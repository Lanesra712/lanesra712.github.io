{"pages":[{"title":"文章分类","text":"","link":"/categories/index.html"},{"title":"文章标签","text":"","link":"/tags/index.html"},{"title":"墨墨墨墨小宇","text":".NET软件开发工程师 / .NET Programmer 性别：男 毕业院校：安徽信息工程学院 / 计算机与软件工程学院 / 网络工程（2014/09 - 2018/06） 工作地：安徽省合肥市 我是谁 / Who AM I 96年生人，出生于安徽某四线城市，毕业于Top 10000000 院校。.NET 程序员，枪手死忠，喵星人。于 2016 年 12 月开始 .NET 程序员生涯，微软 .NET 技术的坚定坚持者，饱经摧残，却依然对各种新技术保持热忱之心，中度强迫症，喜欢简洁、符合规范的代码，不转 Java，立志成为云养猫的少年中面向谷歌编程最厉害的 .NET 程序员。 技能树 / Skill Tree 熟悉基于 C# 的 .NET 平台下的 B/S 开发，熟悉 ASP.NET Core 开发，可以熟练使用 .NET Fx or .NET Core 版本的 MVC、Web API 进行项目开发 熟悉 SQL Server、MySQL、PostgreSQL 的数据库语句编写 熟悉 HTML、CSS、JavaScript / Jquery、Boostrap 等前端开发相关技能，能够上手开发 Angular、Vue 项目 了解 docker 的相关基础使用 可以进行软件开发过程中各种文档的编写 冰阔落 / Buy me a ice cola如果我的文章对你有丢丢的帮助，那么，你想请我喝口冰阔落吗？","link":"/about/index.html"}],"posts":[{"title":"在 ASP.NET Core 项目中使用 npm 管理你的前端组件包","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在项目的前端开发中，对于绝大多数的小伙伴来说，当然，也包括我，不可避免的需要在项目中使用到一些第三方的组件包。这时，团队中的小伙伴是选择直接去组件的官网上下载，还是图省事直接在网上搜索，然后从一些来源不明的地方下载，我们就无法管控了。同时，我们添加的组件间可能存在各种依赖关系，如果我们没有正确下载引用的话，到最后可能还是无法正常使用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，如何从可信的源下载组件包，以及如何轻松的解决各个组件间的依赖关系就成了我们需要解决的问题，那么，有没有一种工具可以帮我们解决这一问题？你好，有的，npm 了解一下。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仓储地址：https://github.com/Lanesra712/ingos-common/tree/master/sample/aspnetcore/aspnetcore-npm-tutorial Step by Step&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 .NET Framework 的项目中，我们可以在项目中通过 Nuget 下载安装前端的组件包。但是 Nuget 更多的是作为 .NET 后端项目中的包管理器，在这里管理前端的组件包显得有些不太合适。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是，在 .NET Core 的时代到来后，伴随着前端的发展，微软在创建的示例项目中开始推荐我们使用 bower 来管理我们项目中的前端组件包，然后，bower is dead。。。。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以这里，我采用 npm 作为我们的 ASP.NET Core 项目中的前端包管理器。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一、安装 Node 环境&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node.js 是一个能够在服务端运行 Javascript 的执行环境，也就是说，Javascript 不仅可以用于前端，也可以构建后端服务了。而 npm 则是 Node.js 官方提供的包管理工具，所以在使用 npm 之前，需要在我们的电脑上安装 Node.js 环境。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，如果你之前有开发过 Vue、Angular 这类的前端项目，你肯定已经安装好了。如果没有，打开 Node.js 的官网（https://nodejs.org/en/download），根据你正在使用的操作系统信息，选择安装包下载就可以了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你使用的是 window 系统，很简单，下载 msi 安装包，一路 next 即可。在最新版本的 Node.js 安装包中，npm 是随着 Node.js 的安装一起完成的。我们可以使用下面的命令进行验证，当可以打印出你安装的版本信息，则说明安装已经完成了。12345//1、node.js 版本node -v//2、npm 版本npm -v &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、使用 npm 安装包&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇文章的示例项目，我采用的是 ASP.NET Core 2.2 默认生成的 MVC 项目，因为在写文章的过程中有过更换解决方案，所以文章中的截图可能会出现名称前后不对应的情况，还请见谅。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当示例项目创建完成后，会自动在项目中引用 bootstrap 和 jquery，所以，我们就在这个项目的基础上，尝试采用 npm 来管理我们的前端组件包。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;右击我们的项目，添加一个 package.json 配置文件。在这个 json 文件中定义了这个项目所需要的各种前端模块，以及项目的配置信息（比如名称、版本、许可证等等）。当我们从别处拷贝这个项目后，通过执行 npm install 命令，就会根据这个配置文件，自动下载项目中所需要引用的前端组件包。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打开 package.json 文件，如果你选择使用 VS 进行编辑的话，可以看到 VS 会自动帮我们出现代码补齐提示。这里我添加了一个 dependencies 节点，它与 devDependencies 节点都代表我们项目中需要安装的插件。不同的是，devDependencies 里面的插件只用于开发环境，不用于生产环境，而 dependencies 中引用的则是需要发布到生产环境中的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，这里我们需要在项目中添加 bootstrap 和 jquery，因为在正式发布时如果缺少这两个组件，就会导致我们的程序报错，所以这里我们需要添加到 dependencies 节点下，而像后面我们使用到的 gulp 的一系列插件，只有在我们进行项目开发时才会使用到，所以我们只需要添加到 devDependencies 即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我推荐使用命令行的方式添加组件，可以更好地展示出我们添加的组件需要添加哪些依赖。右键选中我们的示例项目，选择 Open Command Line，打开控制台，输入下列的命令，将 bootstrap 添加到我们的项目中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 install 命令中我们添加了 –save 修饰，表示需要将 bootstrap 添加到 dependencies 节点下面。如果，你需要将引用到的 package 安装到 devDependencies 节点下，则需要使用 –save-dev 修饰。1npm install bootstrap --save &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到，安装完成后，npm 提示我们 bootstrap 依赖于 jquery 和 popper.js，所以这里我们手动添加上这两个依赖的组件。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们安装 jquery 的 1.9.1 版本后，因为之前的 jquery 版本存在一些安全隐患，所以 npm 会提示我们执行 npm audit 命令来查看当前项目中可能存在的安全隐患，以及对于如何解决这些隐患的建议。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我进行了版本升级，你可以根据自己的需求进行操作。请特别注意，当你在完成项目的基础包加载后，后续对于包版本的升级一定要谨慎、谨慎、再谨慎。升级完成后的 package.json 文件如下所示。1234567891011{ \"version\": \"1.0.0\", \"name\": \"aspnetcore.npm.tutorial\", \"private\": true, \"devDependencies\": {}, \"dependencies\": { \"bootstrap\": \"^4.3.1\", \"jquery\": \"^3.4.1\", \"popper.js\": \"^1.14.7\" }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们第一次执行 npm install 命令时，系统自动为我们创建了 package-lock.json 这个文件，用来记录当前状态下实际安装的各个 npm package 的具体来源和版本号，当前项目下的 package-lock.json 文件如下。1234567891011121314151617181920212223{ \"name\": \"aspnetcore.npm.tutorial\", \"version\": \"1.0.0\", \"lockfileVersion\": 1, \"requires\": true, \"dependencies\": { \"bootstrap\": { \"version\": \"4.3.1\", \"resolved\": \"https://registry.npmjs.org/bootstrap/-/bootstrap-4.3.1.tgz\", \"integrity\": \"sha512-rXqOmH1VilAt2DyPzluTi2blhk17bO7ef+zLLPlWvG494pDxcM234pJ8wTc/6R40UWizAIIMgxjvxZg5kmsbag==\" }, \"jquery\": { \"version\": \"3.4.1\", \"resolved\": \"https://registry.npmjs.org/jquery/-/jquery-3.4.1.tgz\", \"integrity\": \"sha512-36+AdBzCL+y6qjw5Tx7HgzeGCzC81MDDgaUP8ld2zhx58HdqXGoBd+tHdrBMiyjGQs0Hxs/MLZTu/eHNJJuWPw==\" }, \"popper.js\": { \"version\": \"1.14.7\", \"resolved\": \"https://registry.npmjs.org/popper.js/-/popper.js-1.14.7.tgz\", \"integrity\": \"sha512-4q1hNvoUre/8srWsH7hnoSJ5xVmIL4qgz+s4qf2TnJIMyZFUFMGH+9vE7mXynAlHSZ/NdTmmow86muD0myUkVQ==\" } }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么 package-lock.json 这个文件到底有什么用呢？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为我们在 npm 上下载的包遵循了大版本.次要版本.小版本的版本定义。例如，在上面的示例中，我们使用 npm install 命令安装的 bootstrap 版本为 4.3.1，而在安装插件包的时候，package.json 一般指定的是包的范围，即只对插件包的大版本进行限定。因此，当别人拷贝了你的代码，准备还原引用的包时，可能此时的 bootstrap 已经有 4.4.4 版本的了，这时，如果你使用了某些 4.3.1 版本中的特性，而在 4.4.4 版本中已经被移除的话，毫无疑问，你的代码就会出 bug。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而当项目中存在了 package-lock.json 文件之后，因为项目中引用的组件包版本和来源信息已经锁定在了这个文件中了，此时，当别人拷贝了代码，准备还原时，就可以准确的加载到你开发时使用的组件版本。当然，如果你修改了引用的包信息，当执行 npm install 命令时，package-lock.json 文件会同步更新。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于包的版本限定条件如下所示。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指定版本：比如此例中 bootstrap 的版本为 4.3.1，当重新安装时只安装指定的 4.3.1 版本。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;波浪号(tilde) + 指定版本：比如 ~1.2.2，表示安装1.2.x 的最新版本（不低于1.2.2），但是不安装 1.3.x，也就是说安装时不改变大版本号和次要版本号。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;插入号(caret) + 指定版本：比如 ˆ1.2.2，表示安装1.x.x 的最新版本（不低于1.2.2），但是不安装 2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;latest：始终安装包的最新版本。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三、gulp 配置&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们通过 npm 添加好需要使用的组件包后，就需要考虑如何在项目中使用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们知道，在 ASP.NET Core 项目中，对于 web 项目中的静态文件的获取，通常是使用 StaticFileMiddleware 这个中间件。而 “{contentroot}/wwwroot” 这个目录是对外发布项目中的静态文件默认使用的根目录，也就是说，我们需要将使用到的 npm 包移动到 wwwroot 文件下。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;手动复制？em，工作量似乎有点大。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过，既然这里我们使用到了 node.js，那么这里就可以使用 gulp.js 这个自动化任务执行器来帮我们实现这一功能，当然，你也可以根据自己的习惯使用别的工具。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过使用 gulp.js，我们就可以自动的执行移动文件，打包压缩 js、css、image、删除文件等等，帮我们省了再通过 bundle 去打包压缩 css 和 js 文件的过程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在项目中使用 gulp.js 的前提，需要我们作为项目的开发依赖（devDependencies）安装 gulp 和一些用到的 gulp 插件，因为会下载很多的东西，整个安装的过程长短依据你的网络情况而定，嗯，请坐和放宽。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个项目中使用到的 gulp 插件如下所示，如果你需要拷贝下面的命令行的话，在执行时请删除注释内容。1234567891011121314151617181920//gulp.jsnpm install gulp --save-dev//压缩 cssnpm install gulp-clean-css --save-dev//合并文件npm install gulp-concat --save-dev//压缩 jsnpm install gulp-uglify --save-dev//重命名npm install gulp-rename --save-dev//删除文件、文件夹npm install rimraf --save-dev//监听文件变化npm install gulp-changed --save-dev &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装完成后的 package.json 文件如下所示。12345678910111213141516171819{ \"version\": \"1.0.0\", \"name\": \"aspnetcore.npm.tutorial\", \"private\": true, \"devDependencies\": { \"gulp\": \"^4.0.1\", \"gulp-changed\": \"^3.2.0\", \"gulp-clean-css\": \"^4.2.0\", \"gulp-concat\": \"^2.6.1\", \"gulp-rename\": \"^1.4.0\", \"gulp-uglify\": \"^3.0.2\", \"rimraf\": \"^2.6.3\" }, \"dependencies\": { \"bootstrap\": \"^4.3.1\", \"jquery\": \"^3.4.1\", \"popper.js\": \"^1.14.7\" }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们安装好所有的 gulp 组件包之后，在我们的项目根路径下创建一个 gulpfile.js 文件，文件的内容如下所示。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/// &lt;binding BeforeBuild='min' Clean='clean' ProjectOpened='auto' /&gt;\"use strict\";//加载使用到的 gulp 插件const gulp = require(\"gulp\"), rimraf = require(\"rimraf\"), concat = require(\"gulp-concat\"), cssmin = require(\"gulp-clean-css\"), rename = require(\"gulp-rename\"), uglify = require(\"gulp-uglify\"), changed = require(\"gulp-changed\");//定义 wwwroot 下的各文件存放路径const paths = { root: \"./wwwroot/\", css: './wwwroot/css/', js: './wwwroot/js/', lib: './wwwroot/lib/'};//csspaths.cssDist = paths.css + \"**/*.css\";//匹配所有 css 的文件所在路径paths.minCssDist = paths.css + \"**/*.min.css\";//匹配所有 css 对应压缩后的文件所在路径paths.concatCssDist = paths.css + \"app.min.css\";//将所有的 css 压缩到一个 css 文件后的路径//jspaths.jsDist = paths.js + \"**/*.js\";//匹配所有 js 的文件所在路径paths.minJsDist = paths.js + \"**/*.min.js\";//匹配所有 js 对应压缩后的文件所在路径paths.concatJsDist = paths.js + \"app.min.js\";//将所有的 js 压缩到一个 js 文件后的路径//使用 npm 下载的前端组件包const libs = [ { name: \"jquery\", dist: \"./node_modules/jquery/dist/**/*.*\" }, { name: \"popper\", dist: \"./node_modules/popper.js/dist/**/*.*\" }, { name: \"bootstrap\", dist: \"./node_modules/bootstrap/dist/**/*.*\" },];//清除压缩后的文件gulp.task(\"clean:css\", done =&gt; rimraf(paths.minCssDist, done));gulp.task(\"clean:js\", done =&gt; rimraf(paths.minJsDist, done));gulp.task(\"clean\", gulp.series([\"clean:js\", \"clean:css\"]));//移动 npm 下载的前端组件包到 wwwroot 路径下gulp.task(\"move\", done =&gt; { libs.forEach(function (item) { gulp.src(item.dist) .pipe(gulp.dest(paths.lib + item.name + \"/dist\")); }); done()});//每一个 css 文件压缩到对应的 min.cssgulp.task(\"min:css\", () =&gt; { return gulp.src([paths.cssDist, \"!\" + paths.minCssDist], { base: \".\" }) .pipe(rename({ suffix: '.min' })) .pipe(changed('.')) .pipe(cssmin()) .pipe(gulp.dest('.'));});//将所有的 css 文件合并打包压缩到 app.min.css 中gulp.task(\"concatmin:css\", () =&gt; { return gulp.src([paths.cssDist, \"!\" + paths.minCssDist], { base: \".\" }) .pipe(concat(paths.concatCssDist)) .pipe(changed('.')) .pipe(cssmin()) .pipe(gulp.dest(\".\"));});//每一个 js 文件压缩到对应的 min.jsgulp.task(\"min:js\", () =&gt; { return gulp.src([paths.jsDist, \"!\" + paths.minJsDist], { base: \".\" }) .pipe(rename({ suffix: '.min' })) .pipe(changed('.')) .pipe(uglify()) .pipe(gulp.dest('.'));});//将所有的 js 文件合并打包压缩到 app.min.js 中gulp.task(\"concatmin:js\", () =&gt; { return gulp.src([paths.jsDist, \"!\" + paths.minJsDist], { base: \".\" }) .pipe(concat(paths.concatJsDist)) .pipe(changed('.')) .pipe(uglify()) .pipe(gulp.dest(\".\"));});gulp.task(\"min\", gulp.series([\"min:js\", \"min:css\"]));gulp.task(\"concatmin\", gulp.series([\"concatmin:js\", \"concatmin:css\"]));//监听文件变化后自动执行gulp.task(\"auto\", () =&gt; { gulp.watch(paths.css, gulp.series([\"min:css\", \"concatmin:css\"])); gulp.watch(paths.js, gulp.series([\"min:js\", \"concatmin:js\"]));}); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 gulp.js 中主要有四个 API，就像我们项目中的 gulpfile 更多的是对于第三方插件的使用，而我们只需要通过 pipe 将任务中的每一步操作添加到任务队列中即可。完整的 API 文档，大家可以去官网去详细查看 =&gt; Gulp。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gulp.src：根据匹配、或是路径加载文件；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gulp.dest：输出文件到指定路径；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gulp.task：定义一个任务；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gulp.watch：监听文件变化&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们创建好任务后，删除 wwwroot 路径下的引用的第三方组件包，运行我们的示例项目，毫无疑问，整个页面的样式都已经丢失了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选中 gulpfile.js，右键打开任务运行程序资源管理器。可以看到，系统会自动显示出我们定义的所有任务，这时，我们可以鼠标右键点击任务，选中运行，即可执行我们的任务。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然而，我们手动去执行似乎有些不智能，我们能不能自动执行某些任务呢？答案当然是可以，同样是鼠标右键点击任务，点击绑定菜单选项，我们就将定义好的任务绑定事件上。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，在我的 gulpfile 中，我绑定了三个事件：生成解决方案前执行 min task，清理解决方案时执行 clean task，打开项目时执行 auto task，而 VS 也自动帮我们生成了如下的绑定脚本到我们的 gulpfile 上。1/// &lt;binding BeforeBuild='min' Clean='clean' ProjectOpened='auto' /&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过将绑定事件与 gulp API 进行结合，就可以很好的实现我们的需求。就像这里，我在项目打开时绑定了自动监听文件变化的任务，这时，只要我修改了 css、js 文件，gulp 就会自动帮我们实现对于文件的压缩。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PS：如果你将任务绑定到项目打开的事件上，则是需要下一次打开项目时才能自动执行。 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一章主要是介绍了如何在我们的 ASP.NET Core 项目中通过 npm 管理我们的前端组件包，同时，使用 gulp 去执行一些移动文件、压缩文件的任务。随着这些年前端的发展，前端的开发越来越规范化，也越来越朝后端靠拢了，我们作为传统意义上的后端程序猿，在涉及到前端的开发时，如果可以用到这些可以规范化我们的前端项目的特性，还是极好的。因为自己水平也很菜，很多东西并没有很详细的涉及到，可能还需要你在实际使用中进行进一步的探究，毕竟，实践出真知。","link":"/2019/05/09/ASP-NET-Core-NPM-Tutorial/"},{"title":"构建可读性更高的 ASP.NET Core 路由","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不知你在平时上网时有没有注意到，绝大多数网站的 URL 地址都是小写的英文字母，而我们使用 .NET/.NET Core MVC 开发的项目，因为在 C# 中类和方法名采用的是 Pascal 命名规范，根据 .NET 框架默认的路由规则，项目的 URL 地址会呈现出大小写混合的情况。对于强迫症来说，这种情况绝对不能忍，当然，由于整个项目的 URL 地址大小写混合显示，也无法更清晰的向用户、浏览器表达出当前页面的功能。那么，这篇文章就来介绍下，如何调整我们的 ASP.NET Core 项目的路由规则，从而使我们项目的 URL 地址可读性更高。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PS：在构建 URL 的过程中，采用大写的地址还是采用小写的地址，每个人都会有自己的想法和这样做的理由，这篇文章不讨论两种方案的优劣，只是提供一种构建小写 URL 地址以及让我们的 URL 可读性更高的解决方案，请友善观看，切勿互怼。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仓储地址：https://github.com/Lanesra712/ingos-common/tree/master/sample/aspnetcore/aspnetcore-route Step by Step&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在构建项目的路由时，不管是采用大写的 URL 路由，还是采用小写的 URL 路由，我们首先需要确保的是，我们需要将整个项目的 URL 格式进行统一。不能说一个项目一部分的 URL 地址用大写的，而另一部分采用的是小写的 URL 地址。同时，同一个页面的大写的路径以及小写的路径，虽然最终服务器可能都会将两个地址指向同一个页面，但是对于搜索引擎的收录来说，这无疑是两个页面。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;试想以下，当别人告诉了我们一个有趣的网站，我们从浏览器的地址栏中输入网址进行访问。当我们输入 URL 地址时，不管是中文输入法还是英文输入法，输出的英文字母都是小写的，此时，如果输入的网址中存在大写字母，嗯，我们还需要使用 CapsLock 键进行大小写切换。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，我们知道，对于 Windows 服务器来说，因为对于路径的大小写不敏感，如果我们弄错了地址的大小写，我们还是可以进行正常的访问的，可是，如果将应用部署到 Linux 服务器上的话。。。。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至于更好的可读性，这个概念可能会显得有些主观。简单来说，就是当我们面对一个网址时，我们可以很清楚的通过这个网址知道这个网页的主要内容。例如，当我们看见www.youdomain.com/editor/post/new 这个网址时，虽然可能并没有打开这个网页，但我们还是可以大致猜到这个页面可能是新增文章的。可是，如果你收到的网址是 www.youdomain.com/9rg7f2/i?HXI-D+iaj34 这样的，没人能知道这个页面到底是干啥的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，为了便捷输入，首先我们需要将我们的 URL 地址转换成小写的形式，在 ASP.NET Core 中，微软提供了 RoutingServiceCollectionExtensions.AddRouting 这个扩展方法可以让我们将 URL 地址转换成小写。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打开项目的 Startup.cs 文件，找到 ConfigureServices 方法，在方法体内添加下面的代码。1234services.AddRouting(options =&gt;{ options.LowercaseUrls = true;}); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例项目的顶部链接代码如下所示，运行项目可以看到，通过设置小写路由后，程序根据 Controller 和 Action 自动生成的 URL 地址全部变成了小写。仔细观察可以发现，这里会出现一个问题。在某些特殊的情况下，Area/Controller/Action 可能是由多个英文字母拼接而成的一个混合英文单词，如果把这个混合的单词全部进行小写而不进行拆分的话，整个项目的 URL 可读性更低了。123456789101112131415161718192021222324&lt;header&gt; &lt;nav class=\"navbar navbar-expand-sm navbar-toggleable-sm navbar-light bg-white border-bottom box-shadow mb-3\"&gt; &lt;div class=\"container\"&gt; &lt;a class=\"navbar-brand\" asp-area=\"\" asp-controller=\"Home\" asp-action=\"Index\"&gt;Sample&lt;/a&gt; &lt;button class=\"navbar-toggler\" type=\"button\" data-toggle=\"collapse\" data-target=\".navbar-collapse\" aria-controls=\"navbarSupportedContent\" aria-expanded=\"false\" aria-label=\"Toggle navigation\"&gt; &lt;span class=\"navbar-toggler-icon\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;div class=\"navbar-collapse collapse d-sm-inline-flex flex-sm-row-reverse\"&gt; &lt;ul class=\"navbar-nav flex-grow-1\"&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link text-dark\" asp-area=\"\" asp-controller=\"Home\" asp-action=\"Index\"&gt;Home&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link text-dark\" asp-area=\"\" asp-controller=\"Home\" asp-action=\"Privacy\"&gt;Privacy&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link text-dark\" asp-area=\"\" asp-controller=\"Post\" asp-action=\"DraftSetting\"&gt;Draft Setting&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt;&lt;/header&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Startup 类中的 Configure 方法里，我们定义了针对包含 Area 和不包含 Area 的两个路由模板，整个项目的 URL 都是根据这两个模板进行生成的。那么这里我们是不是可以通过对单个 Controller 或是 Action 指定特殊的 URL 格式呢？12345678910app.UseMvc(routes =&gt;{ routes.MapRoute( name: \"default\", template: \"{controller=Home}/{action=Index}/{id?}\"); routes.MapRoute( name: \"areas\", template: \"{area:exists}/{controller=Home}/{action=Index}/{id?}\");}); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案当然是可以的。在 ASP.NET Core 中，我们可以通过在 Controller 或是 Action 方法上添加 RouteAttribute 的方式将用户自定义路由信息添加到项目的路由表中。例如这里我在 DraftSetting 这个 Action 上使用特性路由的方式手动指定当前 Action 生成特殊的 URL 格式。12345678public class PostController : Controller{ [Route(\"post/draft-setting\")] public IActionResult DraftSetting() { return View(); }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然这样可以解决我们的问题，可以一旦项目有新增页面时，就要手动的指定特性路由地址，这样似乎有些麻烦。那么，如何自动的让程序帮我们实现这一功能呢？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 ASP.NET Core 2.2 版本中，微软为我们提供了参数转换器这一概念，我们可以通过实现 IOutboundParameterTransformer 这个接口，从而将 URL 中路由的值或者是 URL 中路由参数的值按照我们的需求进行转换。就像下面的代码中，我通过实现这个接口，从而实现将多个英文单词生成的混合单词以 hyphen(-) 的形式进行分隔。123456789public class SlugifyParameterTransformer : IOutboundParameterTransformer{ public string TransformOutbound(object value) { return value == null ? null : Regex.Replace(value.ToString(), \"([a-z])([A-Z])\", \"$1-$2\").ToLower(); }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我使用 hyphen(-) 作为 URL 中各个单词间的连字符，是因为对于搜索引擎来说，它会将 - 视为单词间分隔符，采用这种风格的 URL 更有利于搜索引擎收录。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当接口功能实现之后，我们就需要对我们的默认全局路由进行修改。首先，我们需要在路由模板上指定需要替换的路由参数，这里我们指定 Area、Controller、Action 是需要进行路由参数转换的变量。1234567891011app.UseMvc(routes =&gt;{ routes.MapRoute( name: \"default\", template: \"{controller:slugify=Home}/{action:slugify=Index}/{id?}\"); routes.MapRoute( name: \"areas\", template: \"{area:exists:slugify}/{controller:slugify=Home}/{action:slugify=Index}/{id?}\" );}); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当定义好参数转换器以及需要转换的 URL 路由参数后，我们就可以在 AddRouting 方法中通过 ConstraintMap 进行配置需要转换的参数路由值。至此就可以完成我们进行路由参数转换的结果。1234services.AddRouting(options =&gt; { options.ConstraintMap[\"slugify\"] = typeof(SlugifyParameterTransformer); options.LowercaseUrls = true;}); 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本章中，我们主要是调整了 ASP.NET Core 项目中的默认路由，从而使项目的 URL 地址具有更好的可读性。通过使用小写路由和 hyphen(-) 路由，只是构建可读性更高的 URL 地址的第一步，在构建页面时，我们更应该考虑的是如何使用少数的单词就可以让用户清楚当前页面的功能，更简短，更易读的 URL 不仅对于用户，对于搜索引擎也是更友好的。","link":"/2019/05/31/ASP-NET-Core-Route/"},{"title":"ASP.NET Core 实战：使用 ASP.NET Core Web API 和 Vue.js，搭建前后端分离框架","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这几年前端的发展速度就像坐上了火箭，各种的框架一个接一个的出现，需要学习的东西越来越多，分工也越来越细，作为一个 .NET Web 程序猿，多了解了解行业的发展，让自己扩展出新的技能树，对自己的职业发展还是很有帮助的。毕竟，现在都快到9102年了，如果你还是只会 Web Form，或许还是能找到很多的工作机会，可是，这真的不再适应未来的发展了。如果你准备继续在 .NET 平台下进行开发，适时开始拥抱开源，拥抱 ASP.NET Core，即使，现在工作中可能用不到。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;雪崩发生时，没有一片雪花是无辜的，你也不会知道那片雪花，会引起最后的雪崩。有些自说自话，见谅。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系列目录地址：ASP.NET Core 项目实战&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仓储地址：https://github.com/Lanesra712/Grapefruit.VuCore Step by Step&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在整个的开发过程中，后端应用使用 Visual Studio 2017 进行开发，对于前端项目，则是使用 Visual Studio Code 进行开发，嗯，使用专业的工具做相应的事。对于前端的 Vue 项目，我采用的是 Vue CLI 来进行构建的，当然，巨硬也为我们准备了一套 Vue 的模板，这里我没有使用，有需要的可以到附录中进行了解（点此穿越）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一、 项目开发环境搭建&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、 安装 .NET Core&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .NET Core 与之前的 .NET Framework 不一样，它不再紧紧的耦合在 Windows 系统上了，因此，我们可以在支持的操作系统上以安装软件的形式安装我们的 .NET Core 开发环境。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打开官网的下载页面（.NET Downloads），找到 .NET Core，这里因为我们需要在当前环境进行开发，所以需要安装 .NET Core SDK，下载完成后，一路 Next 即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们安装完成后，打开控制台，输入命令，则会显示出我们本机安装的 .NET Core 版本。1dotnet --info ## 或者使用 dotnet --version 查看本机安装的 .NET Core 版本信息 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 .NET Core 中为我们提供了 .NET Core CLI 这一工具使我们使用命令行的方式创建我们的 .NET Core 应用，这里我们还是使用 VS 来创建我们的应用，有兴趣的朋友，可以看看园子里的这篇文章 =》.NET Core dotnet 命令大全&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、 安装 Node.js &amp; Vue CLI&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在整个前后端分离的项目的搭建中，前端的 Vue 项目，是使用 Vue CLI 3 进行搭建的脚手架项目，而 Vue CLI 本质上是一个全局安装的 npm 包，通过安装这一 npm 包可以为我们提供终端里的 vue 命令，因此我们需要使用这一脚手架工具的前提，则是需要我们安装 Node.js 环境。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打开 Node.js 官网（Node.js），选择长期支持版下载，之后一路 Next 下去即可。目前的 Node.js 安装包中已经包含了 npm，因此，我们安装好 Node.js 即可。npm 可以类比于我们 .NET 平台的 Nuget，而默认我们安装的全局组件和缓存默认是在 C:\\Users\\用户名\\AppData\\Roaming 下，如果你想修改缓存的地址或者全局安装的包地址则需要自己配置环境，具体可参考 =》Node.js安装及环境配置之Windows篇&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PS：Vue CLI 3 需要 Node.js 8.9 或更高版本 (推荐 8.11.0+)。123npm uninstall vue-cli -g ## 卸载 vue-cli (1.x or 2.x)node -v ## 查看安装的 Node 版本npm -v ## 查看安装的 npm 版本 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当 Node 环境安装好之后，我们就可以安装 Vue CLI 3 脚手架工具了，如果你之前已经全局安装了旧版本的 vue-cli (1.x 或 2.x)，则需要先卸载旧版本的 Vue CLI。12npm uninstall vue-cli -g ## 卸载 vue-cli (1.x or 2.x)npm install -g @vue/cli &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装之后，我们就可以在命令行中使用 vue 命令。12vue ## 查看 vue 相关帮助信息vue --version ## 查看安装的 vue cli 版本信息 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、 安装 Git&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为代码添加版本控制是必须的，它可以详细的记录你的每一次操作，以及当你的某次作死导致的环境出错时，你可以很快的恢复环境。经常作死的表示，这个巨需要。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Git 作为一个分布式的版本控制系统，与 SVN 这种集中式的版本控制系统不同，我们的本地仓库不仅包含了我们的代码，还包含了每个人对代码的操作历史 log，而 SVN 的历史操作记录只存在于中央仓库中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样有什么好处呢？假如，某天中央仓库出错了需要重新创建，因为我们本地的代码不包含操作历史 log，你只能把代码重新放置到中央仓库，而文件的历史版本却丢失了。如果使用 Git 进行版本控制的话，因为我们本地的仓库是一个完整的包含历史操作记录的仓库，我们就可以毫无差别的重新搭建一个中央仓库。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Git 方面的学习教程，可以看看廖雪峰大神写的这一系列的教程 =》Git 教程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打开 Git 官网（Git）下载安装包安装，一路 Next 即可。安装完成后，开始菜单里出现 Git Bash 这个应用，则说明我们的 Git 已经安装成功了。安装 Git 之后，我们需要设置我们的名字以及 Email，从而表明我们的身份，这里使用 Git Bash 设置即可。12git config --global user.name \"Your Name\" ## 全局设置用户名git config --global user.email \"email@example.com\" ## 全局设置邮箱 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、 应用整体框架搭建&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们安装好项目开发的环境之后就可以搭建我们的项目框架了，这里我选择将前后端的项目放到同一个 Git 仓储中，你也可以根据你自己的喜好放到多个 Git 仓储中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新建一个文件夹作为仓储，在创建好的文件夹路径下打开 Git Bash，初始化我们的仓储。如果你勾选了显示隐藏文件夹，则会发现，当我们执行好初始化的命令之后，则会在当前文件夹下创建一个 .git 文件夹。1git init &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，你也可以使用 VS 进行创建 Git 仓储，使用 VS 创建仓储后会自动帮我们创建 .gitignore 和 .gitattributes 文件，同样的，后续对于该仓储的任何 Git 操作，我们也可以通过 VS 进行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gitignore 文件表示我们需要忽略的文件或目录，而 gitattribute 则用于设置非文本文件的对比方式，这里我们使用 VS 创建 Git 仓储后生成的 gitignore 文件默认会添加 .NET 项目需要忽略提交的文件和目录。因为，前端的项目我是使用 VS Code 进行开发的，这里，我需要将一些 VS Code 生成的文件也添加到 gitignore 文件中。12345.vscode/*!.vscode/settings.json!.vscode/tasks.json!.vscode/launch.json!.vscode/extensions.json &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建 ASP.NET Core Web API 的具体过程就不演示了，这里采用的就是基础的多层架构，当我们创建好项目之后，可以看到 VS 右下角铅笔 icon 处会显示我们未做提交的修改。点击 icon ，输入我们的提交信息后，就可以将我们的修改提交到仓储中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后端的 API 接口应用创建好了，现在我们使用 Vue CLI 来构建我们前端的 Vue 项目。这里，我选择在解决方案的根目录创建我们的前端项目。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Vue CLI 3 中，我们不仅可以使用 vue create 命令来创建我们的项目，而且可以使用图形化的页面创建我们的应用。12vue create project-name ## 使用命令行的形式创建vue ui ## 使用图形化的方式创建 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当使用 vue ui 命令后会自动打开创建项目的页面，可以看到，这个路径下，并没有创建好的项目，你可以选择从别的路径下导入，或者是直接创建新的项目。如果你有使用过 Vue CLI 之前的版本，使用大写字母创建项目时是会报错的，但是在 Vue CLI 3 版本中没有出现这种问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为我将前端项目与后端的项目放到同一个仓储中，所以这里就不需要再进行初始化 git 仓库了，对于项目的配置，这里就采用默认的配置。点击创建之后就会自动搭建我们的项目。如何启动这个脚手架项目，可以按照生成的 README 文件中的步骤执行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到这里，基础的 Vue 脚手架项目就已经搭建完成了，对于添加插件之类的内容，放到我们后面的内容中。另外，虽然我们在创建项目时并没有勾选初始化 Git 仓储，但是 Vue CLI 还是创建了一个 gitignore 文件，如果你和我一样，是将前后端项目放到一个仓储的话，可以把这个文件里的内容复制到项目根目录中的 gitignore 文件中，然后把这个文件删除。 附录&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;微软官方有提供一套 Vue 的 SPA 应用模板，不过并没有显示在我们使用 VS 创建项目的页面中，而且需要我们添加一个插件之后，使用 .NET Core CLI 的方式创建。因为自己并没有详细了解这块的内容，这里只列出创建的方法，详细的介绍请查看微软的官方文档（Building Single Page Applications on ASP.NET Core with JavaScriptServices ）。12## 安装 SPA 模板dotnet new --install Microsoft.AspNetCore.SpaTemplates::* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当你安装好模板之后，可以看到，多了使用 Aurelia、Vue、Knockout 创建 SPA 模板的选项，这时我们就可以使用 dotnet new 命令来创建包含 Vue 的模板应用。模板创建完成后需要安装依赖的包。加载完依赖的包之后，我们就可以通过 VS 或 VS Code 开发调试我们的项目。12dotnet new vue ## 创建 Vue SPA 项目npm install ## 还原依赖的 npm 包 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一章没有包含很多的内容，主要就是如何搭建我们的 .NET Core 和 Vue 的开发环境，以及创建我们的项目架构，在后面的文章中则会慢慢的阐述整个项目的开发过程，希望可以能对你有一丢丢的帮助。","link":"/2018/12/18/ASP-NET-Core-on-Linux-01/"},{"title":"ASP.NET Core 实战：使用 NLog 将日志信息记录到 MongoDB","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在项目开发中，日志系统是系统的一个重要组成模块，通过在程序中记录运行日志、错误日志，可以让我们对于系统的运行情况做到很好的掌控。同时，收集日志不仅仅可以用于诊断排查错误，由于日志同样也是大量的数据，通过对这些数据进行集中分析，可以产生极大的价值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在微服务的系统架构中，由于一个系统会被拆成很多个功能模块，每个模块负责不同的功能，对于日志系统的要求也会更高，比较常见的有 EFLK(ElasticSearch + Filebeat + LogStash + Kibana) 方案，而对于我们这种单体应用来说，由于程序的代码比较集中，所以我们主要采用手写日志帮助类或是使用第三方组件的形式进行日志信息的记录。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系列目录地址：ASP.NET Core 项目实战&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仓储地址：https://github.com/Lanesra712/Grapefruit.VuCore Step by Step&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一、 为什么选择 NLog 和 MongoDB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 ASP.NET Core 中，巨硬为我们提供了一个 ILogger 接口，通过 ILogger 接口，我们可以很方便的将日志信息输出到控制台中，不过，在控制台中查看日志信息会显得不太方便，因此，我们可以通过实现该接口或是直接使用第三方的框架来实现将日志信息记录到别的存储介质中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 .NET Framework 时代，对于第三方的日志框架的选择，绝大多数童鞋首选的都会是 log4net 这一根据 Log4j 移植的日志框架，不过，由于 log4net 目前已经接近有3年的时间没更新了，所以就不在考虑范围内。综合比较下官方文档中推荐的几款第三方日志框架，最终还是选择 NLog 这一目前使用人数相对来说比较多的框架，毕竟用户多的话，遇到什么问题也好找资料。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，我们会将日志信息记录到 txt or log 文件中，虽然你可以通过修改日志布局让日志信息具有良好的可读性，不过在信息多的情况下查阅时还是会显得不太方便。因为不仅做到对于错误信息做到记录，还需要记录程序在运行时的访问日志，所以将日志信息写入到关系型数据库中就不是特别合适了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而 MongoDB 作为一个文档型的 NoSQL 数据库，相比于传统的关系型数据库，NoSQL 数据库具有更好的扩展性、以及能提供更出色的性能，因此，我最终选择将日志信息记录到 MongoDB 中。当然，最主要的原因还是目前在工作中有开始尝试用 MongoDB 存储用户上传的文件，在找资料的过程中看到有使用 MongoDB 存储日志的案例，Grapefruit.VuCore 既然作为一个学习项目，所以就要多尝试尝试啊。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、 安装 MongoDB（Windows）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为是第一次使用 MongoDB，所以我们需要提前安装 MongoDB Server，我是直接安装到我的开发机上(Windows 10)，所以这里只是演示如何在 Windows 上进行 MongoDB 的安装与配置，如何在 Linux or Docker 中进行安装配置，我将在后面的文章中进行演示。毕竟，这个项目的最终准备通过 Docker 部署到 Linux 上的，总在 Windows 上玩是不合适滴。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，打开 MongoDB 官网获取到我们的安装包下载地址（MongoDB Community Download），选择 Server tab 后按照我们的操作系统选择安装包下载即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;双击下载好的 msi 文件，开始安装，这里我选择 Complete（完整）安装，如果你想要指定安装的组件和安装的位置，你可以选择 Custom（自定义安装）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 MongoDB 之前的版本中，如果我们需要将 MongoDB Server 作为 Windows 服务，需要我们在安装完成之后进行配置，但是从 MongoDB 4.0 开始，我们就可以在安装期间直接配置和启动我们的 MongoDB 作为 Windows 服务了，当我们安装成功后就会自动启动 MongoDB 服务。嗯，相信我，如果你上网搜索 Windows 下的 MongoDB 安装，你会发现 90% 的文章因为是针对 MongoDB 之前版本的，都会在安装完成之后需要你指定日志地址、指定存储地址，配置 Windows 服务啊，而如果你和我一样，安装的是 MongoDB 4.0 以上的版本，这些统统都不要，是不是很超值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里勾选上 Install MongoD as a Service，当我们安装完成后就会自动启动 MongoDB 服务，同时，对于这里的配置项，我们不做任何的改动。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Service Name：创建的 Windows 服务名称，如果已经存在了，则需要更换名称&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Data Directory：存储数据的目录&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Log Directory：存储 MongoDB Log 日志的目录&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;点击 Next 之后，安装程序会询问你是否需要安装 MongoDB Compass，MongoDB Compass 是官方的一个可视化管理工具，毕竟总是用黑乎乎的 shell 还是不太方便的，这里看你自己的需求，决定是否安装这个工具。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们安装完成后，MongoDB 的服务也就已经启动了，此时，你就可以连接上你的 MongoDB Server 了，这里我是使用 Navicat 进行连接。对于这个服务，你同样可以在计算机管理中对这个服务进行管理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在默认情况下，当我们安装好 MongoDB 后是不允许远程访问以及不存在任何的用户权限的。而这些，在我们正式使用中都是需要考虑的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，配置我们的 MongoDB Server 以允许用户进行远程访问。找到程序安装路径下面的 mongod.cfg 文件（如果你使用的是默认配置，则该文件位于 C:\\Program Files\\MongoDB\\Server\\4.0\\bin），修改 bindIp 属性值为 0.0.0.0，重启 MongoDB 服务，确保 27017 端口外界可以访问后，则可以远程访问我们的 MongoDB 服务。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们允许远程访问我们的 MongoDB 服务后，我们更应该为 MongoDB 配置权限。与我们经常使用的 SQL Server 或是 MySQL 不同，MongoDB 中的权限是针对每一个数据库的，也就是说我们需要为使用到的数据库创建用户并配置权限。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打开 Navicat，连接安装好的 MongoDB 服务。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一步将默认数据库切换到 admin 数据库，创建一个管理员用户，这里我就将管理员用户的角色设置为 root 用户。1234567891011//切换到 admin 数据库use admin//创建一个管理员用户db.createUser( { user: \"user name\", pwd: \"user password\", roles: [ { role: \"root\", db: \"admin\" } ] }) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们创建好管理员用户后，我们就可以为数据库配置用户与权限了。右击连接名称，新建一个数据库 GrapefruitVuCore，切换到 GrapefruitVuCore 数据库后，新建一个可以读写的用户 grapefruit。用户都创建完成后，关闭我们的 MongoDB 连接。1234567891011//切换到需要授权的数据库use GrapefruitVuCore//创建普通用户db.createUser( { user: \"grapefruit\", pwd: \"grapefruit\", roles: [ { role: \"readWrite\", db: \"GrapefruitVuCore\" } ] }) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当用户已经创建完成之后，我们就可以修改配置文件，启用权限控制。还是在 mongod.cfg 中，取消 security 节点的注释，添加授权配置，修改完成后，重启服务，此时，MongoDB 就必须通过账户密码登录了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当服务重启之后，如果你还是按照之前的方式连接，则会提示你权限不足，你需要修改 Navicat 的连接配置。将验证方式修改成 Password，输入账户、密码，并指定需要登录的数据库，重新连接即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PS：这里，我使用账户、密码登录进入 GrapefruitVuCore 后，右侧的连接下面是没有显示这个数据库的，但这个数据库是真实存在的，不晓得这是个啥问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MongoDB 内置的用户角色权限：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Read：允许用户读取授权的数据库&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;readWrite：允许用户读写授权的数据库&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dbAdmin：允许用户在授权的数据库中执行管理操作，如索引创建、删除，查看统计或访问system.profile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userAdmin：允许用户向 system.users 集合写入，可以在指定数据库里创建、删除和管理用户&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clusterAdmin：只在 admin 数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;readAnyDatabase：只在 admin 数据库中可用，赋予用户所有数据库的读权限&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;readWriteAnyDatabase：只在 admin 数据库中可用，赋予用户所有数据库的读写权限&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userAdminAnyDatabase：只在 admin 数据库中可用，赋予用户所有数据库的 userAdmin 权限&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dbAdminAnyDatabase：只在 admin 数据库中可用，赋予用户所有数据库的 dbAdmin 权限。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root：只在admin数据库中可用。超级账号，超级权限 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三、 使用 NLog 记录日志信息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们安装配置好 MongoDB 后，有了存储日志信息的介质，我们就可以使用 NLog 来记录我们的程序日志信息了。首先，我们需要为项目中添加对于 NLog 的引用，右击 Grapefruit.WebApi 打开管理 Nuget 程序包页面或是使用程序包管理器控制台选中默认项目为 Grapefruit.WebApi，添加 NLog、NLog.Web.AspNetCore、NLog.Mongo。123Install-Package NLogInstall-Package NLog.Web.AspNetCoreInstall-Package NLog.Mongo &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NLog 和 NLog.Web.AspNetCore 为 ASP.NET Core 添加了对于 NLog 的平台支持，在 NLog 中，我们可以通过继承 NLog.Targets.TargetWithLayout 来为 NLog 添加更多的输出介质支持，而 NLog.Mongo 就是为 NLog 添加输出日志信息到 MongoDB 的支持。嗯，尝试了自己写，一直有问题，最后还是用的别人写好的，哈哈哈，水平太菜。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们添加好引用后，在 Grapefruit.WebApi 下添加一个 NLog 的配置文件 nlog.config（文件名全部需要小写），右键 nlog.config，打开属性窗口，将复制到输出目录修改成较新才复制或是总是复制都可以。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在配置文件中，nlog 节点必须是 xml 文件的根节点，同时包含三个主要的子节点：extensions、targets、rules。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extensions：当你不仅仅只使用 NLog 这一个基础的 dll ，并使用了一些基于 NLog 扩展的工具时，你就需要在 extensions 节点下面添加引用的程序集名称。例如，这里，我添加了 NLog.Web.AspNetCore 这个程序集从而达到 NLog 对于 ASP.NET Core 的支持，以及添加了 NLog.Mongo 这个程序集用来将日志信息输出到 MongoDB 中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;targets：targets 节点下包含了我们需要输出的日志的信息内容以及日志信息的布局，例如，这里我按照日期输出两个文件 nlog-all-date.log 和 nlog-own-date.log，分别记录所有的日志信息以及我们自定义记录的信息。因为我们是需要将日志信息写入 MongoDB 中的，这里我也添加了一个子节点用来设置写入 MongoDB 数据库中的数据字段。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rules：rules 节点是将需要记录的日志级别关联到记录日志的方式上。这里，我是将只要是 Trace 以上的都进行日志记录。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;nlog xmlns=\"http://www.nlog-project.org/schemas/NLog.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" autoReload=\"true\" internalLogLevel=\"info\" internalLogFile=\"c:\\Temp\\GrapefruitVuCore\\internal-nlog.txt\"&gt; &lt;!-- enable asp.net core and mongodb layout renderers --&gt; &lt;extensions&gt; &lt;add assembly=\"NLog.Web.AspNetCore\"/&gt; &lt;add assembly=\"NLog.Mongo\"/&gt; &lt;/extensions&gt; &lt;!--internal-nlog:NLog启动及加载config信息--&gt; &lt;!--nlog-all:所有日志记录信息--&gt; &lt;!--nlog-own:自定义日志记录信息--&gt; &lt;!-- the targets to write to --&gt; &lt;targets&gt; &lt;!-- write logs to file --&gt; &lt;target xsi:type=\"File\" name=\"allfile\" fileName=\"c:\\Temp\\GrapefruitVuCore\\nlog-all-${shortdate}.log\" layout=\"日志记录时间：${longdate}${newline}日志级别：${uppercase:${level}}${newline}日志来源：${logger}${newline}日志信息：${message}${newline}错误信息：${exception:format=tostring}${newline}==============================================================${newline}\" /&gt; &lt;!-- another file log, only own logs. Uses some ASP.NET core renderers --&gt; &lt;target xsi:type=\"File\" name=\"ownFile-web\" fileName=\"c:\\Temp\\GrapefruitVuCore\\nlog-own-${shortdate}.log\" layout=\"日志记录时间：${longdate}${newline}日志级别：${uppercase:${level}}${newline}日志来源：${logger}${newline}日志信息：${message}${newline}错误信息：${exception:format=tostring}${newline}url: ${aspnet-request-url}${newline}action: ${aspnet-mvc-action}${newline}==============================================================${newline}\" /&gt; &lt;!-- write log to mongodb--&gt; &lt;target xsi:type=\"Mongo\" name=\"mongo\" databaseName=\"GrapefruitVuCore\" collectionName=\"Logs\" connectionString=\"mongodb://grapefruit:grapefruit@localhost:27017/GrapefruitVuCore\" cappedCollectionSize=\"26214400\"&gt; &lt;property name=\"LongDate\" layout=\"${longdate}\" bsonType=\"DateTime\" /&gt; &lt;property name=\"Level\" layout=\"${level}\" /&gt; &lt;property name=\"Logger\" layout=\"${logger}\"/&gt; &lt;property name=\"Message\" layout=\"${message}\" /&gt; &lt;property name=\"Exception\" layout=\"${exception:format=tostring}\" /&gt; &lt;property name=\"Url\" layout=\"${aspnet-request-url}\" /&gt; &lt;property name=\"Action\" layout=\"${aspnet-mvc-action}\" /&gt; &lt;property name=\"UserName\" layout=\"${windows-identity}\" /&gt; &lt;/target&gt; &lt;/targets&gt; &lt;!-- rules to map from logger name to target --&gt; &lt;rules&gt; &lt;!--All logs, including from Microsoft--&gt; &lt;logger name=\"*\" minlevel=\"Trace\" writeTo=\"allfile\" /&gt; &lt;!--Skip non-critical Microsoft logs and so log only own logs--&gt; &lt;logger name=\"Microsoft.*\" maxLevel=\"Info\" final=\"true\" /&gt; &lt;!-- BlackHole without writeTo --&gt; &lt;logger name=\"*\" minlevel=\"Trace\" writeTo=\"ownFile-web\" /&gt; &lt;!--Add logs to mongodb--&gt; &lt;logger name=\"*\" minlevel=\"Trace\" writeTo=\"mongo\"/&gt; &lt;/rules&gt;&lt;/nlog&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们设置好配置文件后就可以在 Program.cs 中启用 NLog 去记录日志。运行我们的项目后，就可以查看记录的日志信息了，这里我在 txt 文件中和 MongoDB 中都有记录日志信息，具体看你自己的需求了。12345678910111213141516171819202122232425262728293031public class Program{ public static void Main(string[] args) { //加载日志配置信息文件后去捕获所有的错误 var logger = NLogBuilder.ConfigureNLog(&quot;nlog.config&quot;).GetCurrentClassLogger(); try { logger.Info(&quot;Init Log API Information&quot;); CreateWebHostBuilder(args).Build().Run(); } catch (Exception ex) { logger.Error(ex, &quot;Stop Log Information Because Of Exception&quot;); } finally { LogManager.Shutdown(); } } public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&gt; WebHost.CreateDefaultBuilder(args) .UseStartup&lt;Startup&gt;() .ConfigureLogging(logging =&gt; { logging.ClearProviders();//移除其它已经注册的日志处理程序 logging.SetMinimumLevel(Microsoft.Extensions.Logging.LogLevel.Trace);//记录最小日志级别 }) .UseNLog();//注入 NLog 服务} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，在 appsettings.json 中指定的 Logging 配置会覆盖任何对于 SetMinimumLevel 方法的调用。因此，你可以删除配置文件中的 default 属性，或是根据你自己的需要进行调整。12345678{ &quot;Logging&quot;: { &quot;LogLevel&quot;: { &quot;Default&quot;: &quot;Trace&quot;, &quot;Microsoft&quot;: &quot;Information&quot; } }} 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本章主要是演示如何在 Windows 上安装 MongoDB Server 以及在 ASP.NET Core 项目中使用 NLog 将日志信息记录到 MongoDB 中。在我们使用这些这些第三方开源框架时，可能会遇到很多问题，当你无法解决的时候，项目的 Issue 是个好地方，多搜搜，很大可能你就会得到解决方案。","link":"/2019/01/05/ASP-NET-Core-on-Linux-03/"},{"title":"ASP.NET Core 实战：基于 Jwt Token 的权限控制全揭露","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在涉及到后端项目的开发中，如何实现对于用户权限的管控是需要我们首先考虑的，在实际开发过程中，我们可能会运用一些已经成熟的解决方案帮助我们实现这一功能，而在 Grapefruit.VuCore 这个项目中，我将使用 Jwt 的方式实现对于用户的权限管控，在本章中，我将演示如何使用 Jwt 实现对于用户的授权、鉴权。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系列目录地址：ASP.NET Core 项目实战&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仓储地址：https://github.com/Lanesra712/Grapefruit.VuCore Step by Step&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一、一些概念&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Jwt(json web token)，是一种基于 Json 的无状态授权令牌，因为 Jwt 是一种标准的数据传输规范，并不是某家所独有的技术规范，因此非常适用于构建单点登录服务，为 web、client、app 等等各种接口使用方提供授权服务。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用 Jwt 进行权限控制的过程中，我们需要先请求授权服务器获取到 token 令牌，将令牌存储到客户端本地（在 web 项目中，我们可以将 token 存储到 localstorage 或是 cookie 中），之后，对于服务端的每一次请求，都需要将获取到的 token 信息添加到 http 请求的 header 中。12345678910$.ajax({ url: url, method: \"POST\", data: JSON.stringify(data), beforeSend: function (xhr) { /* Authorization header */ xhr.setRequestHeader(\"Authorization\", \"Bearer \" + token); }, success: function (data) {}}); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当用户拥有令牌后是否就可以访问系统的所有功能了呢？答案当然否定的。对于一个系统来说可能会有多种用户角色，每一个用户角色可以访问的资源也是不同的，所以，当用户已经拥有令牌后，我们还需要对用户角色进行鉴定，从而做到对用户进行进一步的权限控制。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Grapefruit.VuCore 这个项目中，我采用的是基于策略的授权方式，通过定义一个授权策略来完善 Jwt 鉴权，之后将这个自定义策略注入到 IServiceCollection 容器中，对权限控制做进一步的完善，从而达到对于用户访问权限的管控。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于策略的授权是微软在 ASP.NET Core 中添加的一种新的授权方式，通过定义好策略（policy）的一个或多个要求（requirements），将这个自定义的授权策略在 Startup.ConfigureServices 方法中作为授权服务配置的一部分进行注册之后即可按照我们的策略处理程序进行权限的控制。1234567services.AddAuthorization(options =&gt;{ options.AddPolicy(&quot;Permission&quot;, policy =&gt; policy.Requirements.Add(new PolicyRequirement()));})services.AddSingleton&lt;IAuthorizationHandler, PolicyHandler&gt;(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像我在后面的代码中一样，我定义了一个名叫 Permission 的授权策略，它包含了一个叫做 PolicyRequirement 的鉴权要求，在实现了授权策略后，将基于这个要求的鉴权方法 PolicyHandler 以单例（AddSingleton）的形式注入到服务集合中，此时，我们就可以在需要添加验证的 controller 上添加 attribute 即可。123[Authorize(Policy = &quot;Permission&quot;)]public class SecretController : ControllerBase{} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、授权&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Grapefruit.VuCore 这个项目中，涉及到授权相关的代码所在的位置我已在下图中进行标示。在之前系列开篇文章（ASP.NET Core 实战：使用 ASP.NET Core Web API 和 Vue.js，搭建前后端分离框架）进行介绍整个项目框架时曾说到， Grapefruit.Application 是项目的应用层，顾名思义，就是为了实现我们项目中的实际业务功能所划分的类库。因此，我们实现 Jwt 的相关业务代码应该位于此层中。同时，因为对于 Jwt 的令牌颁发与鉴权，采用的是微软的 JwtBearer 组件，所以我们在使用前需要先通过 Nuget 将引用添加到 Grapefruit.Application 上。12Install-Package Microsoft.AspNetCore.Authentication.JwtBearerInstall-Package System.IdentityModel.Tokens.Jwt &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Grapefruit.Application 这个类库下我创建了一个 Authorization 解决方案文件夹用来存储授权相关的代码。在 Authorization 这个解决方案文件夹中包含了两个子文件夹 Jwt 和 Secret。Jwt 文件夹中主要包含我们对于 Jwt 的操作，而 Secret 文件夹下则是对于用户的相关操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个子应用文件夹（Jwt、Secret）都包含了相同的结构：Dto 数据传输对象、功能接口，以及功能接口的实现类，这里接口的继承采用单继承的方式。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Jwt 文件夹下创建一个 IJwtAppService 接口文件，在这里定义我们对于 Jwt 的相关操作。因为对于 Jwt 的授权、鉴权是采用微软的 JwtBearer 组件，我们只需要进行配置即可，所以这里只定义对于 token 的生成、刷新、停用，以及判断这个 token 是否有效这几个方法。同时，我们需要创建 JwtAppService 这个类文件，去继承 IJwtAppService 从而实现接口功能。123456789101112131415161718192021222324252627282930313233343536373839404142public interface IJwtAppService{ /// &lt;summary&gt; /// 新增 Jwt token /// &lt;/summary&gt; /// &lt;param name=&quot;dto&quot;&gt;用户信息数据传输对象&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; JwtAuthorizationDto Create(UserDto dto); /// &lt;summary&gt; /// 刷新 Token /// &lt;/summary&gt; /// &lt;param name=&quot;token&quot;&gt;Token&lt;/param&gt; /// &lt;param name=&quot;dto&quot;&gt;用户信息数据传输对象&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; Task&lt;JwtAuthorizationDto&gt; RefreshAsync(string token, UserDto dto); /// &lt;summary&gt; /// 判断当前 Token 是否有效 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; Task&lt;bool&gt; IsCurrentActiveTokenAsync(); /// &lt;summary&gt; /// 停用当前 Token /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; Task DeactivateCurrentAsync(); /// &lt;summary&gt; /// 判断 Token 是否有效 /// &lt;/summary&gt; /// &lt;param name=&quot;token&quot;&gt;Token&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; Task&lt;bool&gt; IsActiveAsync(string token); /// &lt;summary&gt; /// 停用 Token /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; Task DeactivateAsync(string token);} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JwtAuthorizationDto 是一个 token 信息的传输对象，包含我们创建好的 token 相关信息，用来将 token 信息返回给前台进行使用。而 UserDto 则是用户登录获取 token 时的数据传输对象，用来接收登录时的参数值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在创建 token 或是验证 token 时，像 token 的颁发者、接收者之类的信息，因为会存在多个地方调用的可能性，这里我将这些信息存放在了配置文件中，后面当我们需要使用的时候，只需要通过注入 IConfiguration 进行获取即可。关于 Jwt 的配置文件主要包含了四项：token 的颁发者，token 的接收者，加密 token 的 key 值，以及 token 的过期时间，你可以根据你自己的需求进行调整。123456\"Jwt\": { \"Issuer\": \"yuiter.com\", \"Audience\": \"yuiter.com\", \"SecurityKey\": \"a48fafeefd334237c2ca207e842afe0b\", \"ExpireMinutes\": \"20\"} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 token 的创建过程中可以简单拆分为三个部分：根据配置信息和用户信息创建一个 token，将加密后的用户信息写入到 HttpContext 上下文中，以及将创建好的 token 信息添加到静态的 HashSet 集合中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 token 创建、校验的整个生命周期中，都涉及到了 Scheme、Claim、ClaimsIdentity、ClaimsPrincipal 这些概念，如果你之前有使用过微软的 Identity 权限验证，对于这几个名词就会比较熟悉，可能某些小伙伴之前并没有使用过 Identity，我来简单介绍下这几个名词的含义。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scheme 模式，这个与其余的名词相对独立，它主要是指明我们是以什么授权方式进行授权的。例如，你是以 cookie 的方式授权或是以 OpenId 的方式授权，或是像这里我们使用 Jwt Bearer 的方式进行授权。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Claim 声明，以我们的现实生活为例，我们每个人都会有身份证，上面会包含我们的姓名、性别、民族、出生日期、家庭住址、身份证号，每一项数据的都可以看成是 type-value（数据类型-数据值），例如，姓名：张三。身份证上的每一项的信息就是我们的 Claim 声明，姓名：张三，是一个 Claim；性别：男，也是一个 Claim。而对于 ClaimsIdentity，就像这一项项的信息最终组成了我们的身份证，这一项项的 Claim 最终组成了我们的 ClaimsIdentity。而 ClaimsPrincipal 则是 ClaimsIdentity 的持有者，就像我们拥有身份证一样。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上面的文字可以总结出，Claim（每一项的证件信息）=》ClaimsIdentity（证件）=》ClaimsPrincipal（证件持有者）。其中，一个 ClaimsIdentity 可以包含多个的 Claim，而一个 ClaimsPrincipal 可以包含多个的 ClaimsIdentity。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果想要深入了解 ASP.NET Core 的授权策略的可以看看园子里这篇文章 =》ASP.NET Core 运行原理解剖[5]:Authentication，或是国外的这篇介绍 ASP.NET Core 授权的文章 =》Introduction to Authentication with ASP.NET Core。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现 token 生成的最终代码实现如下所示，可以看到，在创建 ClaimsIdentity “证件”信息时，我添加了用户的角色信息，并把加密后的用户信息写入到 HttpContext 上下文中，这样，我们在后面验证的时候就可以通过 HttpContext 获取到用户的角色信息，从而判断用户是否可以访问当前请求的地址。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/// &lt;summary&gt;/// 新增 Token/// &lt;/summary&gt;/// &lt;param name=&quot;dto&quot;&gt;用户信息数据传输对象&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public JwtAuthorizationDto Create(UserDto dto){ JwtSecurityTokenHandler tokenHandler = new JwtSecurityTokenHandler(); SymmetricSecurityKey key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_configuration[&quot;Jwt:SecurityKey&quot;])); DateTime authTime = DateTime.UtcNow; DateTime expiresAt = authTime.AddMinutes(Convert.ToDouble(_configuration[&quot;Jwt:ExpireMinutes&quot;])); //将用户信息添加到 Claim 中 var identity = new ClaimsIdentity(JwtBearerDefaults.AuthenticationScheme); IEnumerable&lt;Claim&gt; claims = new Claim[] { new Claim(ClaimTypes.Name,dto.UserName), new Claim(ClaimTypes.Role,dto.Role.ToString()), new Claim(ClaimTypes.Email,dto.Email), new Claim(ClaimTypes.Expiration,expiresAt.ToString()) }; identity.AddClaims(claims); //签发一个加密后的用户信息凭证，用来标识用户的身份 _httpContextAccessor.HttpContext.SignInAsync(JwtBearerDefaults.AuthenticationScheme, new ClaimsPrincipal(identity)); var tokenDescriptor = new SecurityTokenDescriptor { Subject = new ClaimsIdentity(claims),//创建声明信息 Issuer = _configuration[&quot;Jwt:Issuer&quot;],//Jwt token 的签发者 Audience = _configuration[&quot;Jwt:Audience&quot;],//Jwt token 的接收者 Expires = expiresAt,//过期时间 SigningCredentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha256)//创建 token }; var token = tokenHandler.CreateToken(tokenDescriptor); //存储 Token 信息 var jwt = new JwtAuthorizationDto { UserId = dto.Id, Token = tokenHandler.WriteToken(token), Auths = new DateTimeOffset(authTime).ToUnixTimeSeconds(), Expires = new DateTimeOffset(expiresAt).ToUnixTimeSeconds(), Success = true }; _tokens.Add(jwt); return jwt;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当创建好 token 之后，客户端就可以在 Http 请求的 header 中添加 token 信息，从而访问受保护的资源。不过，在某些情况下，比如说，用户修改了密码之后，虽然当前的 token 信息可能还未过期，但我们也不能允许用户再使用当前的 token 信息进行接口的访问，这时，就涉及到了对于 token 信息的停用以及刷新。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我采用是当我们停用 token 信息时，将停用的 token 信息添加到 Redis 缓存中，之后，在用户请求时判断这个 token 是不是存在于 Redis 中即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，你也可以在停用当前用户的 token 信息时，将 HashSet 中的这个 token 信息进行删除，之后，通过判断访问时的 token 信息是否在 HashSet 集合中，判断 token 是否有效。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方法很多，看你自己的需求了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 Redis 的读写操作，我是使用微软的 Redis 组件进行的，你可以按照你的喜好进行修改。如果你和我一样，采用这个组件，你需要在 Grapefruit.Application 这个类库中通过 Nuget 添加微软的分布式缓存抽象接口 dll 的引用，以及在 Grapefruit.WebApi 项目中添加微软的 Redis 实现。12Install-Package Microsoft.Extensions.Caching.Abstractions ## 分布式缓存抽象接口Install-Package Microsoft.Extensions.Caching.Redis ## Redis 实现 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们停用 token 时，通过 HttpContext 上下文获取到 HTTP Header 中的 token 信息，将该 token 信息存储到 Redis 缓存中，这样，我们就完成了对于 token 的停用。12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class JwtAppService : IJwtAppService{ /// &lt;summary&gt; /// 停用 Token /// &lt;/summary&gt; /// &lt;param name=&quot;token&quot;&gt;Token&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task DeactivateAsync(string token) =&gt; await _cache.SetStringAsync(GetKey(token), &quot; &quot;, new DistributedCacheEntryOptions { AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(Convert.ToDouble(_configuration[&quot;Jwt:ExpireMinutes&quot;])) }); /// &lt;summary&gt; /// 停用当前 Token /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task DeactivateCurrentAsync() =&gt; await DeactivateAsync(GetCurrentAsync()); /// &lt;summary&gt; /// 设置缓存中过期 Token 值的 key /// &lt;/summary&gt; /// &lt;param name=&quot;token&quot;&gt;Token&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private static string GetKey(string token) =&gt; $&quot;deactivated token:{token}&quot;; /// &lt;summary&gt; /// 获取 HTTP 请求的 Token 值 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private string GetCurrentAsync() { //http header var authorizationHeader = _httpContextAccessor .HttpContext.Request.Headers[&quot;authorization&quot;]; //token return authorizationHeader == StringValues.Empty ? string.Empty : authorizationHeader.Single().Split(&quot; &quot;).Last();// bearer tokenvalue }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 token 的刷新，其实我们就可以看成重新生成了一个 token 信息，只不过我们需要将之前的 token 信息进行停用。123456789101112131415161718192021222324252627282930313233343536public class JwtAppService : IJwtAppService{ /// &lt;summary&gt; /// 刷新 Token /// &lt;/summary&gt; /// &lt;param name=&quot;token&quot;&gt;Token&lt;/param&gt; /// &lt;param name=&quot;dto&quot;&gt;用户信息&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;JwtAuthorizationDto&gt; RefreshAsync(string token, UserDto dto) { var jwtOld = GetExistenceToken(token); if (jwtOld == null) { return new JwtAuthorizationDto() { Token = &quot;未获取到当前 Token 信息&quot;, Success = false }; } var jwt = Create(dto); //停用修改前的 Token 信息 await DeactivateCurrentAsync(); return jwt; } /// &lt;summary&gt; /// 判断是否存在当前 Token /// &lt;/summary&gt; /// &lt;param name=&quot;token&quot;&gt;Token&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private JwtAuthorizationDto GetExistenceToken(string token) =&gt; _tokens.SingleOrDefault(x =&gt; x.Token == token);} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此，我们对于 token 的创建、刷新、停用的代码就已经完成了，接下来，我们来实现对于 token 信息的验证。PS：下面的代码如无特殊说明外，均位于 Startup 类中。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三、鉴权&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 ASP.NET Core 应用中，依赖注入随处可见，而我们对于我们的功能方法的使用，也是采用依赖注入到容器，通过功能接口进行调用的方式。因此，我们需要将我们的接口与其实现类注入到 IServiceCollection 容器中。这里，我们采用反射的方式，批量的将程序集内的接口与其实现类进行注入。123456789101112public void ConfigureServices(IServiceCollection services){ Assembly assembly = Assembly.Load(&quot;Grapefruit.Application&quot;); foreach (var implement in assembly.GetTypes()) { Type[] interfaceType = implement.GetInterfaces(); foreach (var service in interfaceType) { services.AddTransient(service, implement); } }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为基础的权限验证我们是采用的微软的 JwtBearer 权限验证组件进行的授权和鉴权，因此对于 token 信息的基础鉴权操作，只需要我们在中间件中进行配置即可。同时，我们也在 IJwtAppService 接口中定义了对于 token 信息的一些操作，而对于我们自定义的权限验证策略，则需要通过基于策略的授权方式进行实现。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们需要先定义一个继承于 IAuthorizationRequirement 的自定义授权要求类 PolicyRequirement。在这个类中，你可以定义一些属性，通过有参构造函数的方式进行构造，这里我不定义任何的属性，仅是创建这个类。12public class PolicyRequirement : IAuthorizationRequirement{ } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们创建好 PolicyRequirement 这个权限要求类后，我们就可以通过继承 AuthorizationHandler 来实现我们的授权逻辑。这里实现权限控制的代码逻辑，主要是通过重写 HandleRequirementAsync 方法来实现的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657protected override async Task HandleRequirementAsync(AuthorizationHandlerContext context, PolicyRequirement requirement){ //Todo：获取角色、Url 对应关系 List&lt;Menu&gt; list = new List&lt;Menu&gt; { new Menu { Role = Guid.Empty.ToString(), Url = &quot;/api/v1.0/Values&quot; }, new Menu { Role=Guid.Empty.ToString(), Url=&quot;/api/v1.0/secret/deactivate&quot; }, new Menu { Role=Guid.Empty.ToString(), Url=&quot;/api/v1.0/secret/refresh&quot; } }; var httpContext = (context.Resource as AuthorizationFilterContext).HttpContext; //获取授权方式 var defaultAuthenticate = await Schemes.GetDefaultAuthenticateSchemeAsync(); if (defaultAuthenticate != null) { //验证签发的用户信息 var result = await httpContext.AuthenticateAsync(defaultAuthenticate.Name); if (result.Succeeded) { //判断是否为已停用的 Token if (!await _jwtApp.IsCurrentActiveTokenAsync()) { context.Fail(); return; } httpContext.User = result.Principal; //判断角色与 Url 是否对应 // var url = httpContext.Request.Path.Value.ToLower(); var role = httpContext.User.Claims.Where(c =&gt; c.Type == ClaimTypes.Role).FirstOrDefault().Value; var menu = list.Where(x =&gt; x.Role.Equals(role) &amp;&amp; x.Url.ToLower().Equals(url)).FirstOrDefault(); if (menu == null) { context.Fail(); return; } return; } } context.Fail();} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在判断用户是否可以访问当前的请求地址时，首先需要获取到用户角色与其允许访问的地址列表，这里我使用的是模拟的数据。通过判断当前登录用户的角色是否包含请求的地址，当用户的角色并不包含对于访问地址的权限时，返回 403 Forbidden 状态码。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里需要注意，如果你准备采取 RESTful 风格的 API，因为请求的地址是相同的，你需要添加一个 HTTP 谓词参数用来指明所请求的方法，从而达到访问权限管控的目的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;包含 token 的基础验证的授权配置的代码如下所示。在中间件进行 Jwt 验证的过程中，会验证授权方式是不是 Bearer 以及通过 token 的属性解密之后与生成时用户数据进行比对，从而判断这个 token 是否有效。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public void ConfigureServices(IServiceCollection services){ string issuer = Configuration[&quot;Jwt:Issuer&quot;]; string audience = Configuration[&quot;Jwt:Audience&quot;]; string expire = Configuration[&quot;Jwt:ExpireMinutes&quot;]; TimeSpan expiration = TimeSpan.FromMinutes(Convert.ToDouble(expire)); SecurityKey key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(Configuration[&quot;Jwt:SecurityKey&quot;])); services.AddAuthorization(options =&gt; { //1、Definition authorization policy options.AddPolicy(&quot;Permission&quot;, policy =&gt; policy.Requirements.Add(new PolicyRequirement())); }).AddAuthentication(s =&gt; { //2、Authentication s.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme; s.DefaultScheme = JwtBearerDefaults.AuthenticationScheme; s.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme; }).AddJwtBearer(s =&gt; { //3、Use Jwt bearer s.TokenValidationParameters = new TokenValidationParameters { ValidIssuer = issuer, ValidAudience = audience, IssuerSigningKey = key, ClockSkew = expiration, ValidateLifetime = true }; s.Events = new JwtBearerEvents { OnAuthenticationFailed = context =&gt; { //Token expired if (context.Exception.GetType() == typeof(SecurityTokenExpiredException)) { context.Response.Headers.Add(&quot;Token-Expired&quot;, &quot;true&quot;); } return Task.CompletedTask; } }; }); //DI handler process function services.AddSingleton&lt;IAuthorizationHandler, PolicyHandler&gt;();} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为我们是使用 Swagger 进行的 API 文档的可视化，这里，我们继续配置 Swagger 从而使 Swagger 可以支持我们的权限验证方式。12345678910111213141516171819public void ConfigureServices(IServiceCollection services){ services.AddSwaggerGen(s =&gt; { //Add Jwt Authorize to http header s.AddSecurityDefinition(&quot;Bearer&quot;, new ApiKeyScheme { Description = &quot;JWT Authorization header using the Bearer scheme. Example: \\&quot;Authorization: Bearer {token}\\&quot;&quot;, Name = &quot;Authorization&quot;,//Jwt default param name In = &quot;header&quot;,//Jwt store address Type = &quot;apiKey&quot;//Security scheme type }); //Add authentication type s.AddSecurityRequirement(new Dictionary&lt;string, IEnumerable&lt;string&gt;&gt; { { &quot;Bearer&quot;, new string[] { } } }); });} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在停用 token 的代码中，我们使用了 Redis 去保存停用的 token 信息，因此，我们需要配置我们的 Redis 连接。1234567public void ConfigureServices(IServiceCollection services){ services.AddDistributedRedisCache(r =&gt; { r.Configuration = Configuration[&quot;Redis:ConnectionString&quot;]; });} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，整个业务相关的代码已经完成了，我们可以创建前端访问的接口了。这里我是在 Controllers 下的 V1 文件夹下创建了一个 SecretController 用来构建前端访问的接口。控制器中主要有三个方法，分别为 CancelAccessToken（停用 token）、Login（获取 token）以及 RefreshAccessTokenAsync（刷新 token）。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105public class SecretController : ControllerBase{ /// &lt;summary&gt; /// 停用 Jwt 授权数据 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; [HttpPost(&quot;deactivate&quot;)] public async Task&lt;IActionResult&gt; CancelAccessToken() { await _jwtApp.DeactivateCurrentAsync(); return Ok(); } /// &lt;summary&gt; /// 获取 Jwt 授权数据 /// &lt;/summary&gt; /// &lt;param name=&quot;dto&quot;&gt;授权用户信息&lt;/param&gt; [HttpPost(&quot;token&quot;)] [AllowAnonymous] public IActionResult Login([FromBody] SecretDto dto) { //Todo：获取用户信息 var user = new UserDto { Id = Guid.NewGuid(), UserName = &quot;yuiter&quot;, Role = Guid.Empty, Email = &quot;yuiter@yuiter.com&quot;, Phone = &quot;13912345678&quot;, }; if (user == null) return Ok(new JwtResponseDto { Access = &quot;无权访问&quot;, Type = &quot;Bearer&quot;, Profile = new Profile { Name = dto.Account, Auths = 0, Expires = 0 } }); var jwt = _jwtApp.Create(user); return Ok(new JwtResponseDto { Access = jwt.Token, Type = &quot;Bearer&quot;, Profile = new Profile { Name = user.UserName, Auths = jwt.Auths, Expires = jwt.Expires } }); } /// &lt;summary&gt; /// 刷新 Jwt 授权数据 /// &lt;/summary&gt; /// &lt;param name=&quot;dto&quot;&gt;刷新授权用户信息&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; [HttpPost(&quot;refresh&quot;)] public async Task&lt;IActionResult&gt; RefreshAccessTokenAsync([FromBody] SecretDto dto) { //Todo：获取用户信息 var user = new UserDto { Id = Guid.NewGuid(), UserName = &quot;yuiter&quot;, Role = Guid.Empty, Email = &quot;yuiter@yuiter.com&quot;, Phone = &quot;13912345678&quot;, }; if (user == null) return Ok(new JwtResponseDto { Access = &quot;无权访问&quot;, Type = &quot;Bearer&quot;, Profile = new Profile { Name = dto.Account, Auths = 0, Expires = 0 } }); var jwt = await _jwtApp.RefreshAsync(dto.Token, user); return Ok(new JwtResponseDto { Access = jwt.Token, Type = &quot;Bearer&quot;, Profile = new Profile { Name = user.UserName, Auths = jwt.Success ? jwt.Auths : 0, Expires = jwt.Success ? jwt.Expires : 0 } }); }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，让我们测试一下，从下图中可以看到，当我们未获取 token 时，访问接口提示我们 401 Unauthorized，当我们模拟登录获取到 token 信息后，再次访问受保护的资源时，已经可以获取到响应的数据。之后，当我们刷新 token，此时再用原来的 token 信息访问时，已经无法访问，提示 403 Forbidden，同时，可以看到我们的 Redis 中已经存在了停用的 token 信息，此时，使用新的 token 信息又可以访问了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此，整个的 Jwt 授权鉴权相关的代码就已经完成了，因为篇幅原因，完整的代码请到 Github 上进行查看（电梯直达）。 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本章，主要是使用 Jwt 完成对于用户的授权与鉴权，实现了对于用户 token 令牌的创建、刷新、停用以及校验。在实际的开发中，采用成熟的轮子可能是更好的方案，如果你有针对 Jwt 进行用户授权、鉴权更好的解决方案的话，欢迎你在评论区留言指出。拖了很久，应该是年前的最后一篇了，提前祝大家新年快乐哈~~~","link":"/2019/01/29/ASP-NET-Core-on-Linux-04/"},{"title":"ASP.NET Core 项目实战（持续更新~~~）","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;准备写这个系列文章的设想开始于今年9月，毫无意外，期间又又又又拖了很长时间，文章主要是为了记录自己学习使用 ASP.NET Core Web API 与 Vue 创建一个前后端分离的项目的整个过程。嗯，2018年快要结束了，应该能在 .NET Core 3.0 正式版和 Vue 3.0 正式版发布前完成吧。。。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码仓储地址：https://github.com/Lanesra712/Grapefruit.VuCore 使用到的技术点(暂定)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）项目框架：ASP.NET Core 2.1 Web API&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）ORM：Dapper&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）数据实体映射：AutoMapper&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4）数据库引擎：SQL SERVER 2012 / MySQL Server 8.0 + Redis&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5）权限验证：基于 Jwt 的角色权限验证&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6）前端框架：Vue.js + Element UI&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7）日志记录：nlog + MongoDB 章节目录 Vue 先导系列 Vue.js 牛刀小试 项目框架搭建 ASP.NET Core 实战：使用 ASP.NET Core Web API 和 Vue.js，搭建前后端分离框架 ASP.NET Core 实战：构建带有版本控制的 API 接口 ASP.NET Core 实战：使用 NLog 将日志信息记录到 MongoDB ASP.NET Core 实战：基于 Jwt Token 的权限控制全揭露 ASP.NET Core 实战：基于 Dapper 扩展你的数据访问方法 附录 ASP.NET Core 实战：Linux 小白的 .NET Core 部署之路 ASP.NET Core 实战：将 .NET Core 2.0 项目升级到 .NET Core 2.1 ASP.NET Core 实战：使用 Docker 容器化部署 ASP.NET Core + MySQL + Nginx","link":"/2018/08/15/ASP-NET-Core-on-Linux-Overview/"},{"title":"ASP.NET Core 实战：基于 Dapper 扩展你的数据访问方法","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在非静态页面的项目开发中，必定会涉及到对于数据库的访问，最开始呢，我们使用 Ado.Net，通过编写 SQL 帮助类帮我们实现对于数据库的快速访问，后来，ORM（Object Relational Mapping，对象关系映射）出现了，我们开始使用 EF、Dapper、NHibernate，亦或是国人的 SqlSugar 代替我们原来的 SqlHelper.cs。通过这些 ORM 工具，我们可以很快速的将数据库中的表与代码中的类进行映射，同时，通过编写 SQL 或是 Lambda 表达式的方式，更加便捷的实现对于数据层的访问。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像文章标题中所说的这样，在这个项目中我是使用的 Dapper 来进行的数据访问，每个人都有自己的编程习惯，本篇文章只是介绍我在 Grapefruit.VuCore 这个项目中是如何基于 Dapper 创建自己使用的帮助方法的，不会涉及各种 ORM 工具的对比，请友善查看、讨论。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系列目录地址：ASP.NET Core 项目实战&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仓储地址：https://github.com/Lanesra712/Grapefruit.VuCore Step by Step&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一、整体思路&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Grapefruit.VuCore 这个项目中，我选择将 SQL 语句存储在 XML 文件中（XML 以嵌入的资源的方式嵌入到程序集中），通过编写中间件的方式，在程序运行时将存储有 SQL 语句的 XML 程序集写入到 Redis 缓存中。当使用到 SQL 语句时，通过 Redis 中的 Key 值进行获取到 Value，从而将 SQL 语句与我们的代码进行拆分。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;涉及到的类文件主要是在以下的类库中，基于 Dapper 的数据访问代码则位于基础构造层（02_Infrastructure）中，而使用到这些数据访问代码的，有且仅在位于领域层（03_Domain）中的代码。同时，领域层的文件分布结构和应用层（04_Applicatin）保持相同。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、扩展数据访问方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用 Dapper 之前，我们首先需要在 Grapefruit.Infrastructure 这个类库中添加对于 Dapper 的引用。同时，因为需要将 SQL 语句存储到 Redis 缓存中，与之前使用 Redis 存储 Token 时相同，这里，也是使用的微软的分布式缓存接口，因此，同样需要添加对于此 DLL 的引用。12Install-Package DapperInstall-Package Microsoft.Extensions.Caching.Abstractions &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Grapefruit.Infrastructure 类库中创建一个 Dapper 文件夹，我们基于 Dapper 的扩展代码全部置于此处，整个的代码结构如下图所示。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在整个 Dapper 文件夹下类/接口/枚举文件，主要可以按照功能分为三部分。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、辅助功能文件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主要包含 DataBaseTypeEnum 这个枚举类以及 SqlCommand 这个用来将存储在 XML 中的 SQL 进行映射的帮助类。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataBaseTypeEnum 这个数据库类型枚举类主要定义了可以使用的数据库类型。我们知道，Dapper 这个 ORM 主要是通过扩展 IDbConnection 接口，从而给我们提供附加的数据操作功能，而我们在创建数据库连接对象时，不管是 SqlConnection 还是 MySqlConnection 最终对于数据库最基础的操作，都是继承于 IDbConnection 这个接口。因此，我们可以在后面创建数据库连接对象时，通过不同的枚举值，创建针对不同数据库操作的数据库连接对象。1234567public enum DataBaseTypeEnum{ SqlServer = 1, MySql = 2, PostgreSql = 3, Oracle = 4} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SqlCommand 这个类文件只是定义了一些属性，因为我是将 SQL 语句写到 XML 文件中，同时会将 XML 文件存储到 Redis 缓存中，因此，SqlCommand 这个类主要用来将我们获取到的 SQL 语句与类文件做一个映射关系。123456789101112public class SqlCommand{ /// &lt;summary&gt; /// SQL语句名称 /// &lt;/summary&gt; public string Name { get; set; } /// &lt;summary&gt; /// SQL语句或存储过程内容 /// &lt;/summary&gt; public string Sql { get; set; }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、SQL 存储读取&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 SQL 语句的存储、读取，我定义了一个 IDataRepository 接口，DataRepository 继承于 IDataRepository 实现对于 SQL 语句的操作。1234567891011121314public interface IDataRepository{ /// &lt;summary&gt; /// 获取 SQL 语句 /// &lt;/summary&gt; /// &lt;param name=\"commandName\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; string GetCommandSQL(string commandName); /// &lt;summary&gt; /// 批量写入 SQL 语句 /// &lt;/summary&gt; void LoadDataXmlStore();} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存储 SQL 的 XML 我是以附加的资源存储到 dll 中，因此，这里我是通过加载 dll 的方式获取到所有的 SQL 语句，之后，根据 Name 属性判断 Redis 中是否存在，当不存在时就写入 Redis 缓存中。核心的代码如下所示，如果你需要查看完整的代码，可以去 Github 上查看。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/// &lt;summary&gt;/// 载入dll中包含的SQL语句/// &lt;/summary&gt;/// &lt;param name=\"fullPath\"&gt;命令名称&lt;/param&gt;private void LoadCommandXml(string fullPath){ SqlCommand command = null; Assembly dll = Assembly.LoadFile(fullPath); string[] xmlFiles = dll.GetManifestResourceNames(); for (int i = 0; i &lt; xmlFiles.Length; i++) { Stream stream = dll.GetManifestResourceStream(xmlFiles[i]); XElement rootNode = XElement.Load(stream); var targetNodes = from n in rootNode.Descendants(\"Command\") select n; foreach (var item in targetNodes) { command = new SqlCommand { Name = item.Attribute(\"Name\").Value.ToString(), Sql = item.Value.ToString().Replace(\"&lt;![CDATA[\", \"\").Replace(\"]]&gt;\", \"\") }; command.Sql = command.Sql.Replace(\"\\r\\n\", \"\").Replace(\"\\n\", \"\").Trim(); LoadSQL(command.Name, command.Sql); } }}/// &lt;summary&gt;/// 载入SQL语句/// &lt;/summary&gt;/// &lt;param name=\"commandName\"&gt;SQL语句名称&lt;/param&gt;/// &lt;param name=\"commandSQL\"&gt;SQL语句内容&lt;/param&gt;private void LoadSQL(string commandName, string commandSQL){ if (string.IsNullOrEmpty(commandName)) { throw new ArgumentNullException(\"CommandName is null or empty!\"); } string result = GetCommandSQL(commandName); if (string.IsNullOrEmpty(result)) { StoreToCache(commandName, commandSQL); }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、数据操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于数据的操作，这里我定义了 IDataAccess 这个接口，提供了同步、异步的方式，实现对于数据的访问。在项目开发中，对于数据的操作，更多的还是根据字段值获取对象、获取对象集合、执行 SQL 获取受影响的行数，获取字段值，所以，这里主要就定义了这几类的方法。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public interface IDataAccess{ /// 关闭数据库连接 bool CloseConnection(IDbConnection connection); /// 数据库连接 IDbConnection DbConnection(); /// 执行SQL语句或存储过程返回对象 T Execute&lt;T&gt;(string sql, object param, bool hasTransaction = false, CommandType commandType = CommandType.Text); /// 执行SQL语句返回对象 T Execute&lt;T&gt;(string sql, object param, IDbTransaction transaction, IDbConnection connection, CommandType commandType = CommandType.Text); /// 执行SQL语句或存储过程返回对象 Task&lt;T&gt; ExecuteAsync&lt;T&gt;(string sql, object param, bool hasTransaction = false, CommandType commandType = CommandType.Text); /// 执行SQL语句返回对象 Task&lt;T&gt; ExecuteAsync&lt;T&gt;(string sql, object param, IDbTransaction transaction, IDbConnection connection, CommandType commandType = CommandType.Text); /// 执行SQL语句或存储过程，返回IList&lt;T&gt;对象 IList&lt;T&gt; ExecuteIList&lt;T&gt;(string sql, object param, bool hasTransaction = false, CommandType commandType = CommandType.Text); /// 执行SQL语句或存储过程，返回IList&lt;T&gt;对象 IList&lt;T&gt; ExecuteIList&lt;T&gt;(string sql, object param, IDbTransaction transaction, IDbConnection connection, CommandType commandType = CommandType.Text); /// 执行SQL语句或存储过程，返回IList&lt;T&gt;对象 Task&lt;IList&lt;T&gt;&gt; ExecuteIListAsync&lt;T&gt;(string sql, object param, bool hasTransaction = false, CommandType commandType = CommandType.Text); /// 执行SQL语句或存储过程，返回IList&lt;T&gt;对象 Task&lt;IList&lt;T&gt;&gt; ExecuteIListAsync&lt;T&gt;(string sql, object param, IDbTransaction transaction, IDbConnection connection, CommandType commandType = CommandType.Text); /// 执行SQL语句或存储过程返回受影响行数 int ExecuteNonQuery(string sql, object param, bool hasTransaction = false, CommandType commandType = CommandType.Text); /// 执行SQL语句或存储过程返回受影响行数 int ExecuteNonQuery(string sql, object param, IDbTransaction transaction, IDbConnection connection, CommandType commandType = CommandType.Text); /// 执行SQL语句或存储过程返回受影响行数 Task&lt;int&gt; ExecuteNonQueryAsync(string sql, object param, bool hasTransaction = false, CommandType commandType = CommandType.Text); /// 执行SQL语句或存储过程返回受影响行数 Task&lt;int&gt; ExecuteNonQueryAsync(string sql, object param, IDbTransaction transaction, IDbConnection connection, CommandType commandType = CommandType.Text); /// 执行语句返回T对象 T ExecuteScalar&lt;T&gt;(string sql, object param, bool hasTransaction = false, CommandType commandType = CommandType.Text); /// 执行语句返回T对象 Task&lt;T&gt; ExecuteScalarAsync&lt;T&gt;(string sql, object param, bool hasTransaction = false, CommandType commandType = CommandType.Text);} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 IDataAccess 接口的功能实现与调用上，我采用了代理模式的方式，会涉及到 DataAccess、DataAccessProxy、DataAccessProxyFactory、DBManager 这四个类文件，之间的调用过程如下。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataAccess 是接口的实现类，通过下面的几个类进行隐藏，不直接暴露给外界方法。一些接口的实现如下所示。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/// &lt;summary&gt;/// 创建数据库连接/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;public IDbConnection DbConnection(){ IDbConnection connection = null; switch (_dataBaseType) { case DataBaseTypeEnum.SqlServer: connection = new SqlConnection(_connectionString); break; case DataBaseTypeEnum.MySql: connection = new MySqlConnection(_connectionString); break; }; return connection;}/// &lt;summary&gt;/// 执行SQL语句或存储过程，返回IList&lt;T&gt;对象/// &lt;/summary&gt;/// &lt;typeparam name=\"T\"&gt;类型&lt;/typeparam&gt;/// &lt;param name=\"sql\"&gt;SQL语句 or 存储过程名&lt;/param&gt;/// &lt;param name=\"param\"&gt;参数&lt;/param&gt;/// &lt;param name=\"transaction\"&gt;外部事务&lt;/param&gt;/// &lt;param name=\"connection\"&gt;数据库连接&lt;/param&gt;/// &lt;param name=\"commandType\"&gt;命令类型&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public IList&lt;T&gt; ExecuteIList&lt;T&gt;(string sql, object param, IDbTransaction transaction, IDbConnection connection, CommandType commandType = CommandType.Text){ IList&lt;T&gt; list = null; if (connection.State == ConnectionState.Closed) { connection.Open(); } try { if (commandType == CommandType.Text) { list = connection.Query&lt;T&gt;(sql, param, transaction, true, null, CommandType.Text).ToList(); } else { list = connection.Query&lt;T&gt;(sql, param, transaction, true, null, CommandType.StoredProcedure).ToList(); } } catch (Exception ex) { _logger.LogError($\"SQL语句：{sql}，使用外部事务执行 ExecuteIList&lt;T&gt; 方法出错，错误信息：{ex.Message}\"); throw ex; } return list;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBManager 是外界方法访问的类，通过 CreateDataAccess 方法会创建一个 IDataAccess 对象，从而达到访问接口中方法的目的。123456789101112131415161718192021222324252627282930313233[ThreadStatic]private static IDataAccess _sMsSqlFactory;/// &lt;summary&gt;/// /// &lt;/summary&gt;/// &lt;param name=\"cp\"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private static IDataAccess CreateDataAccess(ConnectionParameter cp){ return new DataAccessProxy(DataAccessProxyFactory.Create(cp));}/// &lt;summary&gt;/// MsSQL 数据库连接字符串/// &lt;/summary&gt;public static IDataAccess MsSQL{ get { ConnectionParameter cp; if (_sMsSqlFactory == null) { cp = new ConnectionParameter { ConnectionString = ConfigurationManager.GetConfig(\"ConnectionStrings:MsSQLConnection\"), DataBaseType = DataBaseTypeEnum.SqlServer }; _sMsSqlFactory = CreateDataAccess(cp); } return _sMsSqlFactory; }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataAccessProxy 就是实际接口功能实现类的代理，通过有参构造函数的方式进行调用，同时，类中继承于 IDataAccess 的方法都是不实现的，都是通过 _dataAccess 调用接口中的方法。12345678910111213141516171819202122232425262728/// &lt;summary&gt;/// /// &lt;/summary&gt;private readonly IDataAccess _dataAccess;/// &lt;summary&gt;/// ctor/// &lt;/summary&gt;/// &lt;param name=\"dataAccess\"&gt;&lt;/param&gt;public DataAccessProxy(IDataAccess dataAccess){ _dataAccess = dataAccess ?? throw new ArgumentNullException(\"dataAccess is null\");}/// &lt;summary&gt;/// 执行SQL语句或存储过程，返回IList&lt;T&gt;对象/// &lt;/summary&gt;/// &lt;typeparam name=\"T\"&gt;类型&lt;/typeparam&gt;/// &lt;param name=\"sql\"&gt;SQL语句 or 存储过程名&lt;/param&gt;/// &lt;param name=\"param\"&gt;参数&lt;/param&gt;/// &lt;param name=\"transaction\"&gt;外部事务&lt;/param&gt;/// &lt;param name=\"connection\"&gt;数据库连接&lt;/param&gt;/// &lt;param name=\"commandType\"&gt;命令类型&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public IList&lt;T&gt; ExecuteIList&lt;T&gt;(string sql, object param, IDbTransaction transaction, IDbConnection connection, CommandType commandType = CommandType.Text){ return _dataAccess.ExecuteIList&lt;T&gt;(sql, param, transaction, connection, commandType);} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataAccessProxyFactory 这个类有一个 Create 静态方法，通过实例化 DataAccess 类的方式返回 IDataAccess 接口，从而达到真正调用到接口实现类。12345678910111213/// &lt;summary&gt;/// 创建数据库连接字符串/// &lt;/summary&gt;/// &lt;param name=\"cp\"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static IDataAccess Create(ConnectionParameter cp){ if (string.IsNullOrEmpty(cp.ConnectionString)) { throw new ArgumentNullException(\"ConnectionString is null or empty!\"); } return new DataAccess(cp.ConnectionString, cp.DataBaseType);} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三、使用方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为我们对于 SQL 语句的获取全部是从缓存中获取的，因此，我们需要在程序执行前将所有的 SQL 语句写入 Redis 中。在 ASP.NET MVC 中，我们可以在 Application_Start 方法中进行调用，但是在 ASP.NET Core 中，我一直没找到如何实现仅在程序开始运行时执行代码，所以，这里，我采用了中间件的形式将 SQL 语句存储到 Redis 中，当然，你的每一次请求，都会调用到这个中间件。如果大家有好的方法，欢迎在评论区里指出。123456789101112131415161718192021222324252627282930313233343536373839404142public class DapperMiddleware{ private readonly ILogger _logger; private readonly IDataRepository _repository; private readonly RequestDelegate _request; /// &lt;summary&gt; /// ctor /// &lt;/summary&gt; /// &lt;param name=\"repository\"&gt;&lt;/param&gt; /// &lt;param name=\"logger\"&gt;&lt;/param&gt; /// &lt;param name=\"request\"&gt;&lt;/param&gt; public DapperMiddleware(IDataRepository repository, ILogger&lt;DapperMiddleware&gt; logger, RequestDelegate request) { _repository = repository; _logger = logger; _request = request; } /// &lt;summary&gt; /// 注入中间件到HttpContext中 /// &lt;/summary&gt; /// &lt;param name=\"context\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task InvokeAsync(HttpContext context) { Stopwatch sw = new Stopwatch(); sw.Start(); //加载存储xml的dll _repository.LoadDataXmlStore(); sw.Stop(); TimeSpan ts = sw.Elapsed; _logger.LogInformation($\"加载存储 XML 文件DLL，总共用时：{ts.TotalMinutes} 秒\"); await _request(context); }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;中间件的实现，只是调用了之前定义的 IDataRepository 接口中的 LoadDataXmlStore 方法，同时记录下了加载的时间。在 DapperMiddlewareExtensions 这个静态类中，定义了中间件的使用方法，之后我们在 Startup 的 Configure 方法里调用即可。123456789101112public static class DapperMiddlewareExtensions{ /// &lt;summary&gt; /// 调用中间件 /// &lt;/summary&gt; /// &lt;param name=\"builder\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static IApplicationBuilder UseDapper(this IApplicationBuilder builder) { return builder.UseMiddleware&lt;DapperMiddleware&gt;(); }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;中间件的调用代码如下，同时，因为我们在中间件中通过依赖注入的方式使用到了 IDataRepository 接口，所以，我们也需要在 ConfigureServices 中注入该接口，这里，采用单例的方式即可。12345678910111213141516public class Startup{ // This method gets called by the runtime. Use this method to add services to the container. public void ConfigureServices(IServiceCollection services) { //DI Sql Data services.AddTransient&lt;IDataRepository, DataRepository&gt;(); } // This method gets called by the runtime. Use this method to configure the HTTP request pipeline. public void Configure(IApplicationBuilder app, IHostingEnvironment env, IApiVersionDescriptionProvider provider) { //Load Sql Data app.UseDapper(); }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当所有的 SQL 语句写入到缓存中后，我们就可以使用了，这里的示例代码实现的是上一篇（ASP.NET Core 实战：基于 Jwt Token 的权限控制全揭露）中，进行 Jwt Token 授权，验证登录用户信息的功能。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整个的调用过程如下图所示。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 SecretDomain 中，我定义了一个 GetUserForLoginAsync 方法，通过帐户名和密码获取用户的信息，调用了之前定义的数据访问方法。12345678910111213141516171819202122232425262728293031323334353637383940414243public class SecretDomain : ISecretDomain{ #region Initialize /// &lt;summary&gt; /// 仓储接口 /// &lt;/summary&gt; private readonly IDataRepository _repository; /// &lt;summary&gt; /// ctor /// &lt;/summary&gt; /// &lt;param name=\"repository\"&gt;&lt;/param&gt; public SecretDomain(IDataRepository repository) { _repository = repository; } #endregion #region API Implements /// &lt;summary&gt; /// 根据帐户名、密码获取用户实体信息 /// &lt;/summary&gt; /// &lt;param name=\"account\"&gt;账户名&lt;/param&gt; /// &lt;param name=\"password\"&gt;密码&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;IdentityUser&gt; GetUserForLoginAsync(string account, string password) { StringBuilder strSql = new StringBuilder(); strSql.Append(_repository.GetCommandSQL(\"Secret_GetUserByLoginAsync\")); string sql = strSql.ToString(); return await DBManager.MsSQL.ExecuteAsync&lt;IdentityUser&gt;(sql, new { account, password }); } #endregion} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XML 的结构如下所示，注意，这里需要修改 XML 的属性，生成操作改为附加的资源。123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;Commands&gt; &lt;Command Name=\"Secret_GetUserByLoginAsync\"&gt; &lt;![CDATA[ SELECT Id ,Name ,Account ,Password ,Salt FROM IdentityUser WHERE Account=@account AND Password=@password; ]]&gt; &lt;/Command&gt; &lt;Command Name=\"Secret_NewId\"&gt; &lt;![CDATA[ select NEWID(); ]]&gt; &lt;/Command&gt;&lt;/Commands&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为篇幅原因，这里就不把所有的代码都列出来，整个调用的过程演示如下，如果有不明白的，或是有什么好的建议的，欢迎在评论区中提出。因为，数据库表并没有设计好，这里只是建了一个实验用的表，，这里我使用的是 SQL Server 2012，创建表的 SQL 语句如下。123456789101112131415161718192021222324252627282930313233USE [GrapefruitVuCore]GOALTER TABLE [dbo].[IdentityUser] DROP CONSTRAINT [DF_User_Id]GO/****** Object: Table [dbo].[IdentityUser] Script Date: 2019/2/24 9:41:15 ******/DROP TABLE [dbo].[IdentityUser]GO/****** Object: Table [dbo].[IdentityUser] Script Date: 2019/2/24 9:41:15 ******/SET ANSI_NULLS ONGOSET QUOTED_IDENTIFIER ONGOCREATE TABLE [dbo].[IdentityUser]( [Id] [uniqueidentifier] NOT NULL, [Name] [nvarchar](50) NOT NULL, [Account] [nvarchar](50) NOT NULL, [Password] [nvarchar](100) NOT NULL, [Salt] [uniqueidentifier] NOT NULL, CONSTRAINT [PK__User__3214EC07D257C709] PRIMARY KEY CLUSTERED ( [Id] ASC)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]GOALTER TABLE [dbo].[IdentityUser] ADD CONSTRAINT [DF_User_Id] DEFAULT (newid()) FOR [Id]GO 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一章主要是介绍下我是如何使用 Dapper 构建我的数据访问帮助方法的，每个人都会有自己的编程习惯，这里只是给大家提供一个思路，适不适合你就不一定啦。因为年后工作开始变得多起来了，现在主要都是周末才能写博客了，所以更新的速度会变慢些，同时，这一系列的文章，按我的设想，其实还有一两篇文章差不多就结束了（VUE 前后端交互、Docker 部署），嗯，因为 Vue 那块我还在学习中（其实就是很长时间没看了。。。），所以接下来的一段时间可能会侧重于 Vue 系列（Vue.js 牛刀小试），ASP.NET Core 系列可能会不定期更新，希望大家同样可以多多关注啊。最后，感谢之前赞赏的小伙伴。","link":"/2019/02/24/ASP-NET-Core-on-Linux-05/"},{"title":"ASP.NET Core 实战：Linux 小白的 .NET Core 部署之路","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近一段时间自己主要的学习计划还是按照毕业后设定的计划，自己一步步的搭建一个前后端分离的 ASP.NET Core 项目，目前也还在继续学习 Vue 中，虽然中间断了很长时间，好歹还是坚持下来了，嗯，看了看时间，原本决定的半年完成肯定是完不成了。这几周重新拾起来学习 Vue，文章也在慢慢的更新中，这一篇文章主要是想提前试试水将 ASP.NET Core 部署到 Linux Server 上，原本的打算是写毕业设计的时候就部署到 Linux 上，最终也未能成行，究其原因，还是自己太懒太拖了吧，哈哈哈，拖到最后，毕业设计差点都没写完。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为目前自己的前后端分离的项目还没开始写，所以这里采用的还是自己原来写的 .NET Core 项目，这篇文章的主要目的是操作下如何将我们 ASP.NET Core 项目部署到我们的 Linux 服务器上，如果对你有任何的帮助的话，不胜荣幸。当然，如果有不对的地方，欢迎大家提出。 准备工作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、一台 Linux 操作系统的电脑，嗯，这里采用的是腾讯云学生套餐，服务器版本为 CnetOS 7.5 。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、终端软件，这里我使用的是putty，用来帮助我们远程连接到我们的服务器。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下载链接：https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、文件上传软件，这里我使用的是 WinSC，上传文件的，同时，如何你和我一样对于使用命令行编辑文件不习惯的话，用这个还可以编辑下服务器上需要更改的配置文件，逃~~~。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下载链接：https://winscp.net/eng/download.php Step by Step&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一、安装 .NET Core Runtime&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为这里并不需要在 Linux 服务器上进行开发工作，所以只需要安装好 dotnet core runtime 就可以了，如果你需要在 Linux 上进行开发，就需要安装 .NET Core SDK了，当然，如果安装过了 SDK，也就不需要安装 Runtime 了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们打开微软的官方网站，使用 putty 连接到我们的服务器。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;官方网站：Install .NET Core Runtime on Linux CentOS / Oracle x64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、在服务器上注册 Microsoft 秘钥，这里我使用的是 Centos ，这里你需要按照你自己的服务器版本进行选择下载。1sudo rpm -Uvh https://packages.microsoft.com/config/rhel/7/packages-microsoft-prod.rpm &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、更新可供安装的版本，当控制台出现 Complete 时，则代表我们更新完成。1sudo yum update &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、安装 .NET Core，同样的，当控制台出现 Complete 时，则代表我们安装完成。1sudo yum install aspnetcore-runtime-2.1 ##这里如果你要在 Linux 上开发，这里就安装 dotnet-sdk-2.1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时，如何判断我们的 .NET Core 安装成功了呢？我们可以在控制台上输入下面的命令，如果已经安装成功的话，就可以把我们安装的 dotnet 版本信息显示出来，反之，你就需要重新执行了。1dotnet --info &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们可以看到，我们只是安装了 .NET Core Runtime，并没有安装 SDK，我们的 Host 版本是2.1.5。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、安装 MySQL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、添加 MySQL 源&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先打开 MySQL 的官网，需要根据自己的服务器信息选择合适的源信息，我的服务器操作系统是 CentOS，这里我选择的是 yum 源（yum 源地址：https://dev.mysql.com/downloads/repo/yum/）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们点击 Download 按钮后发现，要登录。。。如果你和我一样不想又注册一个账户，我们可以获取到下面的下载地址，然后通过 rpm -Ivh 的方式安装。我安装的是最新的 MySQL 8.0 版本，当然，你也可以通过修改版本号下载不同的 MySQL 版本。12wget https://dev.mysql.com/get/mysql80-community-release-el7-1.noarch.rpmrpm -ivh mysql80-community-release-el7-1.noarch.rpm &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、校验 md5 与官网上的是不是一致的，当然，也可以不执行这一步。如果不一样的话，恭喜你，你使用的源可能被某些人篡改了。1md5sum mysql80-community-release-el7-1.noarch.rpm &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、安装 MySQL Server1sudo yum install mysql-server &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、启动 MySQL Server&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们完成安装之后，就可以启动 MySQL Server 服务了。我们可以使用下面的命令启动 MySQL 守护程序。1sudo systemctl start mysqld &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可是上面的命令执行之后，不会有任何的反应，我们可能会疑问我们执行成功了吗？所以为了确保我们执行成功，我们可以使用下面的命令来查看是否启用了 MySQL 服务。此时，如果我们的 MySQL 服务已经启动了，则会输出我们的执行信息。1sudo systemctl status mysqld &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们启动后可能会疑问，我们并没有设置管理员密码啊？原来，我们在安装的过程中，会自动的为 MySQL root 用户生成一个临时的密码，我们可以通过下面的命令中找到这个默认的密码。1sudo grep &apos;temporary password&apos; /var/log/mysqld.log &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以使用下面的命令来修改我们的 root 密码，系统会提示我们输入默认密码，默认密码输入正确后就可以自己设置新的密码了。1sudo mysql_secure_installation &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：重新设置的密码至少包含一个大写字母，一个小写字母，一个数字和一个特殊字符的12个字符！！！在整个设置密码的过程中，总共有五步：设置 root 密码；是否禁止 root 账号远程登录；是否禁止匿名账号（anonymous）登录；是否删除测试库；是否确认修改。按照你自己的需求后，设置完成后即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5、设置允许远程登录&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的设置完成后，我们用自己本地的 Workbench 连接服务器上的数据库，发现无法进行连接，如果你之前使用过远程连接 MySQL Server 你应该会知道，我们需要在 user 表中设置 root 用户允许访问的地址。12345mysql -h localhost -u root -p ##登录数据库，输入密码后完成登录use mysql; ##选择 mysql 表select user,host from user; ##查询当前的用户update user set host=&apos;%&apos; where user=&apos;root&apos;; ##允许使用 root 账户进行远程登录flush privileges; ##刷新设置 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时，我们就可以远程连接到我们的 MySQL Server 上了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三、发布部署程序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本次部署的项目，采用的还是之前的毕业设计的项目(ASP.NET Core 2.0 MVC 项目实战)，在这里发布测试的时候遇到了一个问题，因为当时项目采用的 MySQL 版本为5.7，服务器中所安装的 MySQL 版本为8.0，而 Oracle 在最新的 MySQL 中将默认的版本身份验证从 mysql_native_password 改为了 caching_sha2_password，这里在进行数据操作时就会出现问题。如果你和我遇到同样的问题，你需要将 MySQL 官方的 EFCore 组件替换成 Pomelo.EntityFrameworkCore.MySql，嗯，替换，而不是升级，因为升级后又会出现新的问题（小声BB：MySQL 的这个 EFCore 的驱动事不是一般的多）。如果你不想升级的话，可以参考这个做法，链接地址送上：mysql8 ：客户端连接caching-sha2-password问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们把项目丢到服务器上后，我们进去到放置的路径下，执行 dotnet 命令就可以运行我们的项目了。这里要特别注意，Linux 中对于大小写是区分的，这里输入的路径以及项目的名称都要确保和实际相同。12cd /usr/local/wwwroot/psu/ ##注意：最后一定要加上这个 / !!!!!dotnet PSU.Site.dll &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里会有个问题，不管你是使用的虚拟机还是云服务器，因为 5000 端口并没有开放给外部访问，所以外部的机器采用 ip:port 的方式，是无法访问到的，所以我们接下来需要安装反向代理的服务器来达到访问的目的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在部署 .NET Core 项目的时候，我们应该保持我们的程序的 .NET Core 版本与服务器上的环境版本保持一致，这样才可以避免因为环境的因素而导致的某些问题，所以这里我部署 .NET Core 2.0 版本的程序其实不是很好的选择。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;四、安装 Nginx 服务器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Windows 服务器上，如果我们要部署 .NET 项目，肯定会选择部署到 IIS 中，同样的，虽然 .NET Core 可以实现自托管，内置的 Kestrel 也非常适合从 ASP.NET Core 提供动态内容。 但是，Kestrel 的 Web 服务功能不像专门的服务器（如 IIS、Apache 或 Nginx）那样功能丰富。 而反向代理服务器可以从 HTTP 服务器卸载服务静态内容、缓存请求、压缩请求和 SSL 终端等工作。 反向代理服务器可能驻留在专用计算机上，也可能与 HTTP 服务器一起部署可是为了能使用更多的功能，所以这里我们还是会配合一个反向代理服务器进行使用，在这里，我采用的是 Nginx。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、安装 Nginx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从官网上下载 nginx 包并解压，这里采用的是使用源码编译安装的形式。12wget -c http://nginx.org/download/nginx-1.9.9.tar.gztar -zxvf nginx-1.9.9.tar.gz &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解压完成后我们就可以进入到 nginx 目录，在这里我们创建默认的配置文件。在我们创建配置文件之前，我们需要安装 gcc 环境。123cd nginx-1.9.9yum install gcc gcc-c++./configure &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的步骤完成后，我们需要添加几个插件去完善 Nginx 的功能。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Nginx 的 http 模块使用 pcre 来解析正则表达式，PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。1yum install -y pcre pcre-devel &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zlib 库提供了很多种压缩和解压缩的方式，Nginx 使用 zlib 对 http 包的内容进行 gzip ，所以我们也需要在服务器上安装 zlib 库。1yum install -y zlib zlib-devel &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Nginx 不仅支持 http 协议，还支持 https 协议，而 OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用，所以我们也会在 Nginx 上面添加。1yum install -y openssl openssl-devel &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此，我们对于 Nginx 插件的安装就完成了，现在我们就可以重新执行配置命令，再编译安装了。12./configuremake install &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编译安装完成后，Nginx 就安装到了我们的服务器上，可是安装到哪里去了呢？这里我们可以使用下面的命令去找到我们安装的 Nginx。知道了安装路径后，我们就可以进入 Nginx 的目录中执行进一步的操作。至此 Nginx 的安装就完成了。12whereis Nginxcd /usr/local/nginx/sbin/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装完成后，我们一般会将 Nginx 设置为开机自启动以及自动重启，从而预防特殊情况导致的网站挂了。我们先创建一个软连接用来指向 Nginx 的安装目录。1ln -s /usr/local/nginx/sbin/nginx /usr/bin/nginx &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在创建一个自启动的脚本。1vim /etc/init.d/nginx &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在脚本中，输入下面的内容。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#!/bin/sh## nginx - this script starts and stops the nginx daemon## chkconfig: - 85 15# description: NGINX is an HTTP(S) server, HTTP(S) reverse \\# proxy and IMAP/POP3 proxy server# processname: nginx# config: /usr/local/nginx/conf/nginx.conf# config: /etc/sysconfig/nginx# pidfile: /usr/local/nginx/logs/nginx.pid# Source function library.. /etc/rc.d/init.d/functions# Source networking configuration.. /etc/sysconfig/network# Check that networking is up.[ &quot;$NETWORKING&quot; = &quot;no&quot; ] &amp;&amp; exit 0nginx=&quot;/usr/local/nginx/sbin/nginx&quot;prog=$(basename $nginx)NGINX_CONF_FILE=&quot;/usr/local/nginx/conf/nginx.conf&quot;[ -f /etc/sysconfig/nginx ] &amp;&amp; . /etc/sysconfig/nginxlockfile=/var/lock/subsys/nginxmake_dirs() { # make required directories user=`$nginx -V 2&gt;&amp;1 | grep &quot;configure arguments:&quot; | sed &apos;s/[^*]*--user=\\([^ ]*\\).*/\\1/g&apos; -` if [ -z &quot;`grep $user /etc/passwd`&quot; ]; then useradd -M -s /bin/nologin $user fi options=`$nginx -V 2&gt;&amp;1 | grep &apos;configure arguments:&apos;` for opt in $options; do if [ `echo $opt | grep &apos;.*-temp-path&apos;` ]; then value=`echo $opt | cut -d &quot;=&quot; -f 2` if [ ! -d &quot;$value&quot; ]; then # echo &quot;creating&quot; $value mkdir -p $value &amp;&amp; chown -R $user $value fi fi done}start() { [ -x $nginx ] || exit 5 [ -f $NGINX_CONF_FILE ] || exit 6 make_dirs echo -n $&quot;Starting $prog: &quot; daemon $nginx -c $NGINX_CONF_FILE retval=$? echo [ $retval -eq 0 ] &amp;&amp; touch $lockfile return $retval}stop() { echo -n $&quot;Stopping $prog: &quot; killproc $prog -QUIT retval=$? echo [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile return $retval}restart() { configtest || return $? stop sleep 1 start}reload() { configtest || return $? echo -n $&quot;Reloading $prog: &quot; killproc $nginx -HUP RETVAL=$? echo}force_reload() { restart}configtest() { $nginx -t -c $NGINX_CONF_FILE}rh_status() { status $prog}rh_status_q() { rh_status &gt;/dev/null 2&gt;&amp;1}case &quot;$1&quot; in start) rh_status_q &amp;&amp; exit 0 $1 ;; stop) rh_status_q || exit 0 $1 ;; restart|configtest) $1 ;; reload) rh_status_q || exit 7 $1 ;; force-reload) force_reload ;; status) rh_status ;; condrestart|try-restart) rh_status_q || exit 0 ;; *) echo $&quot;Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest}&quot; exit 2esac &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们将自启动的脚本赋予脚本可执行权限，并将 Nginx 服务加入 chkconfig 管理列表中。1234chmod a+x /etc/init.d/nginxchkconfig --add /etc/init.d/nginxchkconfig nginx on &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当上面的设置都完成后，启动我们的 Nginx 守护服务就可以了。1systemctl start nginx &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样的，我们也可以使用下面的命令来查看 Nginx 服务的状态。1systemctl status nginx &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一些常用的命令（需要你处于 Nginx 的安装目录下时执行，例如，这里我的 Nginx 安装目录为 /usr/local/nginx/sbin/）：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、启动 Nginx 服务1./nginx &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、停止 Nginx 服务12./nginx -s stop./nginx -s quit &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;停止 Nginx 服务有两种方式，第一种：-s stop：先查出 nginx 的进程 id ，再使用 kill 命令强制杀掉进程；第二种：-s quit：等待 Nginx 的进程处理完成后再进行停止。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、重新加载 Nginx 配置1./nginx -s reload &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;五、配置守护程序以及自启动&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面我们已经使用 dotnet 命令将我们的项目在服务器上运行了，而我们目前通过 ip:port 的形式没有办法进行访问，这时我们安装的 Nginx 服务器就可以为我们提供帮助了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在安装 Nginx 的时候我们创建了一个配置文件，现在我们就可以通过编辑这个配置文件，将我们的项目使用 Nginx 进行代理。首先我们进入 Nginx 的配置文件所在的路径，打开这个配置文件。12cd /usr/local/nginx/conf/vim nginx.conf &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打开 conf 文件后，我们找到 Server 节点，会看到以下的配置项。12345678server { listen 80; server_name localhost; location / { root html; index index.html index.htm; }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当使用 Nginx 时，会根据 server_name 匹配服务器，例如当我们运行 Nginx 成功后，通过浏览器浏览本机的 ip 时，默认会显示 Nginx 的默认页面。而当没有匹配的 server_name 时，Nginx 则会使用默认服务器。 如果没有定义默认服务器，则配置文件中的第一台服务器则成为默认服务器。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里进行修改配置信息，将80端口的请求转发到我们使用 Kestrel 监听的5000端口上的应用上。123456789101112server { listen 80; server_name localhost; location / { # Kestrel proxy_pass http://localhost:5000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Host $http_host; proxy_cache_bypass $http_upgrade; }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以使用命令去验证下修改的配置格式是否正确，配置正确后就可以执行 reload 命令使配置生效。12./nginx -t ##测试格式是否正确./nginx -s reload ##重新加载配置 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们完成上面的步骤后，通过浏览器打开我们的页面，毫无意外的 Nginx 的错误页面出现在了我们的面前。仔细梳理下我们的流程，用户通过浏览器请求 ip，Nginx 将默认的 80 端口的请求反向代理转接到我们应用程序的 5000 端口上，而现在我们并没有使用 dotnet 命令来运行我们的程序，服务器上的 5000 端口也就没有程序在监听。因此当我们在使用 Nginx 进行反向代理我们的 .NET Core 程序时，我们同样需要使用 dotnet 命令将我们的程序运行起来。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，将我们的程序重新使用 dotnet 命令运行起来，打开我们的浏览器访问就会发现我们的网站已经部署成功了。而且浏览器的插件也已经识别出我们使用的 Web 服务器为 Nginx 的 1.9.9 版本。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以这里会引出一个问题，万一 dotnet 进程意外挂了，整个网站不就彻底挂了吗，难道还要我们手动连接到服务器再次创建？所以我们需要能够让 dotnet 进程能够自动重启，从而避免这种情况。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;微软官方则建议我们使用 supervisor 守护程序的方式实现我们守护我们的 .NET Core 程序，确保应用服务即使闪退也会自动重启。同时，Supervisor 也包含一个 web 管理页面，从而方面我们的管理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 linux 或者 unix 操作系统中，守护进程（Daemon）是一种运行在后台的特殊进程，它独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。由于在linux中，每个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端被称为这些进程的控制终端，当控制终端被关闭的时候，相应的进程都会自动关闭。但是守护进程却能突破这种限制，它脱离于终端并且在后台运行，并且它脱离终端的目的是为了避免进程在运行的过程中的信息在任何终端中显示并且进程也不会被任何终端所产生的终端信息所打断。它从被执行的时候开始运转，直到整个系统关闭才退出。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入下面的命令安装 Supervisor 程序。1sudo yum install supervisor &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装完成后我们就可以配置我们的 Supervisor 程序。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们在 etc 目录下创建存储我们配置文件的目录。1mkdir -m 700 -p /etc/supervisor &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目录完成后，我们创建 supervisor 的配置文件，这里采用的是将默认的配置文件复制一份到我们的目录下面。1echo_supervisord_conf &gt; /etc/supervisor/supervisord.conf &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 /etc/supervisor 目录下我们创建一个存放我们 dotnet core 进程文件的存放目录 conf.d。1mkdir -m 700 /etc/supervisor/conf.d &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;修改我们的配置文件，在配置文件的最后，将路径指向我们创建的 conf.d 文件夹。注意注意，这里一定要把前面的 ; 去掉，否则的话这个 include 节点还是被注释无法被应用的！！！12[include]files=/etc/supervisor/conf.d/*.conf &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们就创建一个 PSU.conf 配置文件来管理我们这个项目的 dotnet 进程。嗯，这里我还是采用 WinSCP 的方式进行编辑，同时，我们需要将注释的信息删除。12cd /etc/supervisor/conf.d/touch PSU.conf 1234567891011[program:PSU.Site]command=dotnet PSU.Site.dll #要执行的命令directory=/usr/local/wwwroot/psu/ #命令执行的目录environment=ASPNETCORE__ENVIRONMENT=Production #环境变量user=root #进程执行的用户身份stopsignal=INTautostart=true #是否自动启动autorestart=true #是否自动重启startsecs=3 #自动重启间隔stderr_logfile=/usr/local/wwwroot/logs/psu.err.log #标准错误日志stdout_logfile=/usr/local/wwwroot/logs/psu.log #标准输出日志 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们指明的日志输出的文件，我们实现创建好。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;配置完成后我们就可以创建 Supervisor 的自启动服务。1vim /etc/systemd/system/supervisor.service &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编辑我们的自启动脚本。1234567891011121314[Unit]Description=supervisor[Service]Type=forkingExecStart=/usr/bin/supervisord -c /etc/supervisor/supervisord.confExecStop=/usr/bin/supervisorctl shutdownExecReload=/usr/bin/supervisorctl reloadKillMode=processRestart=on-failureRestartSec=42s[Install]WantedBy=multi-user.target &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重新载入我们的设置。1systemctl daemon-reload &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置 supervisor.service 服务开机启动。1systemctl enable supervisor.service &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;启动我们的服务1systemctl start supervisor.service &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们就使用命令查看我们的程序是否运行，最后的 PSU.Site 则是你设置的配置文件里的 program 名称。123[root@VM_0_3_centos ~]# ps -ef | grep PSU.Siteroot 1382 545 4 19:45 ? 00:00:05 dotnet PSU.Site.dllroot 1648 1606 0 19:47 pts/0 00:00:00 grep --color=auto PSU.Site &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果这里你无法看到两个进程的话，则说明你的程序没有启动成功，你可以去之前设置的程序的错误日志文件处查看因为什么原因导致的程序无法启动。同时，当你对配置文件做了任何的改变后，你都需要将 Supervisor 进行重启。 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次的文章应该是目前写过时间最长也是字数最多的一篇了，就像标题写的一样， Linux 小白，整个过程持续了很多天，中间在重装系统的过程中碰巧还遇到了 aspnetcore 的一个 bug（Missing package dotnet-runtime 2.1.6 for CentOS），看到 bug 关闭后，周六又弄了四五个小时按照步骤一步步走下来才完成了整个的部署。网上有很多将 .NET Core 程序部署到 Linux 服务器的文章，可是，看再多遍，当你尝试的时候，还是会发生很多的问题，如果你有将 .NET Core 程序部署到 Linux 服务器上的计划时，希望你可以实际尝试尝试，毕竟，踩的坑多了，稍微也能避开一点坑了，哈哈哈。 参考&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、如何在CentOS 7上安装MySQL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、CentOS 7 下 Nginx安装以及配置&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、CentOS 7 源码编译安装 Nginx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、ASP.NET Core Linux下为 dotnet 创建守护进程（必备知识）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、Centos 7 .Net core后台守护进程Supervisor配置","link":"/2018/11/17/ASP-NET-Core-on-Linux-S01/"},{"title":"ASP.NET Core 实战：构建带有版本控制的 API 接口","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上一篇的文章中，主要是搭建了我们的开发环境，同时创建了我们的项目模板框架。在整个前后端分离的项目中，后端的 API 接口至关重要，它是前端与后端之间进行沟通的媒介，如何构建一个 “好用” 的 API 接口，是需要我们后端人员好好思考的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在系统迭代的整个过程中，不可避免的会添加新的资源，或是修改现有的资源，后端接口作为暴露给外界的服务，变动的越小，对服务的使用方造成的印象就越小，因此，如何对我们的 API 接口进行合适的版本控制，我们势必需要首先考虑。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系列目录地址：ASP.NET Core 项目实战&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仓储地址：https://github.com/Lanesra712/Grapefruit.VuCore Step by Step&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;项目总是在不断迭代的，某些时候，因为业务发展的需要，需要将现有的接口进行升级，而原有的接口却不能立刻停止使用。比如说，你开发了一个接口提供给爱啪啪 1.0 版本使用，后来爱啪啪的版本迭代了，需要接口返回的数据与原先 1.0 版本返回的数据不同了，这时候，接口肯定是需要升级的，可是如果直接升级原有的接口，还在使用 1.0 版本的用户不就 GG 了，因此，如何做到既可以让 1.0 版本的用户使用，也可以让 2.0 版本的用户使用就需要好好考虑了，常见的解决方案，主要有以下几种。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、 使用不同的 API 名称&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最简单粗暴，需要变更接口逻辑时就重新起个 API 名称，新的版本调用新的 API 名称，旧的版本调用旧的 API 名称。12https://yuiter.com/api/Secret/Login ##爱啪啪 1.0https://yuiter.com/api/Secret/NewLogin ##爱啪啪 2.0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、 在 Url 中标明版本号&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接将 API 版本信息添加到请求的 Url 中，调用不同版本的 API ，就在 URL 中直接标明使用的是哪个版本。12https://yuiter.com/api/v1/Secret/Login ##爱啪啪 1.0https://yuiter.com/api/v2/Secret/Login ##爱啪啪 2.0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、 请求参数中添加版本信息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将 API 的版本信息作为请求的一个参数传递，通过指定参数值来确定请求的 API 版本。12https://yuiter.com/api/Secret/Login?version=1 ##爱啪啪 1.0https://yuiter.com/api/Secret/Login?version=2 ##爱啪啪 2.0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、 在 header 中标明版本号&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前端在请求 API 接口时，在 header 中添加一个参数用来表明请求的版本信息，后端通过前端在 header 中设置的参数来判断，从而执行不同的业务逻辑分支。1234567POST https://yuiter.com/api/Secret/LoginHost: yuiter.com api-version: v1 ##爱啪啪 1.0POST https://yuiter.com/api/Secret/LoginHost: yuiter.com api-version: v2 ##爱啪啪 2.0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Grapefruit.VuCore 这个项目中，我选择将 API 的版本信息添加到请求的地址中，从而明确的指出当前请求的接口版本信息。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一、 Swagger 集成&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后端完成了接口之后，肯定需要告诉前端，不管是整理成 txt/excel/markdown 文档，亦或是写完一个接口就直接发微信告诉前端，总是要多做一步的事情，而 Swagger 则可以帮我们省去这一步。通过配置之后，Swagger 就可以根据我们的接口自动生成 API 的接口文档，省时，省力。当然，如果前端小姐姐单身可撩，而你碰巧有意的话，另谈。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Swagger 是一个可以将接口文档自动生成，同时可以对接口功能进行测试的开源框架，在 ASP.NET Core 环境下，主流的有 Swashbuckle.AspNetCore 和 NSwag 这两个开源框架帮助我们生成 Swagger documents。这里，我采用的是 Swashbuckle.AspNetCore。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用 Swashbuckle.AspNetCore 之前，首先我们需要在 API(Grapefruit.WebApi) 项目中添加对于 Swashbuckle.AspNetCore 的引用。你可以直接右键选中 API 项目选择管理 Nuget 程序包进行加载引用，也可以通过程序包管理控制台进行添加引用，这里注意，使用程序包管理控制台时，你需要将默认的项目修改成 API(Grapefruit.WebApi) 项目。当引用添加完成后，我们就可以在项目中配置 Swagger 了。1Install-Package Swashbuckle.AspNetCore &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ASP.NET Core 的本质上可以看成是一个控制台程序，在我们创建好的 ASP.NET Core Web API 项目中，存在着两个类文件：Program.cs 以及 Startup.cs。与控制台应用一样，Program 类中的 Main 方法是整个程序的入口，在这个方法中，我们将配置好的 IWebHostBuilder 对象，构建成 IWebHost 对象，并运行该 IWebHost 对象从而达到运行 Web 项目的作用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在框架生成的 Program 类文件中，在配置 IWebHostBuilder 的过程时，框架默认为我们添加了一些服务，当然，这里你可以注释掉默认的写法，去自己创建一个 WebHostBuilder 对象。同时，对于一个 ASP.NET Core 程序来说，Startup 类是必须的（你可以删除生成的 Startup 类，重新创建一个新的类，但是，这个新创建的类必须包含 Configure 方法，之后只需要在 UseStartup 中将该类配置为 Startup 类即可），这里如果不指定 Startup 类会导致启动失败。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Startup 类中，存在着 ConfigureServices 和 Configure 这两个方法，在 ConfigureServices 方法中，我们将自定义服务通过依赖注入的方式添加到 IServiceCollection 容器中，而这些容器中的服务，最终都可以在 Configure 方法中进行使用；而 Configure 方法则用于指定 ASP.NET Core 应用程序将如何响应每一个 HTTP 请求，我们可以在这里将我们自己创建的中间件（Middleware）绑定到 IApplicationBuilder 上，从而添加到 HTTP 请求管道中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里只是很粗略的说明了 ASP.NET Core 项目的启动过程，想要仔细了解启动过程的推荐园子里的这篇文章 =》ASP.NET Core 2.0 : 七.一张图看透启动背后的秘密，因为 ASP.NET Core 2.1 版本相比于 2.0 版本又有些改变，这里有一些不一样的地方需要你去注意。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们简单了解了启动过程后，就可以配置我们的 Swagger 了。Swashbuckle.AspNetCore 帮我们构建好了使用 Swagger 的中间件，我们只需要直接使用即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们需要在 ConfigureServices 方法中，将我们的服务添加到 IServiceCollection 容器中，这里，我们需要为生成的 Swagger Document 进行一些配置。123456789101112131415services.AddSwaggerGen(s =&gt;{ s.SwaggerDoc(&quot;v1&quot;, new Info { Contact = new Contact { Name = &quot;Danvic Wang&quot;, Email = &quot;danvic96@hotmail.com&quot;, Url = &quot;https://yuiter.com&quot; }, Description = &quot;A front-background project build by ASP.NET Core 2.1 and Vue&quot;, Title = &quot;Grapefruit.VuCore&quot;, Version = &quot;v1&quot; });}); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后，我们就可以在 Configure 方法中启用我们的 Swagger 中间件。12345app.UseSwagger();app.UseSwaggerUI(s =&gt;{ s.SwaggerEndpoint(&quot;/swagger/v1/swagger.json&quot;, &quot;Grapefruit.VuCore API V1.0&quot;);}); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时，当你运行程序，在域名后面输入/swagger 即可访问到我们的 API 文档页面。因为项目启动时默认访问的是我们 api/values 的 GET 请求接口，这里我们可以打开 Properties 下的 launchSetting.json 文件去配置我们的程序默认打开页面。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上面的图可以看出，不管是使用 IIS 或是程序自托管，我们默认打开的 Url 都是 api/values，这里我们将两种启动方式的 launchUrl 值都修改成 swagger 之后再次运行我们的项目，可以发现，程序默认的打开页面就会变成我们的 API 文档页面。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们使用 API 文档的目的，就是为了让前端知道请求的方法地址是什么，需要传递什么参数，而现在，并没有办法显示出我们对于参数以及方法的注释，通过查看 Swashbuckle.AspNetCore 的 github 首页可以看到，我们可以通过配置，将生成的 json 文件中包含我们对于 Controller or Action 的 Xml 注释内容，从而达到显示注释信息的功能（最终呈现的 Swagger Doc 是根据之前我们定义的这个 “/swagger/v1/swagger.json” json 文件来生成的）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;右键我们的 API 项目，属性 =》生产，勾选上 XML 文档文件，系统会默认帮我们创建生成 XML 文件的地址，这时候，我们重新生成项目，则会发现，当前项目下会多出这个 XML 文件。在重新生成项目的过程中，你会发现，错误列表会显示很多警告信息，提示我们一些方法没有添加 XML 注释。如果你和我一样强迫症的话，可以把 1591 这个错误添加到上面的禁止显示警告中，这样就可以不再显示这个警告了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建好 XML 的注释文件后，我们就可以配置我们的 Swagger 文档，从而达到显示注释的功能。这里，因为我会在 Grapefruit.Application 类库中创建各种的 Dto 对象，而接口中是会调用到这些 Dto 对象的。因此，为了显示这些 Dto 上的注释信息，这里我们也需要生成 Grapefruit.Application 项目的 XML 注释文件。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PS：这里我是将每个项目生成的注释信息 xml 文档地址都放在了程序的基础路径下，如果你将 xml 文档生成在别的位置，这里获取 xml 的方法就需要你进行修改。123456789101112services.AddSwaggerGen(s =&gt;{ //... //Add comments description // var basePath = Path.GetDirectoryName(AppContext.BaseDirectory);//get application located directory var apiPath = Path.Combine(basePath, &quot;Grapefruit.WebApi.xml&quot;); var dtoPath = Path.Combine(basePath, &quot;Grapefruit.Application.xml&quot;); s.IncludeXmlComments(apiPath, true); s.IncludeXmlComments(dtoPath, true);}); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们把 Swagger 配置完成之后，我们就可以创建具有版本控制的 API 接口了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、 带有版本控制的 API 接口实现&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在请求的 API Url 中标明版本号，我不知道你第一时间看到这个实现方式，会想到什么，对于我来说，直接在路由信息中添加版本号不就可以了。。。em，这样过于投机取巧了。。。。12345[Route(&quot;api/v1/[controller]&quot;)]//添加版本信息为v1[ApiController]public class ValuesController : ControllerBase{} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想了想，在 Url 中添加版本号，这个版本号是不是很像我们在 MVC 中使用的 Area。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Area 是 MVC 中经常使用到的一个功能，我们通常会将某些小的模块拆分成一个个的 Area，而这一个个的小 Area 其实就是这个 MVC 项目中的 MVC。通过为 controller 和 action 添加另一个路由参数 area，从而达到创建具有层次路由的结构。比如，这里，我们可以创建一个 Area 叫 v1，用来存储我们 1.x 版本的 API 接口，之后如果有新的 API 版本，新增一个 Area 即可，是不是很简单，嗯，说干就干。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;右击我们的 API 项目，选择添加区域，新增的 Area 名称为 v1。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当 ASP.NET Core 的脚手架程序添加完成 Area 后，则会打开一个文件提示我们需要在 MVC 中间件中创建适用于 Area 的路由定义。1234567app.UseMvc(routes =&gt;{ routes.MapRoute( name : &quot;areas&quot;, template : &quot;{area:exists}/{controller=Home}/{action=Index}/{id?}&quot; );}); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们添加好路由规则定义后，我们在 Area 的 Controllers 文件夹下添加一个 WebAPI Controller。不同于 ASP.NET 中的 Area ，当我们在 ASP.NET Core 创建好一个 Area 之后，脚手架生成的文件中不再有 XXXAreaRegistration（XXX 为 Area 的名称）文件去注册这个 Area，而我们只需要在 Area 中的 Controller 中添加 Area 特性，即可告诉系统框架，这个 Controller 是在当前的 Area 下的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你有自己尝试的话，就会发现，当我们创建好一个 v1 的 Area 后，这个请求的地址并没有按照我们的想法会体现在路由信息中，我们最后还是需要在 Route 中手动指明 API 版本。123456[Area(&quot;v1&quot;)][Route(&quot;api/v1/[controller]&quot;)][ApiController]public class ValuesController : ControllerBase{} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样的话，和最开始直接在路由信息中写死版本信息其实也就没什么差别了，上网搜了搜，发现巨硬爸爸，也早已为我们准备好了实现版本控制 API 的利器 - Microsoft.AspNetCore.Mvc.Versioning。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和上面使用 Swashbuckle.AspNetCore 的方式相同，在我们使用 Versioning 之前，需要在我们的 API 项目中添加对于该 dll 的引用。这里需要注意下安装的版本问题，因为 Grapefruit.VuCore 这个框架距离现在搭建也有几个月的时间了，在这个月初的时候 .NET Core 2.2 也已经发布了，如果你和我一样还是采用的 .NET Core 2.1 版本的话，这里安装的 Versioning 版本最高只能到 2.3。1Install-Package Microsoft.AspNetCore.Mvc.Versioning &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们安装完成之后，就可以进行配置了。123456789public void ConfigureServices(IServiceCollection services){ services.AddApiVersioning(o =&gt; { o.ReportApiVersions = true;//return versions in a response header o.DefaultApiVersion = new ApiVersion(1, 0);//default version select o.AssumeDefaultVersionWhenUnspecified = true;//if not specifying an api version,show the default version });} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReportApiVersions：这个配置是可选的，当我们设置为 true 时，API 会在响应的 header 中返回版本信息。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DefaultApiVersion：指定在请求中未指明版本时要使用的默认 API 版本。这将默认版本为1.0。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AssumeDefaultVersionWhenUnspecified：这个配置项将用于在没有指明 API 版本的情况下提供请求，默认情况下，会请求默认版本的 API，例如，这里就会请求 1.0 版本的 API。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里，删除我们之前的创建的 Area 和默认的 ValuesController，在 Controllers 文件夹下新增一个 v1 文件夹，将所有 v1 版本的 Controller 都建在这个目录下。新建一个 Controller，添加上 ApiVersion Attribute 指明当前的版本信息。因为我采用的方案是在 Url 中指明 API 版本，所以，我们还需要在 Route 中修改我们的路由属性以对应 API 的版本。这里的 v 只是一个默认的惯例，你也可以不添加。123456[ApiVersion(&quot;1.0&quot;)][Route(&quot;api/v{version:apiVersion}/[controller]&quot;)][ApiController]public class VaulesController : ControllerBase{} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们修改好我们的 Controller 之后，运行我们的项目，你会发现，API 文档中显示的请求地址是不对的，难道是我们的配置没起作用吗？通过 Swagger 自带的 API 测试工具测试下我们的接口，原来这里请求的 Url 中已经包含了我们定义的版本信息，当我们指定错误的版本信息时，工具也会告诉我们这个版本的接口不存在。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然我们请求的 Url 中已经带上了版本信息，但是 API 文档上显示的请求地址却是不准确的，强迫症，不能忍。这里，需要我们修改生成 Swagger 文档的配置代码，将路由中的版本信息进行替换。重新运行我们的项目，可以发现，文档显示的 Url 地址也已经正确了，自此，我们创建带有版本控制的 API 也就完成了。12345678910111213141516171819public void ConfigureServices(IServiceCollection services){ services.AddSwaggerGen(s =&gt; { //... //Show the api version in url address s.DocInclusionPredicate((version, apiDescription) =&gt; { var values = apiDescription.RelativePath .Split(&apos;/&apos;) .Select(v =&gt; v.Replace(&quot;v{version}&quot;, version)); apiDescription.RelativePath = string.Join(&quot;/&quot;, values); return true; }); });} 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本章使用了 Microsoft.AspNetCore.Mvc.Versioning 这一组件来实现我们对于 API 版本控制的功能实现，可能你会有疑问，我们直接在路由中写明版本信息不是更简单吗？在我看来，使用这一组件的目的，在于我们可以以多种的方式实现 API 版本控制的目的，如果哪天你不想在 Url 中指明版本信息后，你可以很快的使用别的形式来完成 API 的版本控制。另外，直接在路由中写上版本信息，是不是会显得我们比较 ‘low’，哈哈哈，开玩笑，最后祝大家圣诞快乐~~~","link":"/2018/12/25/ASP-NET-Core-on-Linux-02/"},{"title":"ASP.NET Core 实战：使用 Docker 容器化部署 ASP.NET Core + MySQL + Nginx","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在之前的文章（ASP.NET Core 实战：Linux 小白的 .NET Core 部署之路）中，我介绍了如何在 Linux 环境中安装 .NET Core SDK / .NET Core Runtime、Nginx、MySQL，以及如何将我们的 ASP.NET Core MVC 程序部署到 Linux 上，同时，使用 supervisor 守护程序守护我们的 .NET Core 程序。如果，你有看过那篇文章，并且和我一样是个 Linux 小白用户的话，可能第一感觉就是，把 .NET Core 项目部署在 IIS 上也挺好。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将 .NET Core 项目部署到 Linux 上如此复杂，就没有简单的部署方式吗？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你好，有的，Docker 了解一下~~~&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PS：这里的示例代码还是采用之前的毕业设计项目，在这篇文章发布的时候，我已经在程序的仓库中添加了对于 Docker 的支持，你可以下载下来，自己尝试一下，毕竟，实践出真知。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码仓储：https://github.com/Lanesra712/Danvic.PSU Step by Step&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一、安装 Docker &amp; Docker Compose &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在代码交付的过程中，偶尔会遇到这样的问题，在本地测试是好的，但是部署到测试环境、生产环境时就出这样那样的问题，同时，因为本地与测试环境、生产环境之间存在差异，我们可能无法在本地复现这些问题，那么，有没有一种工具可以很好的解决这一问题呢？随着历史的车轮不断前行，容器技术诞生了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Docker，作为最近几年兴起的一种虚拟化容器技术，他可以将我们的运行程序与操作系统做一个隔离，例如这里我们需要运行 .NET Core 程序，我们不再需要关心底层的操作系统是什么，不需要在每台需要需要运行程序的机器上安装程序运行的各种依赖，我们可以通过程序打包成镜像的方式，将应用程序和该程序的依赖全部置于一个镜像文件中，这时，只要别的机器上有安装 Docker，就可以通过我们打包的这个镜像来运行这个程序。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、卸载 Docker &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在安装 Docker 之前，我们应该确定当前的机器上是否已经安装好了 Docker，为了防止与现在安装的 Docker CE 发生冲突，这里我们先卸载掉以前版本的 Docker，如果你确定你的机器上并没有安装 Docker 的话此步可以跳过。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Linux 中可以使用 \\ 加 Enter 在输入很长很长的语句时进行换行，这里和后面的命令都是采用这样的方式。12345678sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、添加 yum 源 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在安装 Docker CE 的方式上，我是采用将 Docker CE 的源添加到 yum 源中，之后我们就可以直接使用 yum install 安装 Docker CE，整个的安装过程如下。123456789101112# 安装工具包从而可以让我们在 yum 中添加别的仓储源sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2# 设置 docker ce 的稳定库地址sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo# 安装 docker cesudo yum install docker-ce docker-ce-cli containerd.io &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们安装好 Docker 之后，我们就可以使用 docker 命令验证我们是否在机器上成功安装了 Docker，同时，也可以使用 docker –version 命令查看我们安装的 Docker CE 版本。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、设置开机自启 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当 Docker 已经在我们的机器上安装完成后，我们就可以将 Docker 设置成机器的自启服务，这样，如果出现服务器重启的情况下，我们的 Docker 也可以随服务器的重启自动启动 Docker 服务。12345# 启动 Docker 服务并允许开机自启sudo systemctl start docker# 查看当前 dokcer 的运行情况sudo systemctl status docker &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、Hello World &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像我们在学习一门新的语言时，运行的第一句代码，几乎都是打印出 Hello World，而在 Docker Hub 中，也有这么一个镜像，在无数的 Docker 教程中，安装完 Docker 后，第一件事就是拉取这个镜像文件，“告诉” Docker，我来了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Docker Hub 是存放镜像的仓库，里面包含了许多的镜像文件，因为服务器在国外的原因，下载的速度可能不理想，像国内的阿里云、腾讯云也有提供对于 Docker 镜像的加速器服务，你可以按需使用，当然，你也可以创建属于你的私有镜像仓库。1docker run hello-world &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;docker run 命令，它会在我们的本地镜像库中先寻找这个镜像，然后运行。如果在本地没有找到的话，则会自动使用 docker pull 从 Docker Hub 中寻找，能找到的话，则会自动下载到本地，然后运行，找不到的话，这条命令也就运行失败了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5、安装 Docker Compose &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在实际的项目开发中，我们可能会有多个应用镜像，例如在本篇文章的示例中，为了在 Docker 中运行我们的程序，我们需要三个镜像：应用程序自身镜像、MySQL Server 镜像、以及 Nginx 镜像，为了将我们的程序启动起来，我们需要手敲各个容器的启动参数，环境变量，容器命名，指定不同容器的链接参数等等一系列的操作，又多又烦，可能某一步操作失败后程序就无法正常运行。而当我们使用了 Docker Compose 之后，我们就可以把这些命令一次性写在 docker-compose.yml 配置文件中，以后每次启动我们的应用程序时，只需要通过 docker compose 命令就可以自动帮我们完成这些操作。12345678# 从 github 下载 docker compose 二进制文件sudo curl -L \"https://github.com/docker/compose/releases/download/1.23.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose# 对下载的二进制文件应用可执行权限sudo chmod +x /usr/local/bin/docker-compose# 查看 docker compose 版本docker-compose --version &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、构建程序镜像&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们在服务器上安装好 docker 和 docker compose 之后，就可以开始构建我们的程序镜像了。首先我们需要对我们的运行程序添加对于 Docker 的支持。你可以自己手动在 MVC 项目中添加 Dockerfile 文件，或是通过右键添加 Docker 支持。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dockerfile 就像一个执行的清单，它告诉 Docker，我们这个镜像在构建和运行时需要按照什么样的命令运行。打开 VS 为我们自动创建的 Dockerfile，可以看到清晰的分成了四块的内容。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们知道，.NET Core 程序的运行需要依赖于 .NET Core Runtime（CoreCLR），因此，为了使我们的程序可以运行起来，我们需要从 hub 中拉取 runtime ，并在 此基础上构建我们的应用镜像。同时，为了避免因为基础的环境的不同造成对程序的影响，这里的 Runtime 需要同程序开发时的 .NET Core SDK 版本保持一致，所以这里我使用的是 .NET Core 2.1 Runtime。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个镜像中包含了应用程序及其所有的依赖，与虚拟机不同的是，容器中的每个镜像最终是共享了宿主机的操作系统资源，容器作为用户空间中的独立进程运行在主机操作系统上。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PS:图片版权归属于微软的技术文档，如有侵权，请联系我删除，源文件地址：什么是 Docker？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;镜像可以看成一个个小型的“虚拟主机”，这里我们在镜像中创建了一个 /app 路径作为我们程序在镜像中的工作目录，同时，将 80 端口暴露给 Docker，从而可以使我们在镜像外面通过端口访问到当前镜像中的运行的程序。1234FROM microsoft/dotnet:2.1-aspnetcore-runtime AS baseWORKDIR /appEXPOSE 80EXPOSE 443 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为我们的应用是一个多层架构的单体应用，最终的 MVC 项目依赖于解决方案中的各个类库以及我们从 Nuget 中下载的各种第三方组件，在部署时，需要将这些组件打包成 dll 引用。所以，这里我们需要使用 .NET Core SDK 中包含的 .NET Core CLI 进行还原和构建。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像在下面的代码中，我们在镜像的内部创建了一个 /src 的路径，将当前解决方案下的类库都复制到这个目录下，之后通过 dotnet restore 命令还原我们的主程序所依赖的各个组件。当我们还原好依赖的组件后，就可以使用 dotnet build 命令生成 Release版本的 dll 文件，同时输出到之前创建的 /app 路径下。123456789101112131415FROM microsoft/dotnet:2.1-sdk AS buildWORKDIR /srcCOPY [\"PSU.Site/PSU.Site.csproj\", \"PSU.Site/\"]COPY [\"03_Logic/PSU.Domain/PSU.Domain.csproj\", \"03_Logic/PSU.Domain/\"]COPY [\"03_Logic/PSU.Repository/PSU.Repository.csproj\", \"03_Logic/PSU.Repository/\"]COPY [\"01_Entity/PSU.Entity/PSU.Entity.csproj\", \"01_Entity/PSU.Entity/\"]COPY [\"02_Infrastructure/PSU.Utility/PSU.Utility.csproj\", \"02_Infrastructure/PSU.Utility/\"]COPY [\"04_Rule/PSU.Model/PSU.Model.csproj\", \"04_Rule/PSU.Model/\"]COPY [\"02_Infrastructure/PSU.EFCore/PSU.EFCore.csproj\", \"02_Infrastructure/PSU.EFCore/\"]COPY [\"04_Rule/PSU.IService/PSU.IService.csproj\", \"04_Rule/PSU.IService/\"]COPY [\"Controllers.PSU/Controllers.PSU.csproj\", \"Controllers.PSU/\"]RUN dotnet restore \"PSU.Site/PSU.Site.csproj\"COPY . .WORKDIR \"/src/PSU.Site\"RUN dotnet build \"PSU.Site.csproj\" -c Release -o /app &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面一步可以看成我们在使用 VS 生成 Release 版本的解决方案，当生成没有出错之后，我们就可以进行程序的发布。12FROM build AS publishRUN dotnet publish \"PSU.Site.csproj\" -c Release -o /app &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当已经生成发布文件之后，按照我们平时部署在 Windows 上的过程，这时就可以通过 IIS 部署运行了，因此，构建我们应用镜像的最后一步就是通过 dotnet 命令执行我们的程序。1234FROM base AS finalWORKDIR /appCOPY --from=publish /app .ENTRYPOINT [\"dotnet\", \"PSU.Site.dll\"] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;似乎到这一步构建程序镜像就结束了，按照这样流程做的话，就需要我们将整个的解决方案上传到服务器上了，可是，很多时候，我们仅仅是把我们在本地发布好的项目上传到服务器上，这与我们现在的构建流程具有很大的不同，所以这里我们来修改 Dockerfile 文件，从而符合我们的发布流程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上面分析 Dockerfile 的过程中不难看出，在服务器上构建镜像的第二步、第三步就是我们现在在开发环境中手动完成的部分，所以这里，我们只需要对这部分进行删除即可，修改后的 Dockerfile 如下。12345FROM microsoft/dotnet:2.1-aspnetcore-runtimeWORKDIR /appCOPY . /app EXPOSE 80ENTRYPOINT [\"dotnet\",\"PSU.Site.dll\"] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在修改后的 Dockerfile 中，可以看到，我们删去了 build 和 release 的过程，选择直接将我们 Dockerfile 路径下的文件拷贝到镜像中的 /app 路径下，然后直接执行 dotnet 命令，运行我们的程序。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了确保 Dockerfile 与发布后的文件处于同一路径下，这里我们需要使用 VS 修改 Dockerfile 的属性值，确保会复制到输出的目录下，这里选择如果较新则复制即可。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三、编写 docker-compose.yml&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们构建好应用的镜像，对于 Nginx 和 MySQL 我们完全可以从 hub 中拉取下来，再执行一些配置即可。所以，我们现在就可以编写 docker compose 文件，来定义我们的应用镜像运行时需要包含的依赖以及每个镜像的启动顺序。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;右键选中 MVC 项目，添加一个 docker-compose.yml 文件，同样的，需要修改该文件的属性，以便于该文件可以复制到输出目录下。注意，这里的文件名和上文的 Dockerfile 都是特定的，你不能做任何的修改。如果你的电脑上已经安装了 Docker for Windows，你也可以使用 VS，右键添加，选中容器业务流程协调程序支持自动对 docker compose 进行配置。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 yml 文件中，我定义了三个镜像：psu.site、docker.mysql、docker.nginx。三个镜像的定义中有许多相同的地方，都设置了自动重启（restart），以及都处于同一个桥接网络下（psu-net）从而达到镜像间的通信。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;docker.mysql 是 MySQL 的镜像，我们通过环境变量 MYSQL_ROOT_PASSWORD 设置了 MySQL 的数据库连接密码，并通过挂载卷的方式将镜像中的数据库文件持久化到我们的服务器本地路径中。同时，将镜像的 3306 端口映射到服务器的 3306 端口上。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;psu.site 则是我们的程序镜像，采用位于 /usr/wwwroot/psu/ 路径下的 Dockerfile 文件进行构建的，因为主程序的运行需要依赖于数据库，所以这里采用 depends_on 属性，使我们的应用镜像依赖于 docker.mysql 镜像，即，在 docker.mysql 启动后才会启动应用镜像。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;docker.nginx 则是我们的 nginx 镜像，这里将镜像中的 80 端口和 443 端口都映射到服务器 IP 上，因为我们需要配置 Nginx 从而监听我们的程序，所以通过挂载卷的方式，将本地的 nginx.conf 配置文件用配置映射到镜像中。同时，因为我们在构建应用镜像的 Dockerfile 文件时，对外暴露了 80 端口，所以这里就可以通过 links 属性进行监听（如果构建时未暴露端口，你可以在 docker compose 文件中通过 Expose 属性暴露镜像中的端口）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Nginx 的配置文件如下，这里特别需要注意文件的格式，缩进，一点小错误都可能导致镜像无法正常运行。如果你和我一样将 nginx.conf 放到程序运行路径下的，别忘了修改文件的属性。1234567891011server { listen 80; location / { proxy_pass http://psu.site; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Host $http_host; proxy_cache_bypass $http_upgrade; }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个完整的 docker compose 文件如下，包含了三个镜像以及一个桥接网络。1234567891011121314151617181920212223242526272829303132333435363738version: '3.7'services: docker.mysql: image: mysql ports: - \"3306:3306\" restart: always environment: - MYSQL_ROOT_PASSWORD=123456@sql volumes: - /usr/mysql:/var/lib/mysql networks: - psu-net psu.site: build: /usr/wwwroot/psu/ restart: always depends_on: - docker.mysql networks: - psu-net docker.nginx: image: nginx ports: - \"80:80\" - \"443:443\" volumes: - ./nginx.conf:/etc/nginx/nginx.conf links: - psu.site networks: - psu-netnetworks: psu-net: driver: bridge &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里需要注意，所有有用到镜像间的通信的地方，我们都需要使用镜像名进行指代，例如上面的 nginx 的配置文件中，我们需要将监听的地址改为镜像名称，以及，我们需要修改程序的数据库访问字符串的服务器地址，修改后的数据库连接字符串如下所示。123\"ConnectionStrings\": { \"SQLConnection\": \"server=docker.mysql;database=PSU.Site;user=root;password=123456@sql;port=3306;persistsecurityinfo=True;\" } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;四、发布部署程序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们构建好 docker compose 文件后就可以把整个文件上传到服务器上进行构建 docker 镜像了。这里我将所有的部署文件放在服务器的 /usr/wwwroot/psu/ 路径下，这时我们就可以通过 docker compose 命令进行镜像构建。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定位到部署文件在的位置，我们可以直接使用下面的命令进行镜像的（重新）构建，启动，并链接一个服务相关的容器，整个过程都会在后台运行，如果你希望看到整个过程的话，你可以去掉 -d 参数。12# 执行镜像构建，启动docker-compose up -d &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当 up 命令执行完成后，我们就可以通过 ps 命令查看正在运行的容器，若有的容器并没有运行起来，则可以使用 logs 查看容器的运行日志从而进行排错。12345# 查看所有正在运行的容器docker-compose ps# 显示容器运行日志docker-compose logs 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本章主要是介绍了如何通过 docker 容器，完整的部署一个可实际使用的 .NET Core 的单体应用，相比于之前通过 Linux 部署 .NET Core 应用，可以看到整个步骤少了很多，也简单很多。文中涉及到了一些 docker 的命令，如果你之前并没有接触过 docker 的话，可能需要你进一步的了解。当我们将程序打包成一个镜像之后，你完全可以将镜像上传到私有镜像仓库中，或是直接打包成镜像的压缩文件，这样，当需要切换部署环境时，只需要获取到这个镜像之后即可快速完成部署，相比之前，极大的方便了我们的工作。","link":"/2019/03/20/ASP-NET-Core-on-Linux-S03/"},{"title":"ASP.NET Core 实战：将 .NET Core 2.0 项目升级到 .NET Core 2.1","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近一两个星期，加班，然后回去后弄自己的博客，把自己的电脑从 Windows 10 改到 Ubuntu 18.10 又弄回 Windows 10，原本计划的学习 Vue 中生命周期的相关知识目前也没有任何的进展，嗯，罪过罪过。看了眼时间，11月也快要结束了，准备补上一篇如何将我们的 .NET Core 2.0 版本的程序升级到 .NET Core 2.1 版本，好歹也算多学了一点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上一篇的博客中（ASP.NET Core 实战：Linux 小白的 .NET Core 部署之路），试着将我之前写的 ASP.NET Core 2.0 的项目部署到 Linux 服务器上，采用的是微软官方推荐的 Nginx + Supervisor 的方式，评论区的小伙伴提出了使用 Docker 的方式可以更便捷的实现，同时对于新手来说也会更好上手。嗯，新手向的使用 Docker 部署 ASP.NET Core 项目也会在之后的文章中体现。欢迎多多关注啊。 起因&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.NET Core 2.1 发布于今年的5月30号，从版本号我们可以看出这只是一个小版本的升级，从微软官方发布的更新信息来看，对比于 .NET Core 2.0 版本，更多的是进行性能的优化、对于 .NET Core Runtime、.NET Core tools 的更改以及增加 API 或是增加更多的系统支持。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上一篇的文章中，我们在 Linux 服务器上构建我们的 .NET Core 运行环境时，安装的是最新版本的 .NET Core Runtime，而部署的程序 .NET Core 版本则是 .NET Core 2.0（项目源码地址：https://github.com/Lanesra712/Danvic.PSU），因为并没有采取 Docker 部署的缘故，这里程序与运行环境的版本差异，可能导致我们的程序产生某些我们并不能复现的问题，所以，升级我们的程序就显得很有必要了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PS：如果你要在实际的生产项目升级你的 .NET Core 版本，慎重，慎重，再慎重！！！ Step by Step&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一、修改我们的项目目标框架&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在更新 VS 2017 的过程中，我们的 .NET Core 版本也会进行更新，当然，如果你的电脑中没有安装 .NET Core 2.1 SDK，则需要你从官网上下载最新版的 SDK 进行安装。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们已经安装好我们的 .NET Core 2.1 SDK 后，就可以将我们原来程序的目标框架更改为 .NET Core 2.1。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;右键我们的项目，我们可以直接编辑 csproj 文件 或者通过打开属性选项进行可视化的修改。其实这里我们通过属性页面进行编辑实质上就是编辑我们的 csproj 文件。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同时，为了保持我们的项目框架的一致性，我们需要将我们引用的类库的目标框架同样修改成 .NET Core 2.1。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、替换 Nuget 包引用&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 .NET Core 2.1 版本中 微软将 Microsoft.AspNetCore.All 这个 .NET Core 的基础 DLL 更换成了 Microsoft.AspNetCore.App，因此，在更新了程序的目标框架后我们还需要将我们程序删除对于 Microsoft.AspNetCore.All 的引用，同时添加对于 Microsoft.AspNetCore.App 的引用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Microsoft.AspNetCore.App 中不包含了以下 Nuget package，如果你对于这些 package 有需要的话，你可以在项目中引用这些 package。123456789101112131415Microsoft.AspNetCore.ApplicationInsights.HostingStartupMicrosoft.AspNetCore.AzureAppServices.HostingStartupMicrosoft.AspNetCore.AzureAppServicesIntegrationMicrosoft.AspNetCore.DataProtection.AzureKeyVaultMicrosoft.AspNetCore.DataProtection.AzureStorageMicrosoft.AspNetCore.Server.Kestrel.Transport.LibuvMicrosoft.AspNetCore.SignalR.RedisMicrosoft.Data.SqliteMicrosoft.Data.Sqlite.CoreMicrosoft.EntityFrameworkCore.SqliteMicrosoft.EntityFrameworkCore.Sqlite.CoreMicrosoft.Extensions.Caching.RedisMicrosoft.Extensions.Configuration.AzureKeyVaultMicrosoft.Extensions.Logging.AzureAppServicesMicrosoft.VisualStudio.Web.BrowserLink &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在引用 Microsoft.AspNetCore.App 的时候，可能会提示缺少某些依赖项或者提示我们原来引用的 Nuget 包版本不满足 Microsoft.AspNetCore.App，我们只需要根据提示的错误信息将我们缺少的依赖项添加上或者将不满足要求的版本升级就可以了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如我在升级 PSU.EFCore 这个类库中时，发现引用的程序集版本不满足我们我们使用 2.1.6 版本的 Microsoft.AspNetCore.App ，我们只需要将这些引用的 DLL 进行升级，再安装我们最新版本的 Microsoft.AspNetCore.App。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在安装 .NET Core 2.1 SDK 之后，下列的 tools 已经被包含在最新版本的 .NET Core CLI 中，因此，我们可以在 csproj 文件中删除 DotNetCliToolReference 节点下的这些引用的 Nuget 包。1234Microsoft.DotNet.Watcher.Tools (dotnet watch)Microsoft.EntityFrameworkCore.Tools.DotNet (dotnet ef)Microsoft.Extensions.Caching.SqlConfig.Tools (dotnet sql-cache)Microsoft.Extensions.SecretManager.Tools (dotnet user-secrets) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 DotNetCliToolReference 节点下的 dotnet-aspnet-codegenerator（用于生成 MVC中的 controllers 和 views 模板） Nuget 包，你同样可以选择删除这个引用，同时使用全局安装 tool 来代替它。1dotnet tool install -g dotnet-aspnet-codegenerator &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三、基于 ASP.NET Core 2.1 代码惯例的更改&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 .NET Core 升级到 2.1 版本后，ASP.NET Core 相应的也进行了一些更新，我们创建的模板中的一些基础代码也进行了修改。例如在下面示例中，我们使用 .NET Core 2.0 版本创建的 MVC 项目中的 Program.cs 代码结构与使用 .NET Core 2.1 生成的模板代码是有一定差异的。12345678910111213141516//ASP.NET Core 2.0namespace WebApp1{ public class Program { public static void Main(string[] args) { BuildWebHost(args).Run(); } public static IWebHost BuildWebHost(string[] args) =&gt; WebHost.CreateDefaultBuilder(args) .UseStartup&lt;Startup&gt;() .Build(); }} 123456789101112131415//ASP.NET Core 2.1namespace WebApp1{ public class Program { public static void Main(string[] args) { CreateWebHostBuilder(args).Build().Run(); } public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&gt; WebHost.CreateDefaultBuilder(args) .UseStartup&lt;Startup&gt;(); }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们按照最新版本的模板代码对我们的 Program.cs 代码结构进行修改。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样的，在 Startup.cs 文件中，ASP.NET Core 2.1 版本增加了对于 GDPR 的支持（欧盟的一项政策，当我们需要收集用户的数据时，必须以「简洁、透明且易懂的形式，清晰和平白的语言」向用户说明，例如这里我们使用了 cookie、session 来存储用户的数据，我们就需要提前告知用户），对于 HTTPS 的重定向支持以及增加了 SetCompatibilityVersion 方法允许应用程序选择加入或退出ASP.NET MVC Core 2.1+中引入的可能中断的行为更改（嗯，看了一圈还是不明白到底是干什么的）。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;四、其它更改&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 ASP.NET Core MVC 框架版本的更新中，同样对于引用的一些 JS 类库进行了升级，这里我就不升级了，主要为我们的程序添加对于 GDPR 政策的提示。以及要求我们的程序以 HTTPS 的形式进行访问。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们创建一个分布视图 _CookieConsentPartial 用来提示我们需要收集用户的信息，在 SecretController 控制器中添加一个 Action 用来显示我们的隐私政策，同时在我们的模板页面中引用创建的分布视图，这里的样式就不做任何的调整了，只是做个示例。1234567891011121314151617181920212223242526272829303132333435363738394041@using Microsoft.AspNetCore.Http.Features@{ var consentFeature = Context.Features.Get&lt;ITrackingConsentFeature&gt;(); var showBanner = !consentFeature?.CanTrack ?? false; var cookieString = consentFeature?.CreateConsentCookie();}@if (showBanner){ &lt;nav id=&quot;cookieConsent&quot; class=&quot;navbar navbar-default navbar-fixed-top&quot; role=&quot;alert&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#cookieConsent .navbar-collapse&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle cookie consent banner&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;span class=&quot;navbar-brand&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-info-sign&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;collapse navbar-collapse&quot;&gt; &lt;p class=&quot;navbar-text&quot;&gt; Use this space to summarize your privacy and cookie use policy. &lt;/p&gt; &lt;div class=&quot;navbar-right&quot;&gt; &lt;a asp-controller=&quot;Secret&quot; asp-action=&quot;Privacy&quot; class=&quot;btn btn-info navbar-btn&quot;&gt;Learn More&lt;/a&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default navbar-btn&quot; data-cookie-string=&quot;@cookieString&quot;&gt;Accept&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; &lt;script&gt; (function () { document.querySelector(&quot;#cookieConsent button[data-cookie-string]&quot;).addEventListener(&quot;click&quot;, function (el) { document.cookie = el.target.dataset.cookieString; document.querySelector(&quot;#cookieConsent&quot;).classList.add(&quot;hidden&quot;); }, false); })(); &lt;/script&gt;} 12//在网站的首页（登录页面）中引用分布视图&lt;partial name=&quot;_CookieConsentPartial&quot; /&gt; 123456789/// &lt;summary&gt;/// 隐私政策/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;[AllowAnonymous]public IActionResult Privacy(){ return View();} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在之前的步骤中，我们在代码中支持了使用 HTTPS 请求访问，现在我们就可以启用 SSL 来使我们通过 HTTPS 请求来访问我们的项目。 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从 .NET Core 2.0 升级到 .NET Core 2.1的整个过程来看，项目整体改动不多，在发布项目时，我们可以发现，发布后的项目的大小缩小了很多，同时还提供了对于独立部署的支持，不用做过多的操作，就可以获得一些新的优秀特性，总的来说还是很值得升级的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、依赖部署（FDD）：项目依赖于目标服务器系统上的存在的系统级 .NET Core 环境，发布后的应用仅包含其自己的代码和其它位于 .NET Core 系统级库外的第三方依赖项。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、独立部署（SCD）：发布后的项目需要包含发布后的程序所需要的全部组件（.NET Core 环境、第三方依赖项、程序代码），不依赖于目标服务器系统上的 .NET Core 环境。","link":"/2018/11/28/ASP-NET-Core-on-Linux-S02/"},{"title":"ASP.NET Core 2.0 MVC - 获取当前登录用户信息","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上篇实战完成后，没想到会有那么多的圈友给了那么多的支持，甚至连只是作为代码仓储的git上也给了一些小星星，真的感觉很惶恐啊，哈哈哈，毕竟代码写的很烂啊。由于上一篇只是大概说了下项目，所以准备写下这篇详细说下自己对于获取当前登录用户的设计与实现，原本准备上周末就完成的这篇，结果周六一起来，发现自己起水痘了，嗯，很悲催。。。请了一个星期的假，今天好歹头不痛，不发烧能看电脑了，就努力努力赶出来吧。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取当前登录用户的整体思路，我们可以通过创建一个静态的用户类，存储当前登录的用户。通过将属性值存储在session中，从而存储到服务器的内存中，做到可以在系统全局中获取当前登录用户的数据信息。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.NET Framework平台下面的MVC与.NET Core平台下面的MVC，对于Session的使用上存在着一些的差异，主要在于如何获取到Session对象。在传统的MVC项目中我们可以直接使用HttpContext.Current.Session获取到session，从而做到对于数据的取值、赋值；而在ASP.NET Core MVC中，并没有HttpContext.Current.Session这个静态类，通过查阅微软的文档可知，我们可以通过注入IHttpContextAccessor对象的方式从而获取到session对象，解决方案如下所示。 使用Session存储当前登录的用户信息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，在ASP.NET Core 中使用Session，我们需要将Session注入到ASP.NET Core的管道(pipeline)中，和我们使用MVC的方式相同，在ConfigureServices(IServiceCollection services)中，添加 1services.AddSession(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Configure(IApplicationBuilder app, IHostingEnvironment env)中添加 1app.UseSession(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样，我们就可以在MVC中使用到Session了。当然现在也只是能在Controller中获取到Session对象，如果想在别的类文件中使用到Session对象，我们需要注入IHttpContextAccessor对象。这里，我们可以使用nuget添加Microsoft.AspNetCore.Http.Extensions这个程序集，方便我们对于Session进行操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为我们采用静态类作为当前登录用户的载体，而静态类不能拥有实例构造函数，所以我采用创建一个配置方法来进行注入，CurrentUser类如下所示。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public static class CurrentUser{ #region Initialize private static IHttpContextAccessor _httpContextAccessor; private static ISession _session =&gt; _httpContextAccessor.HttpContext.Session; public static void Configure(IHttpContextAccessor httpContextAccessor) { _httpContextAccessor = httpContextAccessor; } #endregion #region Attribute /// &lt;summary&gt; /// 用户主键 /// &lt;/summary&gt; public static string UserOID { get =&gt; _session == null ? &quot;&quot; : _session.GetString(&quot;CurrentUser_UserOID&quot;); set =&gt; _session.SetString(&quot;CurrentUser_UserOID&quot;, !string.IsNullOrEmpty(value) ? value : &quot;&quot;); } /// &lt;summary&gt; ///用户编号 /// &lt;/summary&gt; public static long UserId { get =&gt; _session == null ? 0 : Convert.ToInt64(_session.GetString(&quot;CurrentUser_UserId&quot;)); set =&gt; _session.SetString(&quot;CurrentUser_UserId&quot;, value != 0 ? value.ToString() : &quot;0&quot;); } /// &lt;summary&gt; /// 用户姓名 /// &lt;/summary&gt; public static string UserName { get =&gt; _session == null ? &quot;&quot; : _session.GetString(&quot;CurrentUser_UserName&quot;); set =&gt; _session.SetString(&quot;CurrentUser_UserName&quot;, !string.IsNullOrEmpty(value) ? value : &quot;&quot;); } /// &lt;summary&gt; /// 用户登录账户 /// &lt;/summary&gt; public static string UserAccount { get =&gt; _session == null ? &quot;&quot; : _session.GetString(&quot;CurrentUser_UserAccount&quot;); set =&gt; _session.SetString(&quot;CurrentUser_UserAccount&quot;, !string.IsNullOrEmpty(value) ? value : &quot;&quot;); } /// &lt;summary&gt; /// 用户头像地址 /// &lt;/summary&gt; public static string UserImage { get =&gt; _session == null ? &quot;&quot; : _session.GetString(&quot;CurrentUser_UserImage&quot;); set =&gt; _session.SetString(&quot;CurrentUser_UserImage&quot;, !string.IsNullOrEmpty(value) ? value : &quot;&quot;); } /// &lt;summary&gt; /// 用户角色 /// &lt;/summary&gt; public static string UserRole { get =&gt; _session == null ? &quot;&quot; : _session.GetString(&quot;CurrentUser_UserRole&quot;); set =&gt; _session.SetString(&quot;CurrentUser_UserRole&quot;, !string.IsNullOrEmpty(value) ? value : &quot;&quot;); } /// &lt;summary&gt; /// 主页地址 /// &lt;/summary&gt; public static string UserPage { get =&gt; _session == null ? &quot;&quot; : _session.GetString(&quot;CurrentUser_UserPage&quot;); set =&gt; _session.SetString(&quot;CurrentUser_UserPage&quot;, !string.IsNullOrEmpty(value) ? value : &quot;&quot;); } #endregion} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们创建好了这样一个静态类后，我们就可以在登录成功后，将当前登录的用户信息赋值给这个静态类，这样我们就可以在需要使用到的地方直接使用CurrentUser这个静态类即可。在当时实际使用后发现，想要获取到登录后存储的用户信息，则必须在Controller的构造方法中调用CurrentUser的Configure方法，无形中还是增加了许多的工作量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Controller的构造函数示例代码如下：12345678910111213141516171819202122232425[Area(&quot;Administrator&quot;)][Authorize(Policy = &quot;Administrator&quot;)]public class HomeController : DanvicController{ #region Initialize private readonly ApplicationDbContext _context; private readonly ILogger _logger; private readonly IHomeService _service; private readonly IHttpContextAccessor _httpContextAccessor; public HomeController(IHomeService service, ILogger&lt;HomeController&gt; logger, IHttpContextAccessor httpContextAccessor, ApplicationDbContext context) { _service = service; _logger = logger; _httpContextAccessor = httpContextAccessor; _context = context; CurrentUser.Configure(_httpContextAccessor); } #endregion #region View #endregion} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;登录成功后给CurrentUser赋值的相关代码如下所示：12345678910111213141516171819202122232425262728293031323334/// &lt;summary&gt;/// 设置当前登录用户/// &lt;/summary&gt;public async Task SetCurrentUser(string oid, IHttpContextAccessor httpContextAccessor, ApplicationDbContext context){ CurrentUser.Configure(httpContextAccessor); var user = await PSURepository.GetUserByOIDAsync(oid, context); if (user != null) { string role = string.Empty; switch (user.AccountType) { case 0: role = &quot;Administrator&quot;; break; case 1: role = &quot;Instructor&quot;; break; case 2: role = &quot;Student&quot;; break; } CurrentUser.UserAccount = user.Account; CurrentUser.UserId = user.Id; CurrentUser.UserImage = user.ImageSrc; CurrentUser.UserName = user.Name; CurrentUser.UserOID = user.IdentityUserOID; CurrentUser.UserRole = role; CurrentUser.UserPage = user.HomePage; }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样就可以了，当需要使用到当前登录的用户信息时，直接CurrentUser.属性就可以了，整个项目的代码还是在项目实战的那个代码仓库中，源码地址https://github.com/Lanesra712/Danvic.PSU，欢迎大家提出更好的解决方案啊~~~","link":"/2018/07/25/Get-User/"},{"title":"毕业半月记","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个国内TOP1000000000000学校毕业生的个人感想&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近真的很热啊，自己在公司附近租的房子也没有空调，泪奔。。。大学毕业也有半个月的时间了，墨迹了很长时间，才把博客搭个差不多。从大三下学期萌发出想要写博客的想法，不管是记录自己的学习、工作经历，亦或是写些自己的人生经历，能记录下一些总是好的。嗯，最终一年多了还是只是在博客园里写了一篇。重新开始，希望自己能坚持下来吧~~~ Chapter One：还是毕业了&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有事情都有完结的那一天，大学四年似乎一眨眼就到了结束的时候，从2014年9月到2018年6月，四年时间，从新芜到文津，真正在学校的时间至多也没有两年半。从大三时决定不考研，出去实习开始，虽然还是个学生，却也不算是个学生了。大二小学期决定选择.NET作为自己的方向之后，自己后来的实习都是选择围绕着这个方面寻找的，大学最后的一年半时间，在外包公司呆过，也在互联网B轮创业公司呆过，信息化系统、SAAS系统都有涉及，虽然没办法和那些好学校的学生进入大厂实习做对比，但这段经历还是为我累积了许多的经验。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为之前一直实习的公司都是那种几十人的小型公司，想着还是想在毕业后去那种大一点的公司工作，4月底从实习的公司辞职准备毕业答辩开始，看的公司都是那种规模稍微大点的公司，果然是得不到的永远在骚动呢。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5月份忙着写毕业设计、改论文，找个时间面试了一家做医疗信息化的公司，嗯，最终还是在毕业后进入了这家医疗行业的公司。之后，就是答辩、毕业典礼了，想来也是遗憾，大学四年我没有参加过入学的开学典礼，最终，也还是没有参加毕业典礼。突然，大学就这样的结束了呢。在学校的最后一天，各种意外，最终寝室四个人还是没有聚齐，因为他们上班只请了一天，领完毕业证后，所有人都匆匆的离开了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后，体检、租房、入职，从一个学生变成了一个社会上的新人了。和自己当初想的不一样，入职后，最先开始的并不是和当初面试说的一样，从事web service接口的编写，而是学delphi，先维护公司很长时间之前的系统，知道后，真的是很失落，城市真的是套路深啊。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;失落过后，生活还是要继续的，决定既然目前工作的环境没办法改变，嗯，其实就是没勇气改变，那就从下班后开始吧，.NET Core在近些年.NET生态中逐渐壮大，未来肯定还是会进一步壮大的，之前的毕业设计就是用ASP.NET Core 2.0 MVC + EF Core + MySQL写的，还是属于那种传统的网站项目，之前接触过web api做接口，不过自己并没有涉及到前后端分离中的前端开发，所以决定，花至少一年的时间学习熟悉ASP.NET Core Web API和Vue.js，想着每个月至少能有一篇，在博客中记录，总结自己的学习、工作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;22啦，希望自己能坚持下去啊~ 2018-07-14 17:52:01","link":"/2018/07/14/July-One/"},{"title":"Hello World","text":"我听闻最美的故事，是公主死去了，屠龙的少年还在燃烧。所谓热血的少年，青涩的爱恋，死亡与梦之约。这么好的故事。你可别演砸了。 — 年少荒唐·朱炫","link":"/2018/07/12/Hello-World/"},{"title":"ASP.NET Core 2.0 MVC - 项目实战","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;毕业后入职现在的公司快有一个月了，公司主要的产品用的是C/S架构，再加上自己现在还在学习维护很老的delphi项目，还是有很多不情愿的。之前实习时主要是做.NET的B/S架构的项目，主要还是用的那种传统的开发模式，只有一个项目用到了Web API，自己负责后端的接口功能实现。既然现在没办法改变现状，那就先改变自己吧。定了个计划，下班后慢慢的开始学习ASP.NET Core Web API和Vue，准备从前端到后端自己写一个小项目玩玩，毕竟代码这个东西，时间长了是会忘的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;嗯，有点扯远了。这个MVC项目是我的毕业设计，虽然写的比较烂，而且当时为了赶紧写完，代码的冗余程度有点高，但还是希望能给一些准备入门ASP.NET Core MVC的童鞋提供些借鉴吧。代码我放到Github上了，源码地址https://github.com/Lanesra712/Danvic.PSU，欢迎大神们拍砖，指出不足处。 项目介绍&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;毕业论文的课题是一个大学生的一个报名系统，主要是为了完成大学生报名过程中的一些数据维护，当然最后因为实在来不及了，好多都没做。。。项目主要使用到的相关技术如下所示：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）项目框架：ASP.NET Core 2.0 MVC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）ORM：Entity Framework Core（使用Code First）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）数据库引擎：MySQL SERVER 5.7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4）权限验证：基于策略的权限验证(Policy-Based Authorization)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5）前端框架：AdminLte（一个基于Bootstrap的开源前端UI）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6）表格控件：Jquery Datatables&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7）数据可视化组件：Echarts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8）日志记录：nlog 设计与实现介绍&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;项目架构采用的是多层架构，通过拆分不同的功能领域，实现各个功能间的相对独立，项目在VS中搭建完成后如下图所示。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;01_Entity:实体层，包含PSU.Entity这一个系统组件，用于存储数据库中表所对应的C#对象实体。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;02_Infrastructure:基础架构层，包含PSU.EFCore、PSU.Utility两个系统组件。PSU.EFCore类库通过引用Entity Framework Core来完成对于数据库的操作。PSU.Utility类库中包含系统开发过程中可能用到的帮助类文件。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;03_Logic:逻辑层，包含PSU.Domain、PSU.Repository两个系统组件。PSU.Domain用于继承每个领域的接口类库（PSU.IService），实现领域接口中的功能。PSU.Repository用来实现PSU.Domain类库中所包含的对于数据库的操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;04_Rule:规则层，包含PSU.IService、PSU.Model这两个系统组件。PSU.IService为系统领域功能接口类库，PSU.Model为视图所对应的数据充血模型，对应MVC模式中的实体Model。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Controller.PSU:控制器层，.NET Core类库，用来存放MVC模式中的各种控制器文件。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PSU.Site:表现层，ASP.NET Core MVC项目，项目主程序。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系统权限验证设计：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整个系统分为三种角色，分别为管理员、教职工、学生用户，通过使用Area搭建每个角色的页面，通过在Controller上添加Area特性，指定当前Controller属于的角色。在创建用户时，会指定用户的角色字段，当用户登录成功后，会根据用户角色进行Claim的创建，通过自定义的AuthorizztionHandler来实现对于当前系统的角色权限控制。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当用户登录成功后，会将当前的用户信息赋值给一个静态类（使用Session进行存储），对于判断用户是否登录，则是通过自定义一个控制器的基类，重写OnActionExecuting方法来实现对于用户是否登录的判断，实现代码如下。 1234567891011121314151617181920/// &lt;summary&gt;/// 自定义控制器基类/// &lt;/summary&gt;public class DanvicController : Controller{ /// &lt;summary&gt; /// 判断用户是否登录 /// &lt;/summary&gt; /// &lt;param name=&quot;filterContext&quot;&gt;&lt;/param&gt; public override void OnActionExecuting(ActionExecutingContext filterContext) { if (CurrentUser.UserId == 0) { string path = filterContext.HttpContext.Request.Path; filterContext.Result = new RedirectResult($&quot;/Secret/Login?ReturnUrl={path}&quot;); return; } base.OnActionExecuting(filterContext); }} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/// &lt;summary&gt;/// 当前登录的用户信息/// &lt;/summary&gt;public static class CurrentUser{ #region Initialize private static IHttpContextAccessor _httpContextAccessor; private static ISession _session =&gt; _httpContextAccessor.HttpContext.Session; public static void Configure(IHttpContextAccessor httpContextAccessor) { _httpContextAccessor = httpContextAccessor; } #endregion #region Attribute /// &lt;summary&gt; /// 用户主键 /// &lt;/summary&gt; public static string UserOID { get =&gt; _session == null ? &quot;&quot; : _session.GetString(&quot;CurrentUser_UserOID&quot;); set =&gt; _session.SetString(&quot;CurrentUser_UserOID&quot;, !string.IsNullOrEmpty(value) ? value : &quot;&quot;); } /// &lt;summary&gt; ///用户编号 /// &lt;/summary&gt; public static long UserId { get =&gt; _session == null ? 0 : Convert.ToInt64(_session.GetString(&quot;CurrentUser_UserId&quot;)); set =&gt; _session.SetString(&quot;CurrentUser_UserId&quot;, value != 0 ? value.ToString() : &quot;0&quot;); } /// &lt;summary&gt; /// 用户姓名 /// &lt;/summary&gt; public static string UserName { get =&gt; _session == null ? &quot;&quot; : _session.GetString(&quot;CurrentUser_UserName&quot;); set =&gt; _session.SetString(&quot;CurrentUser_UserName&quot;, !string.IsNullOrEmpty(value) ? value : &quot;&quot;); } /// &lt;summary&gt; /// 用户登录账户 /// &lt;/summary&gt; public static string UserAccount { get =&gt; _session == null ? &quot;&quot; : _session.GetString(&quot;CurrentUser_UserAccount&quot;); set =&gt; _session.SetString(&quot;CurrentUser_UserAccount&quot;, !string.IsNullOrEmpty(value) ? value : &quot;&quot;); } /// &lt;summary&gt; /// 用户头像地址 /// &lt;/summary&gt; public static string UserImage { get =&gt; _session == null ? &quot;&quot; : _session.GetString(&quot;CurrentUser_UserImage&quot;); set =&gt; _session.SetString(&quot;CurrentUser_UserImage&quot;, !string.IsNullOrEmpty(value) ? value : &quot;&quot;); } /// &lt;summary&gt; /// 用户角色 /// &lt;/summary&gt; public static string UserRole { get =&gt; _session == null ? &quot;&quot; : _session.GetString(&quot;CurrentUser_UserRole&quot;); set =&gt; _session.SetString(&quot;CurrentUser_UserRole&quot;, !string.IsNullOrEmpty(value) ? value : &quot;&quot;); } /// &lt;summary&gt; /// 主页地址 /// &lt;/summary&gt; public static string UserPage { get =&gt; _session == null ? &quot;&quot; : _session.GetString(&quot;CurrentUser_UserPage&quot;); set =&gt; _session.SetString(&quot;CurrentUser_UserPage&quot;, !string.IsNullOrEmpty(value) ? value : &quot;&quot;); } #endregion} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;权限验证代码如下截图所示：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;控制器示例图：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于策略的权限验证实现：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自定义验证Claim： 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;项目最终的实现图如下所示，接下来我要开始学习ASP.NET Core Web API和Vue了，希望可以保持住，能够不间断的在博客上分享自己的学习经历与见解。当学的差不多的时候，争取把这个项目精简，重构，让自己在成为更好的自己的路途上前进一大步。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为也是第一次使用ASP.NET Core MVC进行项目的开发，所以遇到了一些自己没办法解决的东西，很感谢博客园里的各位大佬以及一些帮助我的大佬，正是因为有这么多乐于分享的人在，才能更好的推动.NET Core在国内的生态发展，在写毕业设计的过程中，参考了很多位博主的博文，真的是很感谢，致敬。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;项目实现图如下。","link":"/2018/07/20/Graduation-Project/"},{"title":"毕业入职两个月离职-职场小白的碎碎念(2)","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看了看今天的日期，好像正好毕业离开学校有两个月了，毕业后很快就入职了现在的公司，也差不多快上了两个月的班了，我最终还是选择离职了。 一些碎碎念&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原本想要写博客记录自己的学习过程的，结果技术相关的没写几篇，全变成吐槽、牢骚了，呵。等离职办完了，把之前落下的学习内容全部补上来吧。为什么想离职的原因，可能还是因为自己目前从事的工作与自己设想的方向不同吧(毕业入职两个月-职场小白的碎碎念)，我也清楚能找到百分百满意的工作是不可能的，只是希望自己从事的工作内容不会让自己有抵触吧。如果有在合肥的博友所在的公司是做.NET B/S开发并且准备招人的话，希望可以一丢丢的考虑下我，逃….&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;入职两个月，试用期还没结束，按理说并不应该这么快就提出离职的，可是自己考虑来考虑去，最终还是在昨天和老大和HR说了自己想要离职的想法，今天部门的领导又和自己谈了很长时间，聊了很多，又想了想，还是准备正式提出离职。PS，能够在一家公司稳定的干下去一两年之后，后面觉得不满意再选择跳槽，相对来说还是比很快就跳槽的好，希望各位刚入职场的童鞋别学我，逃….&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我从大三开始实习做.NET的B/S开发，到今年6月毕业，我对自己今后的规划还是希望可以从事做.NET的B/S开发。对于我来说，对于现在工作最大的抵触很大一部分就是我们部门需要做delphi开发，c#只是从事接口的开发，甚至可能我都不会接触到这一块。领导说，delphi在我们部门的开发中会占据50~60%，可是在我观察部门的工作后觉得，这个比例可能还要提高，当然，也有可能我还是小菜鸟，没办法接触到部门深层次的工作。部门的主要使用delphi，有熟悉的会知道这主要是做C/S端应用的，当然，现在使用的人数也是极少的了，同时，通过慢慢了解现有的业务，发现对于业务的实现，全部是放在存储过程中实现，em，怎么说呢，我还是觉得没有用代码实现来的便利。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用delphi做C/S端应用，很少甚至是不接触.NET开发，其实就是我很抵触的原因吧。在与领导的聊天中，他谈到部门后期也是采用C#做web service开发的，前期培训业务、delphi是因为这是我们部门工作的基础(嗯，其实就是自己看)，可能对我来说，这个后期会后多长时间，我不敢冒险，两年，三年，甚至是五年？如果我很长时间内没办法接触到.NET的B/S开发，仅靠自己下班时间后的自学，当我最终还是选择离开的时候，我到底还是不是一个.NET的B/S开发人员？我还能不能符合.NET B/S开发岗位的工作要求？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;平台，对于一个刚毕业的学生来说，会有多重要？对于我这样的学历不好的，会不会更加凸显重要性？这个我不清楚，可是周围人都是和我说，一个好的平台会更重要，可是，如果这个平台并不是你想要的呢？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不管是用C#、还是用Java，采用面向对象的思想还是面向过程的思想，其实最后还是面向工资编程，我们大多数都是普通人，都要靠自己工资生活的啊，既然我已经做出了选择，还是希望自己能够坚持下去，嗯，加油~~~","link":"/2018/08/21/Talking-LaLa2/"},{"title":"毕业入职两个月-职场小白的碎碎念","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;毕业后加入现在的公司快有两个月了，有牢骚，有对自己的想法，如果文章的内容和你产生了共鸣，不胜荣幸，如果让你感到不爽，十分抱歉。 一些碎碎念&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从实习工作开始算起，工作也有一年半的时间了，18届的应届毕业生，母校是安徽的一家体量偏大型的上市IT公司下的民办本科院校，可能有人就会问了，安徽在哪？安徽有较大型IT上市公司？哈哈哈，反正就是一所不入流的本科院校的毕业生。从学校在编程这方面的教学内容以及自己实习经历来看，虽然自己的学历不如别的学校的毕业生，但自己的在毕业后从事.NET的毕业生里，能力应该能排中等吧，哈哈哈，迷之自信。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大二小学期决定自己的专业方向是.NET后，也就认定自己如果以后从事程序员这个行当，会一直坚持去做.NET，虽然，国内.NET的生态环境现在不怎么好，可是我还是想坚持下去，毕竟这也算我除了喜欢阿森纳，每天给手机充电之外坚持最长的事情了吧。之后，学习、写代码，一股脑的塞入许多理解的不透彻概念，准备着学校为我们提供的实习工作的招聘，当然，因为院校档次的缘故，愿意来学校招聘的公司绝大多数都是那种中小型的公司，还是觉得很幸运的吧，因为学校背后公司和一些大型的公司有合作（我猜的），还是请到了几家国内某些领域排名靠前的公司来我们学校招实习生，哈哈哈，毕竟如果真是校招的话，我们的简历一定第一批就被刷下去了。后来，我被一家做信息化系统的公司录入了，虽然公司不大，能够做.NET，还是很满足的。从2016年12月26号开始，我开始了自己工作的经历。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从12月26号开始，到今年5月初因为毕业设计真的写不完了辞职回校准备毕业的事情，虽然中途换过一家公司，可是还是坚持了自己从事.NET开发的目标。这一年多的实习期间，从最开始的用Web Form做企业信息化系统，到后来去到一家A轮的互联网公司用MVC做互联网项目，一直从事的B/S开发，也认定自己以后期望的方向是从事.NET的B/S开发，当然，做接口自己也能接受，嗯，这也为自己毕业后加入现在的公司埋下了引线。写毕业设计的时候，突然脑子一热，看到.NET Core 2.0的文章也挺多的了，之后.NET的方向肯定也会逐步转移到.NET Core，索性自己边学NET Core，边将自己还没完成的毕业设计用ASP.NET Core MVC重写，哈哈哈，简直了，虽然最后删了很多的功能，幸好最后还是写完了，具体的可以看看我在园子里的这篇文章，欢迎给出意见，链接地址：ASP.NET Core 2.0 MVC - 项目实战，里面也有自己毕业设计的代码git地址。在写这个项目的时候就感觉，.NET Core真的写起来比传统的.NET项目来说更加的令人舒服，呃，反正差不多就是这样的意思，如果自己毕业后进入的公司能够从事.NET Core的开发，那真是极好的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为自己之前实习的公司都是那种小型的公司，投简历的时候，默认选择那种稍微大型点的公司，嗯，典型的得不到的永远在骚动。其实，真正面试的，也就两家，两家都在合肥，一家是做医疗信息化的，一家是做投资的公司，后面的那家需要很快就入职，面试时得知产品也准备使用.NET Core做开发了，但是因为自己想毕业后才入职，结果就不了了之了，最终，选择了第一家面试的公司。现在想想，如果当时去了第二家，会不会比现在好点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;毕业后，体检、入职，就加入了这家做医疗信息化的公司，因为之前面试时得知，自己入职后的主要工作是从事web service接口开发，结果入职那天被用人组组长领下去后才发现，好像和我想象的不一样。组长和我说，我们部门需要先从事delphi，后期再转入接口开发，你先和之前来的那些新员工一起学习delphi，熟悉业务吧。嗯，好的，先学delphi，不对，delphi是什么。。。。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从入职之后开始，先学delphi，然后熟悉his的业务、表结构，越来越觉得不爽，我是写C#的啊，不是说做接口的吗，熟悉业务这个我能理解，一直写delphi干嘛，我们用的这个版本his早被C#重构了啊？！！！可能对于我这种用惯VS的人来说，换一个IDE，突然发觉，哇，怎么现在还有这么难用的东西，慢慢的觉得，不会我这几年要一直做这个吧，我不想写delphi啊，我是要做.NET的啊！！！&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;慢慢的心里就有了想要离职的念头，可是，又觉得我入职还没一年，甚至试用期都没过完，对于后面的找工作会不会不太好，也就压下了这种想法。上周，按例我们几个新员工和组长汇报自己的学习计划，汇报最后，我们组长说了我们部门老大对我们的想法，说需要我们先从医保组开始做起，等把业务真正的完全熟悉后，后面再转入接口组的开发工作，而对于医保接口的开发，则是要使用delphi。突然心里就各种卧槽，也就是说我需要做很长时间的delphi？！！！汇报结束回到自己的座位时，发现我们部门的一个我们学校的学长他好像也是一直在做delphi（因为工位离得比较远，才发现。。。），再看看自己部门群里的工作交流，和之前认识的一个部门同事，他们好像主要的工作还是用delphi，那个认识的同事，入职快两年了，也是一直做delphi，想了下，也就是说，可能至少两三年内，我都要主要做delphi，运气好的话，可能会接触到C#，哇，这真的与我对自己的规划不一样啊！！！&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想了想，我还是准备离职，不管别的什么了，我和别人说过这件事，有的人支持我，有的人直接说我脑子有坑，说我你一个那么渣的本科毕业证，有家上市公司愿意要你，现在只是学习，每个月又有工资，天天想那些乱七八糟的干什么，可是，我还是觉得，既然我不能选择不工作，而且我选择了程序员这个行业，我还是想做让自己稍微开心点的，我还是想做.NET 的B/S开发，嗯，就这么简单。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为也有很长时间没有没有碰.NET的B/S开发了，很多东西也忘的差不多了，就算现在出去面试的话，估计很多问题也答不上来，无奈，还是决定先看看之前的代码，复习复习基础知识，找回之前写B/S的那种感觉吧，笑哭。之前说的学习ASP.NET Core WebAPI也卡在了一个问题上了，现在写好的代码没办法写完一篇文章，也就只能问问别的大佬，寻求解决方案了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baba了那么多，希望这段时间过了，自己能找到自己想从事的工作，自己学习中遇到的问题也能解决吧。如果在看到这篇文章的合肥的博友所在的公司做.NET的B/S开发，并且有招新人的打算的话，可以稍微丢丢的考虑下我，虽然我的学历可能没办法符合你们公司的要求，但是我面向谷歌编程超6的啊，哈哈哈，开玩笑。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;嗯，加油~~~","link":"/2018/08/10/Talking-LaLa/"},{"title":"【Vue 牛刀小试】：第一章 - 一些基础概念","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vue、React、Angular，当今前端界的三驾马车，作为传统的后端程序员，前端再也不是我们想的那种切切图就可以了，第一次接触的话，先了解了解一些基础的概念。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系列目录地址：Vue.js 牛刀小试&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仓储地址：Chapter01-Rookie Concept 干货合集&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、 Vue.js是什么?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架，只关注于视图层。在Vue的官网中我们可以看见，对于渐进式框架这个词，作者是加粗表示的，按照作者的设计，Vue包含了现代前端框架所必须的内容，但是你并不需要一开始就把所有的东西都用上，这些都是可选的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于Vue的解释，推荐简书上的一篇文章，文章地址：一句话理解Vue核心内容 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、 使用Vue.js后与传统的前端开发模式有何不同?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在传统的前端开发中，为了完成某个任务，我们需要使用 JS/Jquery 获取到元素的DOM元素，随后对获取到的DOM元素进行操作。而当我们使用Vue进行前端开发后，对于DOM的所有操作全部交由Vue来处理，我们只需要关注于业务代码的实现就可以了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、 如何使用Vue.js?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1、使用 script 标签引用Vue.js（这里可以在Vue的官网上下载好js文件后使用标签引入，也可以使用cdn的形式引入）1&lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js\"&gt;&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2、使用 Vue-cli 构建单页应用（需要先在电脑中安装好node.js环境才可使用）12345678910//1、全局安装Vue-Clinpm install -g vue-cli//2、进入创建项目目录下//3、创建使用webpack模板的Vue单页应用，Enter后根据提示完成项目的创建vue init webpack projectname//4、进入项目目录下//5、下载项目引用的包npm install//6、运行项目npm run dev &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PS：这里使用的是 vue-cli 的 2.x 版本，在最新的 vue-cli 3.x 版本中，包名已经发生了改变，你需要卸载原有的包之后重新安装 vue-cli 才可以，同时也可以使用页面的形式配置项目了。12345678//1、卸载原有的 vue-cli 版本npm uninstall vue-cli -g//2、安装新版本 vue-clinpm install -g @vue/cli//3、创建项目vue create projectname//3、使用页面创建vue ui &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、 MVC与MVVM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.1、MVC（Model-View-Controller）：是一种表现模式（UI / Presentation Pattern），它将软件的UI部分的设计拆分成三个主要单元，分别是Model、View和Controller。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MVC核心是控制器，它负责处理浏览器传送过来的所有请求，并决定要将什么内容响应给浏览器。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Model：模型，用于存储数据的组件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;View：视图，根据Model数据进行内容展示的组件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Controller：控制器，接受并处理用户指令，并返回内容&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.2、MVVM（Model-View-ViewModel）：MVVM的核心是ViewModel，它提供了对于Model和ViewModel的双向数据绑定，通过ViewModel连接View和Model,确保视图与数据的一致性,而这个过程是框架自动完成的,无需手动干预。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图片版权说明：由Ugaya40 - 自己的作品，CC BY-SA 3.0，链接 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一章我们主要学习了一些 vue 涉及到的一些概念，在后面的学习中，也会逐渐往本篇文章中里面添加用到的知识，文章开始处提供仓储地址里会将涉及到的知识点的汇总成一个markdown文档，希望多多关注啊，嘻嘻。","link":"/2018/08/27/Vue-Chapter01/"},{"title":"【Vue 牛刀小试】：第二章 - 常见的指令的使用","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上一章中，我们了解了一些在使用 Vue 进行开发中经常会遇到的基础概念，与传统的前端开发不同，Vue 可以使我们不必再使用 JavaScript 去操作 DOM 元素（还是可以用，但是极度不推荐），而这一优秀特性的核心就是 Vue 的指令系统，本章，一起来学习 Vue 的指令系统。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系列目录地址：Vue.js 牛刀小试&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仓储地址：Chapter01-Rookie Directives 干货合集&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、 v-cloak&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用Vue的过程中，当我们引入了 vue.js 这个文件之后，浏览器的内存中就存在了一个 vue 对象，此时，我们就可以通过构造函数的方式创建出一个 vue 的对象实例，后面就可以对这个实例进行操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果在这个过程中，对于 vue.js 的引用因为某些原因没有加载完成，此时，未编译的 Mustache 标签就无法正常显示。例如，在下面的例子中，我们模拟将网页加载速度变慢，此时就可以看见，页面最先开始会显示出插值表达式，只有 vue.js 加载完成后，才会渲染成正确的数据。1234567891011121314&lt;div id=\"app\"&gt; &lt;p&gt;{{msg}}&lt;/p&gt;&lt;/div&gt;&lt;script src=\"../lib/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; new Vue({ el: '#app', data: { msg: 'hello world' } });&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时候，我们就可以使用v-cloak指令用于隐藏未编译完成的插值表达式，一般我们在使用时会与添加一个隐藏该元素的样式同时使用。1234567891011&lt;!-- 添加 v-vloak 样式 --&gt;&lt;style&gt; [v-cloak] { display: none; }&lt;/style&gt;&lt;div id=\"app\"&gt; &lt;!-- 添加 v-vloak 指令 --&gt; &lt;p v-cloak&gt;{{msg}}&lt;/p&gt;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大家可以看到，当页面没有显示内容时，此时 p 标签添加了一个 v-cloak 属性，同时，从右侧的样式中可以看到，隐藏显示，当加载完成后， p 标签上去除了该属性，同时插值表达式也编译完成，正确显示出来。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、 v-text 与 v-html&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v-text 与 v-html 指令都可以更新页面元素的内容，不同的是，v-text 会将数据以字符串文本的形式更新，而 v-html 则是将数据以 html 标签的形式更新。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在更新数据上，我们也可以使用差值表达式进行更新数据，不同于 v-text、v-html 指令，差值表达式只会更新原本占位插值所在的数据内容，而 v-text、v-html 指令则会替换掉整个的内容。12345678910111213141516171819&lt;div id=\"app\"&gt; &lt;p&gt;+++++++++ {{msg}} -----------&lt;/p&gt; &lt;p v-text=\"msg\"&gt;=================&lt;/p&gt; &lt;p v-text=\"msgHtml\"&gt;==============&lt;/p&gt; &lt;p v-html=\"msgHtml\"&gt;============&lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { msg: 'hello world', msgHtml: '&lt;h3 style=\"color:green\"&gt;I want to learn vue.js&lt;/h3&gt;' } });&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、 v-bind&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v-bind 可以用来在标签上绑定标签的属性（例如：img 的 src、title 属性等等）和样式（可以用 style 的形式进行内联样式的绑定，也可以通过指定 class 的形式指定样式）。同时，对于绑定的内容，是做为一个 js 变量，因此，我们可以对该内容进行编写合法的 js 表达式。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在下面的示例中，我们将这个按钮的 title 和 style 都是通过 v-bind 指令进行的绑定，这里对于样式的绑定，我们需要构建一个对象，其它的对于样式的绑定方法，我们将在后面的学习中提到。123456789101112131415161718192021&lt;div id=\"app\"&gt; &lt;!-- v-bind：可以用来在标签上绑定标签的属性和样式，对于绑定的内容，可以对该内容进行编写合法的 js 表达式 可以简写为 :要绑定的内容 --&gt; &lt;!-- &lt;input type=\"button\" value=\"按钮\" v-bind:title=\"msgTitle + 'lalala'\" v-bind:style=\"{color:colorStyle,width:widthStyle+'px'}\"&gt; --&gt; &lt;!-- 使用 : 简写 --&gt; &lt;input type=\"button\" value=\"按钮\" :title=\"msgTitle + 'lalala'\" :style=\"{color:colorStyle,width:widthStyle+'px'}\"&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el: '#app', data: { msgTitle: '这是我自定义的title属性', colorStyle: 'red', widthStyle: '120' }});&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;效果示意图如下所示 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、 v-on&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在传统的前端开发中，当我们想对一个按钮绑定事件时，我们需要获取到这个按钮的 dom 元素，再对这个获取到的 dom 进行事件的绑定。在我们学习 vue 的过程中，我们可以秉持一个思想，对于 dom 的操作，全部让 vue 替我们完成，我们只关注业务代码实现，因此，我们可以使用 vue 内置的 v-on 指令来替我们完成事件的绑定。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;传统的元素 js 写法如下所示12345678&lt;input type=\"button\" value=\"点我啊~~~\" id=\"btn\"&gt;&lt;script&gt; // 传统的事件绑定方法 document.getElementById('btn').onclick = function () { alert('传统的事件绑定方法'); }&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用 v-on 指令对事件进行绑定时，我们需要在标签上指明 v-on:event(click、mousedown、mouseup 等等) 绑定的事件。1&lt;input type=\"button\" value=\"点我啊~~~\" id=\"btn\" v-on:click=\"alert(1111)\"&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样就可以了吗？我们可以测试下，哦吼，报错了，vue 提醒我们属性或者方法在 vue 实例中未定义，原来在 vue 的设计中许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写在 v-on 指令中是不可行的。因此 v-on 还可以接收一个需要调用的方法名称。所以，我们需要在 vue 实例的 methods 下写出方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，使用 v-on 指令接收的方法名称也可以传递参数，我们只需要在 methods 中定义方法时说明这个形参即可在方法中获取到。123456789101112131415161718192021&lt;input type=\"button\" value=\"点我啊~~~\" id=\"btn\" v-on:click=\"handlerClick\"&gt;&lt;!-- 使用 @ 简写 --&gt;&lt;input type=\"button\" value=\"点我啊~~~\" id=\"btn\" @click=\"handlerClickWithParam(1)\"&gt;var vm = new Vue({ el: '#app', data: { msgTitle: '这是我自定义的title属性', colorStyle: 'red', widthStyle: '120' }, methods: {//在 methods 中定义当前 vue 实例的所有可访问方法 handlerClick() { alert('我是使用 v-on 指令绑定的事件'); }, handlerClickWithParam(id) { alert('我是使用 v-on 指令绑定的事件，方法参数为'+id); } }}); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5、 v-model&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在之前的学习中，对于数据的绑定，不管是使用插值表达式还是 v-text 指令，对于数据间的交互都是单向的，即只能将 vue 实例里的值传递给页面，页面对数据值的任何操作却无法传递给 model。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，在下面的示例页面中，我们手动将页面的 h3 标签里的内容进行修改，通过控制台获取到 vue 实例中的数据，发现数据并没有发生变化。这里可以使用 window.vm 获取到 vue 实例，则是因为我们之前引入 vue.js 后，会自动在浏览器内存中创建 vue 对象，我们通过构造函数创建的 vue 的实例也就存在与浏览器的内存里了。123456789101112&lt;div id=\"app\"&gt; &lt;h3&gt;{{ msg }}&lt;/h3&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { msg: '你好啊，hahaha' } });&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MVVM中最重要的一个特性，可以说就是数据的双向绑定，而 vue 作为一个 MVVM 框架，理所应当的实现了数据的双向绑定，所以我们可以使用内置的 v-model 指令完成数据的在 View 与 Model 间的双向绑定。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们知道，只有表单元素可以与用户进行交互，所以我们只能使用 v-model 指令在表单控件或者组件上创建双向绑定。对于组件的双向绑定，我们也会在后面的学习中提到。1234567891011121314&lt;div id=\"app\"&gt; &lt;h3&gt;{{ msg }}&lt;/h3&gt; &lt;input type=\"text\" name=\"\" id=\"\" v-model:value=\"msg\"&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { msg: '你好啊，程十六' } });&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6、 v-if 与 v-show&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v-if 与 v-show 指令都是根据表达式的真假值判断元素的显示与否。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在下面的代码中，我们通过绑定一个按钮的点击事件，去修改 flag 值，从而做到对于两个 h3 标签的显示与否的控制。1234567891011121314151617181920&lt;div id=\"app\"&gt; &lt;input type=\"button\" value=\"切换\" @click=\"handlerClick\"&gt; &lt;h3 v-if=\"flag\"&gt;我是通过 v-if 指令控制的~~~&lt;/h3&gt; &lt;h3 v-show=\"flag\"&gt;我是通过 v-show 指令控制的~~~&lt;/h3&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { flag: true }, methods: { handlerClick() { this.flag = !this.flag; } } });&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到，flag 的初始值为 true，此时，两个 h3 标签都可以显示出来，当我们点击切换按钮后，两个 h3 都隐藏了，不同的是，我们可以看到，对于使用 v-if 指令控制的 h3 标签，当表达式为 false 时，这个元素 dom 会直接销毁并重建，而对于使用 v-show 指令控制的 h3 标签，当表达式为 false 时，仅仅是将当前元素的 display CSS 属性值设置为 none。所以，当我们需要频繁控制元素的显示与否时，推荐使用 v-show 指令，避免因为使用 v-if 指令而造成的高性能消耗。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7、 v-for&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不管我们是写 C# 还是写 JAVA 或者是前端的 JavaScript 脚本，提到循环数据，首先都会想到 使用 for 循环，同样的，在 vue 中，作者也为我们提供了 v-for 这一指令 用来循环数据。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用 v-for 指令时，我们可以对数组、对象、数字、字符串进行循环，获取到源数据的每一个值。使用 v-for 指令，必须使用特定语法 alias in expression ，为当前遍历的元素提供别名，这里类似于 C# 中的 foreach 的循环格式。12345678910111213&lt;div id=\"app\"&gt; &lt;!-- 1、循环数组数据 --&gt; &lt;p v-for=\"(item,index) in arrayList\" :key=\"index\"&gt;数组索引值: {{ index }} , 数据值: {{ item }}&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { arrayList: [12, 20, 34, 1, 6] } });&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 v-for 指令中，我们拥有对父作用域属性的完全访问权限。v-for 还支持一个可选的第二个参数为当前项的索引。在上面这个循环数组的代码中，item 代表了数组中的每一项数据，index 则表示为当前项的索引，所以我们可以很方便的打印出数组中每一项数据和索引。同时，我们在 ul 标签上绑定了一个 key 属性，它可以为循环出来的每一项提供一个 key 值，我们可以理解成数据库表中的每一条数据都有一个唯一的主键值，同样的，我们需要保证这个 key 值要唯一对应着当前的数据项。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里，采用循环数组对象的方式，来解释这个 key 属性要唯一的问题。123456789101112131415161718&lt;div id=\"app\"&gt; &lt;!-- 2、循环对象数组数据 --&gt; &lt;input type=\"radio\" name=\"\" id=\"\"&gt; &lt;p v-for=\"(item,index) in objList\" :key=\"index\"&gt;数组索引值: {{ index }} , id: {{ item.id }} , name: {{ item.name }} , age: {{ item.age }}&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { objList: [ {id: 1,name: 'zhangsan',age: 23}, {id: 2,name: 'lisi',age: 32}, {id: 3,name: 'wangwu',age: 22}, ] } });&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们现在循环了一个对象数组，并在每一个数据项多的前面加了一个单选框，现在我们选中 {id: 2,name: ‘lisi’,age: 32} 这个数据对象，同时，使用控制台往数组中添加新的元素。我们知道往一个数组中新增元素可以使用 push 方法或者是 unshift 方法，我们来尝试一下。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到当我们使用 push 方法在数组的最后添加一个数据时，之前单选框选择的数据没有发生更改，而当我们使用 unshift 方法在数组最前面添加一个数据时，单选框选择的数据就发生了更改。这里就是因为 key 属性绑定的是数组索引的缘故，我们选中的索引值是1，当在选中的数组元素前面添加数据时，原来选中的数组数据的索引值就会加一，所以最后就会选择到别的元素。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们就可以将 key 绑定为 item.id 这个属性，这样我们添加数据时就不会对选中的数据造成影响了，因为，我们已经告诉了程序，我们是根据 item.id 这个 key 值进行选中的，与数组的索引值无关。注意，这里如果我们添加的对象数据 id 还是3的话虽然可以添加成功，但是 vue 会给我们提示警告信息了，因为已经存在了一个 id 等于3的数据。12345&lt;div id=\"app\"&gt; &lt;!-- 2、循环对象数组数据 --&gt; &lt;input type=\"radio\" name=\"\" id=\"\"&gt; &lt;p v-for=\"(item,index) in objList\" :key=\"item.id\"&gt;数组索引值: {{ index }} , id: {{ item.id }} , name: {{ item.name }} , age: {{ item.age }}&lt;/p&gt;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于对象、数字、字符串的循环与对于数组的循环差不多，实现方法如下所示，大家可以自己编写下试试。不过在遍历对象时，是按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下是一致的。1234567891011121314151617181920212223&lt;div id=\"app\"&gt; &lt;!-- 3、遍历对象 --&gt; &lt;p v-for=\"(value,key,index) in obj\" :key=\"key\"&gt;键名: {{ key }} , 值: {{ value }} , 索引值: {{ index }}&lt;/p&gt; &lt;!-- 4、遍历数字 --&gt; &lt;p v-for=\"item in 10\" :key=\"item\"&gt;{{ item }}&lt;/p&gt; &lt;!-- 5、遍历字符 --&gt; &lt;p v-for=\"item in 'chengshiliu'\" :key=\"item\"&gt;{{ item }}&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { obj: { id: 1, name: 'chengshiliu', age: 17 } } });&lt;/script&gt; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一章我们主要学习了一些 vue 中的内置指令，熟悉了它们的使用方法，本篇文章的全部的源码都在文章开始处提供仓储地址里，每一个文件的说明，可以查看 github 仓储的 readme 说明，希望多多关注啊，嘻嘻。","link":"/2018/08/28/Vue-Chapter02/"},{"title":"【Vue 牛刀小试】：第三章 - 事件修饰符的使用","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;熟悉了 Vue 的指令系统后，在实际开发中，不可避免的会使用到对于事件的操作，如何处理 DOM 事件流，成为我们必须要掌握的技能。不同于传统的前端开发，在 Vue 中给我们提供了事件修饰符这一利器，使我们可以便捷的处理 DOM 事件，本章，一起来学习如何使用事件修饰符来实现对于 DOM 事件流的操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系列目录地址：Vue.js 牛刀小试&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仓储地址：Chapter01-Rookie Event Modifiers 干货合集&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一、 DOM 事件流&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时，当我们需要完成页面中的某些功能时，我们要在需要实现功能的页面元素上使用 v-on 指令去监听 DOM 事件，在 html4 时代浏览器如何确定页面的哪一部分会拥有特定的事件时，IE 和 Netscape 的开发团队提出了两个截然相反的概念。这一差异，也使我们在写代码中需要考虑如何去处理 DOM 的事件细节。为了解决这一问题，vue 给我们提供了事件修饰符这一利器，它使我们的方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一些涉及到概念：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、事件：用户设定或者是浏览器自身执行的某种动作。例如click(点击)、load(加载)、mouseover(鼠标悬停)、change(改变)等等&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、事件处理程序：为了实现某个事件的功能而构建的函数方法，也可称为事件监听器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、DOM 事件流：描述的是从页面中接收事件的顺序,也可理解为事件在页面中传播的顺序 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 DOM 事件流中存在着三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事件捕获（event capture）:当鼠标点击或者触发 DOM 事件时，浏览器会从根节点开始由外到内进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事件冒泡（event bubbing）:当鼠标点击或者触发 DOM 事件时，浏览器会从根节点开始由内到外进行事件传播，即点击了子元素，则先触发子元素绑定的事件，逐步扩散到父元素绑定的事件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前我们提到的 IE 和 Netscape 的开发团队提出了两个截然相反的事件流概念，IE 采取的是事件冒泡流，而标准的浏览器的事件流则是事件捕获流。所以，为了兼容 IE 我们需要改变某些的写法。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、 事件修饰符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、.stop：阻止事件冒泡&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在下面的示例中，我们分别创建了一个 button 的点击事件和外侧的 div 的点击事件，根据事件的冒泡机制我们可以得知，当我们点击了按钮之后，会扩散到父元素，从而触发父元素的点击事件，具体的结果也如下图所示：1234567891011121314151617181920&lt;div id=\"app\" class=\"divDefault\"&gt; &lt;div id=\"div1\" @click=\"divHandlerClick\"&gt; &lt;input type=\"button\" value=\"点击\" @click=\"btnHandlerClick\" /&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: {}, methods: { divHandlerClick() { alert('我是div的点击事件！') }, btnHandlerClick() { alert('我是button的点击事件') } } });&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时候，如果我们不希望出现事件冒泡，则可以使用 Vue 内置的修饰符便捷的阻止事件冒泡的产生。因为我们是点击 button 后产生的事件冒泡，我们只需要在 button 的点击事件上加上 stop 修饰符即可，示例代码如下。1&lt;input type=\"button\" value=\"点击\" @click.stop=\"btnHandlerClick\" /&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、.prevent：阻止默认事件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;阻止默认事件这个也很好理解，有些标签本身会存在事件，例如，a 标签的跳转，form 表单中 submit 按钮的提交事件等等，在某些时候我们只想执行我们自己设置的事件，这时，就需要阻止标签的默认事件的执行，原生的 js 我们可以使用 preventDefault 方法来实现，而在 Vue 中，我们只需要使用 prevent 关键字就可以了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在下面的示例中，我们为 a 标签添加了一个点击事件，由于 a 标签本身具有默认的跳转事件，此时，当我们点击后，最终还是会执行 a 标签的默认事件。12345678910111213&lt;a href=\"http://www.baidu.com\" @click=\"aHandlerClick\"&gt;链接跳转&lt;/a&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: {}, methods: { aHandlerClick() { alert('我是a标签的点击事件') } } });&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Vue 中，当我们想要阻止元素的默认事件，只需要在绑定的事件后使用 prevent 修饰符即可，示例代码如下。1&lt;a href=\"http://www.baidu.com\" @click.prevent=\"aHandlerClick\"&gt;链接跳转&lt;/a&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、.capture：添加事件监听器时使用事件捕获模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的学习中我们了解到，事件捕获模式与事件冒泡模式是一对相反的事件处理流程，当我们想要将页面元素的事件流改为事件捕获模式时，只需要在父级元素的事件上使用 capture 修饰符即可，还是上面的例子的代码，当我们在 div 绑定的点击事件上使用 capture 修饰符后，我们点击按钮首先触发的就是最外侧的 div 的事件。12345&lt;div id=\"app\" class=\"divDefault\"&gt; &lt;div id=\"div1\" @click.capure=\"divHandlerClick\"&gt; &lt;input type=\"button\" value=\"点击\" @click=\"btnHandlerClick\" /&gt; &lt;/div&gt;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、.self：只当在 event.target 是当前元素自身时触发处理函数（比如不是子元素冒泡引起的事件触发）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的例子中，我们为 div 绑定了一个点击事件，而我们的本意可能是只有当我们点击 div 后触发这个事件，而实际情况是事件冒泡还是事件捕获都会触发这个事件，这与我们的本意是不符的。在 Vue 中，我们就可以使用 self 修饰符去修饰事件，让这个事件只在我们想要触发时触发。12345&lt;div id=\"app\" class=\"divDefault\"&gt; &lt;div id=\"div1\" @click.self=\"divHandlerClick\"&gt; &lt;input type=\"button\" value=\"点击\" @click=\"btnHandlerClick\" /&gt; &lt;/div&gt;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5、.once：事件只触发一次&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们仅仅想对绑定的事件只在第一次的时候触发，这时我们就可以使用 once 修饰符去修饰绑定的事件。例如在下面的代码中，只有第一次点击时才会触发绑定的事件，之后点击都不会触发。1&lt;input type=\"button\" value=\"点击\" @click.once=\"btnHandlerClick\" /&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6、.passive：滚动事件的默认行为 (即滚动行为) 将会立即触发&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在页面滚动的时候，浏览器会在整个事件处理完毕之后再触发滚动，因为浏览器并不知道这个事件是否在其处理函数中被调用了 event.preventDefault()，而 passive 修饰符用来进一步告诉浏览器这个事件的默认行为不会被取消，即 使用 passive 修饰符后表示绑定的事件永远不会调用 event.preventDefault()。 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、不要把 .passive 和 .prevent 一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，.passive 会告诉浏览器你不想阻止事件的默认行为。 参考&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、JavaScript事件流&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、JavaScript:深入理解事件流&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、理解DOM事件流的三个阶段&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、JavaScript 详说事件机制之冒泡、捕获、传播、委托&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5、vue从入门到进阶：指令与事件（二）","link":"/2018/10/31/Vue-Chapter03/"},{"title":"【Vue 牛刀小试】：第五章 - 计算属性与监听器","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Vue 中，我们可以很方便的将数据使用插值表达式（ Mustache 语法）的方式渲染到页面元素中，但是插值表达式的设计初衷是用于简单运算，即我们不应该对差值做过多的操作。当我们需要对差值做进一步的处理时，这时，我们就应该使用到 Vue 中的计算属性来完成这一操作。同时，当差值数据变化时执行异步或开销较大的操作时，我们可以通过采用监听器的方式来达到我们的目的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系列目录地址：Vue.js 牛刀小试&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仓储地址：Chapter01-Rookie Computed Properties and Watchers 干货合集&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一、计算属性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;计算属性，一般是用来描述一个属性值依赖于另一个的属性值，当我们使用插值表达式将计算属性绑定到页面元素上时，计算属性会在依赖的属性值的变化时自动的更新 DOM 元素。例如在下面的代码中，我们在 computed 中，定义了一个 reversedMessage 属性，它可以根据我们的 data 中的 message 属性的变化自动的获取到反转后的 message 的属性值。1234567891011121314151617181920&lt;div id=\"app\"&gt; 输入的值：&lt;input type=\"text\" v-model=\"message\"&gt;&lt;br /&gt; 反转的值：{{reversedMessage}}&lt;/div&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { message: '' }, computed: { reversedMessage: function () { //这里的 this 指向 当前的 vm 实例 return this.message.split('').reverse().join('') } }, methods: {} })&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可能你会发觉，这里的写法和我们定义方法时很相似，我们完全也可以在 methods 中定义一个方法来实现这个需求。原来，计算属性的本质就是一个方法，只不过，我们在使用计算属性的时候，是把计算属性的名称直接当做属性来使用，而并不会把计算属性当做一个方法去调用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么，为什么我们还要去使用计算属性而不是去定义一个方法呢？原来，计算属性是基于它们的依赖进行缓存的。即只有在相关依赖发生改变时它们才会重新求值。例如在上面的例子中，只要 message 的属性值没有发生改变，无论任何使用我们使用到 reversedMessage 属性，都会立即返回之前的计算结果，而不必再次执行函数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反之，如果你使用方法的形式实现，当你使用到 reversedMessage 方法时，无论 message 属性是否发生了改变，方法都会重新执行一次，这无形中增加了系统的开销。当然，你也可以自己在方法中实现根据依赖进行缓存，嗯，如果你不嫌烦的话。。。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的案例中，对于 reversedMessage 这个计算属性来说，我们主要的目的是为了获取属性的值，即使用的是计算属性的 getter 方法。不过，如果你需要使用到计算属性的 setter 方法时，我们也是可以为计算属性提供一个 setter 方法的。123456789101112131415161718192021222324&lt;div id=\"app\"&gt; 输入的值：&lt;input type=\"text\" v-model=\"message\"&gt;&lt;br /&gt; 反转的值：{{reversedMessage}}&lt;/div&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { message: '' }, computed: { reversedMessage: { get: function () { return this.message.split('').reverse().join('') }, set: function (value) { this.message = value.split('').reverse().join('') } } }, methods: {} })&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的代码中，我们为计算属性 reversedMessage 增加了一个 setter 方法：通过设置 reversedMessage 的值，同样进行反转操作，并最终将结果赋值给属性 message。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、侦听属性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 vue 中，我们不光可以使用计算属性的方式来监听数据的变化，还可以使用 watch 监听器的方法来监测某个数据发生的变化。不同的是，计算属性仅仅是对于依赖数据的变化后进行的数据操作，而 watch 更加侧重于对于监测中的某个数据发生变化后所执行的一系列的业务逻辑操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;监听器以 key-value 的形式定义，key 是一个字符串，它是需要被监测的对象，而 value 则可以是字符串（方法的名称）、函数（可以获取到监听对象改变前的值以及更新后的值）或是一个对象（对象内可以包含回调函数的其它选项，例如是否初始化时执行监听 immediate，或是是否执行深度遍历 deep，即是否对对象内部的属性进行监听）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、回调值为函数方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在下面的例子中，我们监听了 message 属性的变化，根据属性的变化后执行了回调方法，打印出了属性变化前后的值。1234567891011121314151617181920&lt;div id=\"app\"&gt; 输入的值：&lt;input type=\"text\" v-model=\"message\"&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { message: '' }, computed: {}, watch: { //回调为未创建的方法 'message': function (newValue, oldValue) { console.log(`新值：${newValue} --------- 旧值：${oldValue}`) } }, methods: {} })&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样的，我们可以通过方法名称指明回调为已经定义好的方法。12345678910111213141516171819202122&lt;div id=\"app\"&gt; 输入的值：&lt;input type=\"text\" v-model=\"message\"&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { message: '' }, computed: {}, watch: { //回调为已创建好的方法 'message': 'recording' }, methods: { recording: function (newValue, oldValue) { console.log(`method记录：新值：${newValue} --------- 旧值：${oldValue}`) } } })&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、回调值为对象&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们监听的回调值为一个对象时，我们不仅可以设置回调函数，还可以设置一些回调的属性。例如，在下面的例子中，我们监听了 User 这个对象，同时执行了执行深度遍历，这时，当我们监听到 User.name 这个属性发生改变的时候，我们就可以执行我们的回调函数。注意，深度遍历默认为 false，当不启用深度遍历时，我们是无法监听到对象的内部属性的变化的。123456789101112131415161718192021222324252627&lt;div id=\"app\"&gt; 用户姓名：&lt;input type=\"text\" v-model=\"User.name\"&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { message: '', User: { name: 'zhangsan', gender: 'male' } }, computed: {}, watch: { //回调为对象 'User': { handler: function (newValue, oldValue) { console.log(`对象记录：新值：${newValue.name} --------- 旧值：${oldValue.name}`) }, deep: true } }, methods: {} })&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可能你发现了，为什么 newValue 与 oldValue 都是一样的啊？原来，当我们监听的数据为对象或数组时，newValue 和 oldValue 是相等的，因为对象和数组都为引用类型，这两个的形参指向的也是同一个数据对象。同时，如果我们不启用深度遍历，我们将无法监听到对于 User 对象中 name 属性的变化。123456789101112131415161718192021222324252627&lt;div id=\"app\"&gt; 用户姓名：&lt;input type=\"text\" v-model=\"User.name\"&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { message: '', User: { name: 'zhangsan', gender: 'male' } }, computed: {}, watch: { //回调为对象 'User': { handler: function (newValue, oldValue) { console.log(`对象记录：新值：${newValue.name} --------- 旧值：${oldValue.name}`) }, deep: false } }, methods: {} })&lt;/script&gt; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、计算属性的结果会被缓存起来，只有依赖的属性发生变化时才会重新计算，必须返回一个数据，主要用来进行纯数据的操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、监听器主要用来监听某个数据的变化，从而去执行某些具体的回调业务逻辑，不仅仅局限于返回数据。 参考&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、深入理解 Vue Computed 计算属性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、Vue 2.0学习笔记： Vue中的computed属性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、Vue系列之computed使用详解","link":"/2018/11/08/Vue-Chapter05/"},{"title":"【Vue 牛刀小试】：第四章 - 页面元素样式的设定","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前端开发中有三大件：HTML、CSS、JavaScript，在前面的学习中，不管是学习 Vue 的指令系统还是 Vue 的事件修饰符，主要还是针对的是我们在前端开发中的 JavaScript 这一块，而在实际的开发中必定会需要涉及到对于页面布局的设计。即使你采用的是使用第三方的 UI 组件，当我们实际开发中时，还是需要自己写一些样式去满足自己的需求，如何实现在 Vue 中对元素设置样式则是本章学习的重点&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系列目录地址：Vue.js 牛刀小试&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仓储地址：Chapter01-Rookie Style 干货合集&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们知道，为页面的元素设置样式主要有以下的三种方式：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、内联样式（行内样式）：即我们直接在标签元素的 style 属性中设置样式，设置的样式只能作用于当前的元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、内部样式（内嵌样式）：即我们在页面的 head 标签中使用 style 标签设置的 CSS 样式，它可以应用于当前的整个页面&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、外部样式：即我们在需要使用样式的页面的 head 标签中通过 link 导入一个 css 样式文件，或者，我们也可以使用 @import 关键字在 style 标签中引入 CSS 样式文件，因此，使用外部样式方式设置的样式可以整个网站。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class 和 style 作为页面元素的一个属性，因此我们可以在 vue 中 使用 v-bind 进行绑定处理，在 vue 中，我们只需要能通过绑定的表达式计算出字符串结果、数组、对象即可成功的为元素绑定上样式。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一、通过属性为元素设置 class 样式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在以前的前端开发中，我们可以直接在 class 属性中写上需要设置的元素样式，浏览器就会自动帮我们渲染完成，例如我们经常使用到的 Boostrap 这一类的 UI 框架，当我们在页面中引入了样式文件，再去使用其中的样式，只需要在 class 属性中指明样式名称即可。例如下面的代码中我们创建了一个固定宽度并支持响应式布局的 div。1&lt;div class=\"container\"&gt;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而当我们想以同样的方法为元素的 class 属性设置样式时，我们可以发现我们期望的结果并没有出现。打开控制台，我们可以看到 vue 给我们提供了一个报错信息：当前实例上找不到名为 textRed 的属性或是方法。通过在之前学习 v-bind 指令的时候了解到，这里绑定的其实是一个 js 变量，所以在这里我们对于样式的绑定并不会生效。1234567&lt;style&gt; .textRed { color: red }&lt;/style&gt;&lt;h2 :class=\"textRed\"&gt;&lt;/h2&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、数组语法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在vue 中作者给我们提供了使用数组进行绑定样式的方式，这里我们可以直接在数组中写上样式的类名即可。注意：这里如果不使用单引号包裹类名，其实代表的还是一个变量的名称，因此，还是会出现错误信息。123456789101112&lt;style&gt; .textRed { color: red } .textThin { font-weight: 200 }&lt;/style&gt;&lt;div id=\"app\"&gt; &lt;h2 :class=\"['textRed','textThin']\"&gt;我是标题标题标题标题标题标题啊啊啊啊~~~&lt;/h2&gt;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，如果你就是想以变量的方式，就需要你先定义好这个变量。1234567891011121314151617181920212223&lt;style&gt; .textRed { color: red } .textThin { font-weight: 200 }&lt;/style&gt;&lt;div id=\"app\"&gt; &lt;h2 :class=\"[textRed,textThin]\"&gt;我是标题标题标题标题标题标题啊啊啊啊~~~&lt;/h2&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { textRed: 'active', textThin: 'text-danger' }, methods: {} })&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们需要设置多个样式时，只需要在这个数组中增加样式类名即可，我们通过查看元素可以发现，这里已经自动渲染成了浏览器可以识别的写法。可能你会发现，这样写好像没有什么好处啊，反而比之前更麻烦了。不过，在这里我们可以使用三元表达式根据条件切换列表中的 class ，嗯，这种写法原来的写法是不可以的。12345678910111213141516171819202122232425&lt;style&gt; .textRed { color: red } .textThin { font-weight: 200 } .textAquamarine { color: aquamarine }&lt;/style&gt;&lt;div id=\"app\"&gt; &lt;h2 :class=\"[flag?'textAquamarine':'textRed','textThin']\"&gt;我是标题标题标题标题标题标题啊啊啊啊~~~&lt;/h2&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { flag: true }, methods: {} })&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，我们就可以根据 flag 的值去加载不同的样式。不过当有多个条件 class 时这样写有些繁琐。所以在数组语法中也可以使用对象语法：1&lt;h2 :class=\"[{'textAquamarine':flag,'textRed':!flag},'textThin']\"&gt;我是标题标题标题标题标题标题啊啊啊啊~~~&lt;/h2&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、对象语法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的例子的最后，我们在数组中使用了对象的形式来设置样式，而在 vue 中，我们也可以直接使用对象的形式来设置样式。此时，对象的属性为样式的类名，value 则为 true or false，当值为 true 时则显示样式。这里，由于对象的属性可以带引号，也可不带引号，所以属性就按照你自己的习惯写法就可以了。1&lt;h2 :class=\"{textAquamarine:flag,textThin:flag}\"&gt;我是标题标题标题标题标题标题啊啊啊啊~~~&lt;/h2&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当对象中的属性过多时，如果我们还是采用直接全部写到元素上时，势必会显得比较繁琐，这时，我们同样可以在元素上只写上对象变量就可以了，当然，别忘了在 vue 实例中定义。1234567891011121314&lt;h2 :class=\"styleObject\"&gt;我是标题标题标题标题标题标题啊啊啊啊~~~&lt;/h2&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { styleObject: { textAquamarine: true, textThin: true } }, methods: {} })&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、通过属性为元素设置 style 样式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、对象语法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与使用属性为元素设置 class 样式相同，在 vue 中，我们也可以使用对象的方式，为元素设置 style 样式。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v-bind:style 的绑定对象的语法虽然像 CSS，但其实实质上还是一个 JavaScript 对象。CSS 属性名可以用驼峰命名法 (camelCase) 或短横线分隔 (kebab-case，需使用单引号括起来) 来命名。1&lt;h2 :style=\"{color:'aquamarine','font-weight': '200'}\"&gt;我是标题标题标题标题标题标题啊啊啊啊~~~&lt;/h2&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样的，可以直接绑定一个样式对象变量，这样的话代码看起来也会更简洁美观。1234567891011121314&lt;h2 :style=\"styleObject\"&gt;我是标题标题标题标题标题标题啊啊啊啊~~~&lt;/h2&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { styleObject: { color: 'aquamarine', 'font-weight':200 } }, methods: {} })&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、数组语法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们使用数组的方式为 style 属性设置样式的时候，数组中每一项都是 vue 实例中 data 中的样式对象，即我们可以设置多个样式对象，通过数组的方式，全部应用到元素上。12345678910111213141516&lt;h2 :style=\"[baseStyle,additionStyle]\"&gt;我是标题标题标题标题标题标题啊啊啊啊~~~&lt;/h2&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { baseStyle: { color: 'aquamarine' }, additionStyle: { 'font-weight': '200' } }, methods: {} })&lt;/script&gt; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、在 vue 中可以使用数组语法、对象语法对绑定的 class、style 属性的元素设定样式。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于数组语法来说，绑定 class 属性的元素在设置样式时在数组中放置的元素为各个样式类的类名（直接放置类名需要加上单引号）；而绑定 style 属性的元素在设置样式时再数组中放置的则是一个个包含样式的对象。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于对象语法来说，绑定 class 属性的元素在设置样式时对象的每一个属性为样式类名，对应的属性值则是布尔值，我们则可以通过更改属性值的 true or false 来设置样式的是否启用；而对于绑定 style 属性的元素在设置样式时，对象中的属性则是一个个的 css 内置属性，而对应的属性值则是这个 css 属性的自定义值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、当 v-bind:style 使用需要添加浏览器引擎前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。","link":"/2018/11/04/Vue-Chapter04/"},{"title":"【Vue 牛刀小试】：第六章 - 按键修饰符的使用","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上周末的时候，准备试试将 ASP.NET Core 的项目部署到 CentOS 服务器上，结果在一个接一个坑里面跳，最后 Supervisor 守护程序还是有问题，于是，采用重装系统大招，结果，碰巧赶上 aspnetcore 的一个 bug（Missing package dotnet-runtime 2.1.6 for CentOS），嗯，最后 dotnet core 环境装不上了，原本打算更新的 .NET Core 文章以及日常的 Vue 学习计划也暂时搁浅了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在之前的 Vue 的学习中，我们学习了如何使用事件修饰符去处理 DOM 事件，而在某些实际场景中，我们也需要去设定各种按键事件去优化页面的交互，本章，我们来学习下在 Vue 中如何去监听键盘事件。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系列目录地址：Vue.js 牛刀小试&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仓储地址：Chapter01-Rookie Keyboard Modifiers 干货合集&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一、 按键修饰符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在日常的页面交互中，我们经常会遇到这种需求：用户输入账号密码后点击 Enter 键、一个多选筛选条件通过点击多选框后自动加载符合选中条件的数据等等。在传统的前端开发中，当我们碰到这种类似的需求时，我们往往需要知道 js 中需要监听的按键所对应的 keyCode，然后通过判断 keyCode 得知用户是按下了那个按键，继而执行后续的操作。例如，在下面的示例中，当我们松开 Enter 按键后控制台就会打印出姓名输入框内的值。123456789&lt;label&gt;姓名：&lt;/label&gt;&lt;input id=\"name\" type=\"text\"&gt;$('#name').on('keyup',function(event){ event.preventDefault();//阻止浏览器默认动作 if(event.Code == 13){ console.log($(this).val()); }}); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而在 Vue 中，给我们提供了一种便利的方式去实现监听我们的按键事件。在监听键盘事件时，我们经常需要查找常见的按键所对应的 keyCode，而 Vue 为最常用的按键提供了别名。123456789.enter.tab.delete (捕获“删除”和“退格”键).esc.space.up.down.left.right &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在下面的代码中，我们同样监听了 input 框的 Enter 事件，而我们只需要在绑定的 input 标签的 keyup 事件上添加 .enter 修饰符即可。123456789101112131415161718&lt;div id=\"app\"&gt; &lt;label&gt;姓名：&lt;/label&gt; &lt;input id=\"name\" type=\"text\" v-model:value=\"name\" @keyup.enter=\"log\"&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { name: '' }, methods: { log() { console.log(`name:${this.name}`); } } })&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，对于标准的104键盘，Vue 不可能帮我们把所有的按键键值都定义好，这也不现实。于是，Vue 给我们提供了一种通过定义全局 config.keyCodes 来自定义按键修饰符的别名的方式。例如，在上面的例子中，我们是通过 Enter 按键获取到输入的文本框的值，现在，我们的需求变了，需要我们通过 F2 按键来获得文本框的值，这时我们就可以通过自定义按键修饰符来实现操作。123456789101112131415161718192021&lt;div id=\"app\"&gt; &lt;label&gt;姓名：&lt;/label&gt; &lt;input id=\"name\" type=\"text\" v-model:value=\"name\" @keyup.prevent.f2=\"logF2\"&gt;&lt;/div&gt;&lt;script&gt; //通过 keyCode 自定义按键修饰符 Vue.config.keyCodes.f2 = 113 var vm = new Vue({ el: '#app', data: { name: '' }, methods: { logF2() { console.log(`name:${this.name} --- 通过 F2 按键获得`); } } })&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、 系统修饰符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Vue 的2.1.0版本中，开发者又为我们提供了系统修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器事件。123456789//键盘按键修饰符.ctrl.alt.shift.meta//鼠标键盘修饰符.left.right.middle &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)。在其他特定键盘上，尤其在 MIT 和 Lisp 机器的键盘、以及其后继产品，比如 Knight 键盘、space-cadet 键盘，meta 被标记为“META”。在 Symbolics 键盘上，meta 被标记为“META”或者“Meta”。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可能你会觉得，这和按键修饰符也没什么差别啊，都是按下按键然后执行操作啊，看了看官方文档的解释，em，好像更晕了。既然如此我们来使用试试。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在下面的案例中，我们为 input 输入框绑定 ctrl 按键事件，我们来看看与按键修饰符的使用有什么区别。123456789101112131415161718&lt;div id=\"app\"&gt; &lt;label&gt;姓名：&lt;/label&gt; &lt;input id=\"name\" type=\"text\" v-model:value=\"name\" @keyup.ctrl=\"log\"&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { name: '' }, methods: { log() { console.log(`name:${this.name}`); } } })&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可能你在疑问，我在干什么，如果你自己尝试就会发现，当我们在狂点 ctrl 按键时，控制台不会输出任何信息，所以说，我们自定义的方法其实并没有执行。仔细看看，官方文档中的示例，系统修饰符的使用示例中，都是绑定了两个的修饰符，难道，系统修饰符必须和其它的按键修饰符一起使用才可以生效吗？我们来继续尝试。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在下面的示例中，我们将 ctrl 系统修饰符与 keyCode 为67（C）的按键修饰符一起使用看看。123456789101112131415161718&lt;div id=\"app\"&gt; &lt;label&gt;姓名：&lt;/label&gt; &lt;input id=\"name\" type=\"text\" v-model:value=\"name\" @keyup.ctrl.67=\"log\"&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { name: '' }, methods: { log() { console.log(`name:${this.name}`); } } })&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可能 gif 图表达的不是很清楚，当我点击 ctrl 按键时，没有执行我们的 log 方法，当我点击 c 按键时也并没有执行我们的自定义方法，可是当我按下 ctrl 按键时，又点击 c 按键时（这里的操作等同于你在编辑文档时使用 ctrl+c 组合按键），却执行了我们自定义的 log 方法。通过多次尝试，可以发现当我们写如下代码的时候,我们会发现如果仅仅使用系统修饰键是无法触发 keyup 事件的。1234&lt;div id=\"app\"&gt; &lt;label&gt;姓名：&lt;/label&gt; &lt;input id=\"name\" type=\"text\" v-model:value=\"name\" @keyup.ctrl=\"log\"&gt;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还是之前的代码，在测试的过程中，不知你是否发现，当我们绑定一个 ctrl 系统修饰符时，当我们同时使用多个系统修饰符也会触发我们的自定义事件，这肯定与我们所需要的不同。于是 Vue 在2.5.0版本中新增了 .exact 修饰符允许我们控制由精确的系统修饰符组合触发的事件。例如在下面的代码中，我们限制只能使用 ctrl+按键修饰符，却不能使用多个系统修饰符+按键修饰符一起使用。你可以亲身尝试下，你会发现，当我们使用 ctrl+c、ctrl+s 时会触发我们的自定义 log 事件，可是当你使用 ctrl+alt+c 时就不会触发我们的自定义 log 事件。1234&lt;div id=\"app\"&gt; &lt;label&gt;姓名：&lt;/label&gt; &lt;input id=\"name\" type=\"text\" v-model:value=\"name\" @keyup.ctrl.exact=\"log\"&gt;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类似的在 Vue 的2.2.0版本中，开发者又为我们提供了鼠标按钮修饰符去触发鼠标事件监听器。例如下面的代码所示，当我们鼠标右键点击我们的按钮时才会触发我们的自定义 log 事件。1234&lt;div id=\"app\"&gt; &lt;input id=\"name\" type=\"text\" v-model:value=\"name\"&gt; &lt;button @click.right=\"log\"&gt;log&lt;/button&gt;&lt;/div&gt; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、对于 keyup 事件，按键修饰符可以直接使用，而系统修饰符则是以一种组合按键的形式使用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、我们可以通过全局 config.keyCodes 对象自定义按键修饰符别名，也可以直接使用 keyCode 为按键设定按键修饰符。 参考&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、vue修饰符–可能是东半球最详细的文档（滑稽）","link":"/2018/11/15/Vue-Chapter06/"},{"title":"【Vue 牛刀小试】：第七章 - Vue 实例的生命周期","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在之前的 Vue 学习中，我们在使用 Vue 时，都会创建一个 Vue 的实例，而每个 Vue 实例在被创建时都要经过一系列的初始化过程。例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。在这个过程中，Vue 会运行一些生命周期钩子函数，而我们则可以在钩子函数中编写一些自定义方法，用以在 Vue 的整个生命周期中某些阶段实现我们特殊需求。那么，本章，我们就来了解 Vue 实例的生命周期钩子函数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系列目录地址：Vue.js 牛刀小试&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仓储地址：Chapter01-Rookie Lifecycle Hooks 干货合集&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们使用 Vue 的时候，都会先创建一个 Vue 实例，这个实例不仅是我们挂载 Vue 框架的入口，也是 MVVM 思想中的 VM(ViewModel)。在我们使用 Vue 的整个过程中，归根结底都是在对这个 Vue 实例进行操作。因此，只有当我们了解 Vue 实例的生命周期之后，才可以更好的实现我们的业务逻辑。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Vue 官网的这张生命周期图示中，我们可以看到整个生命周期中包含了8个钩子函数：beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed。从字面意思我们就可以清楚的看出来，这8个钩子函数两个一组，分别对应于 Vue 实例的创建、挂载、更新、销毁，接下来，我们就根据这四个阶段，解释 Vue 实例各个阶段中的钩子函数的作用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一、 beforeCreate &amp; created&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们通过 new Vue() 创建了一个 Vue 实例之后,会执行 init 方法，此时只会初始化 Vue 实例所包含的一些默认的事件与生命周期函数，在这个实例还未被完全创建之前，则会执行我们的 beforeCreate 钩子函数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在下面的例子中，我们在实例化 Vue 对象时，自定义了一个 message 属性，同时设定了一个 show 方法，现在我们来看看当实例并没有完全被创建之前，是否能够获取到我们自定义的属性与方法。123456789101112131415161718192021222324&lt;div id=\"app\"&gt; {{message}}&lt;/div&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { message: 'Hello World!' }, methods: { show() { console.log('执行了 show 方法'); } }, beforeCreate() { console.log(`Vue 实例挂载对象 el：${this.$el}`) console.log(`Vue 实例的 data 对象：${this.$data}`) console.log(`Vue 实例的 message 属性值：${this.message}`) console.log(`Vue 实例的 methods 对象：${this.$options.methods}`) this.show(); } })&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从浏览器的控制台中我们可以看到，此时，Vue 实例中的 data、methods 对象，或是我们定义的 Vue 实例的挂载点元素，在 beforeCreated 生命周期钩子函数执行时，都没有进行了初始化。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当 beforeCreated 钩子函数执行完成后，Vue 实例已经初始化完成，此时将要执行生命周期中的 created 钩子函数来监听我们对于数据的更改或是监听事件。123456789101112131415161718192021222324&lt;div id=\"app\"&gt; {{message}}&lt;/div&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { message: 'Hello World!' }, methods: { show() { console.log('执行了 show 方法'); } }, created() { console.log(`Vue 实例挂载对象 el：${this.$el}`) console.log(`Vue 实例的 data 对象：${this.$data}`) console.log(`Vue 实例的 message 属性值：${this.message}`) console.log(`Vue 实例的 methods 对象：${this.$options.methods}`) this.show(); } })&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从浏览器控制台打印出的信息可以看出，在执行 created 钩子函数的过程中，对于自定义的属性 message、自定义的方法 show 已经初始化完成，此时，整个 Vue 实例已经初始化完成。但是，对于我们的 Vue 实例的挂载点元素还没有进行初始化。也就是说，当执行完 created 之后，Vue 实例与 View(视图层)之间依旧是处于隔离的状态，初始化完成的 Vue 实例也依旧没有与 DOM 进行绑定。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、 beforeMount &amp; mounted&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当 Vue 实例执行完 beforeCreated、created 钩子函数之后，Vue 实例已经初始化完成，而 Vue 实例并没有挂载到页面的 DOM 上。在挂载到页面 DOM 元素之前，则需要执行 beforeMount 钩子函数将我们的实例绑定到模板上进行编译渲染。1234567891011121314151617181920&lt;div id=\"app\"&gt; &lt;h3 id=\"h3\"&gt;{{message}}&lt;/h3&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { message: 'Hello World!' }, methods: { show() { console.log('执行了 show 方法'); } }, beforeMount() { console.log(document.getElementById('h3').innerText) } })&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从控制台输出的信息可以看到，当执行到 beforeMount 钩子函数时，已经将模板编译完成，但是尚未挂载到页面上去。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当把编译完成的模板挂载到页面上时，则需要执行 mounted 钩子函数，在这个阶段，用户就可以看到已经渲染好的页面。1234567891011121314151617181920&lt;div id=\"app\"&gt; &lt;h3 id=\"h3\"&gt;{{message}}&lt;/h3&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { message: 'Hello World!' }, methods: { show() { console.log('执行了 show 方法'); } }, mounted() { console.log(document.getElementById('h3').innerText) } })&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们可以看到，已经可以获取到差值表达式的值，即当执行到 mounted 钩子函数时，页面已经渲染完成了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上面的例子中可以看出，mounted 是创建 Vue 实例过程中的最后一个生命周期钩子函数，当执行完 mounted 钩子函数之后，实例已经被完成创建好，并已经渲染到页面中，此时，如果我们不对实例进行任何的操作的话，Vue 实例则不会执行 新的生命周期钩子函数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三、 beforeUpdate &amp; updated&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在执行完了 mounted 钩子函数之后，Vue 实例实际已经脱离了实例的创建阶段，进入实例的运行阶段。此时，当我们对实例的 data 进行修改时，则会触发 beforeUpdate、updated 这两个钩子函数。123456789101112131415161718192021&lt;div id=\"app\"&gt; &lt;h3 id=\"h3\"&gt;{{message}}&lt;/h3&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { message: 'Hello World!' }, methods: { show() { console.log('执行了 show 方法'); } }, beforeUpdate() { console.log(`页面上的数据：${document.getElementById('h3').innerText}`) console.log(`data 中的 message 数据：${this.message}`) } })&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到，当我们对 data 中的 message 属性进行修改时，在执行 beforeUpdate 钩子函数时，页面上的数据还是旧的数据，而 data 中 message 属性已经将值修改成了最新的值（这里页面上显示的为修改后的数据则是因为执行了后面的钩子函数，将修改后的数据同步渲染到了页面上）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vue 作为一个具有数据双向绑定特性的框架，当我们实时修改了页面元素的值之后，肯定希望页面可以同步变更数据。而在执行 beforeUpdate 钩子函数之后，我们已经在实例中修改了数据，现在只需要重新渲染到页面就可以了，这时候，则会执行 updated 钩子函数。123456789101112131415161718192021&lt;div id=\"app\"&gt; &lt;h3 id=\"h3\"&gt;{{message}}&lt;/h3&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { message: 'Hello World!' }, methods: { show() { console.log('执行了 show 方法'); } }, updated() { console.log(`页面上的数据：${document.getElementById('h3').innerText}`) console.log(`data 中的 message 数据：${this.message}`) } })&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从控制台可以看到，当 updated 钩子函数执行的时候，页面和 data 中的数据已经完成了同步，都显示的是最新的数据。此时，整个页面数据实时变更的操作也已经完成了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;四、 beforeDestroy &amp; destroyed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既然有 Vue 实例的创建，那么在我们不需要 Vue 实例的时候就需要将这个实例进行销毁。而 beforeDestroy 以及 destroyed 钩子函数则会帮我们实现这一目的。12345678910111213141516171819202122232425262728293031&lt;div id=\"app\"&gt; {{message}}&lt;/div&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { message: 'Hello World!' }, methods: { show() { console.log('执行了 show 方法'); } }, beforeDestroy() { console.log(`Vue 实例挂载对象 el：${this.$el}`) console.log(`Vue 实例的 data 对象：${this.$data}`) console.log(`Vue 实例的 message 属性值：${this.message}`) console.log(`Vue 实例的 methods 对象：${this.$options.methods}`) this.show(); }, destroyed() { console.log(`Vue 实例挂载对象 el：${this.$el}`) console.log(`Vue 实例的 data 对象：${this.$data}`) console.log(`Vue 实例的 message 属性值：${this.message}`) console.log(`Vue 实例的 methods 对象：${this.$options.methods}`) this.show(); } })&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里，我们手动销毁 Vue 实例，从控制台的输出内容可以看到，在 beforeDestroy 和 destroyed 钩子函数执行中，我们依旧可以获取到 Vue 实例的相关内容，可是，当我们选择更新 message 属性的值时会发现，此时，页面上显示的值并没有发生改变。原来，这里的销毁并不指代’抹去’这个 Vue 实例，而是表示将 Vue 实例与页面的 DOM 元素进行’解绑’。 总结 钩子函数 描述 beforeCreate Vue 实例进行初始化，此时实例的各个组件还没有进行初始化完成，因此不能访问到 data、computed、watch、methods 上的方法和数据，同时，Vue 实例的挂载点也没有进行初始化 created Vue 实例初始化完成，此时可以访问 data、computed、watch、methods 上的方法和数据，但是依旧没有进行 Vue 实例的挂载点初始化 beforeMount 将实例绑定到模板并进行渲染，但并不会将实例挂载到页面上 mounted 将渲染好的模板绑定到页面上，此时，Vue 实例已完全创建好 beforeUpdate 数据变更时调用，在实例数据更改之前执行任何应该发生的自定义逻辑或操作 updated 将 Vue 实例更新完成的数据重新渲染到内存中的虚拟 DOM 上，再将虚拟 DOM 应用到页面上 beforeDestroy Vue 实例进入销毁阶段，此时实例上的 data、methods、过滤器、指令等等还是处于可用的状态，还没有真正执行销毁的过程（解除与页面 DOM 元素的绑定） destroyed 实例被销毁（解除与页面 DOM 元素的绑定） 参考&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、详解vue生命周期&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、Vue2.0 探索之路——生命周期和钩子函数的一些理解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、vue生命周期详解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、vue生命周期探究（一）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5、Vue生命周期深入&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6、Vue 数据绑定和响应式原理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7、Vue.js – lifecycle hooks, the layman’s overview","link":"/2018/12/12/Vue-Chapter07/"},{"title":"【Vue 牛刀小试】：第九章 - 组件基础再探（data、props）","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上一章的学习中，我们学习了 Vue 中组件的基础知识，知道了什么是组件，以及如何创建一个全局/局部组件。不知道你是否记得，在上一章中，我们提到组件是一个可以复用的 Vue 实例，它与 Vue 实例也只是拥有些许的差异。本章，我们将继续学习组件的相关基础知识，了解 Vue 的组件中的 data、prop 选项的使用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系列目录地址：Vue.js 牛刀小试&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仓储地址：Chapter02-Bronze Component Advance 干货合集&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一、 组件中的 data 选项&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当一个 Vue 实例被创建之后，实例中的 data 选项的属性值就与页面的视图做了一个“绑定”，当我们修改 data 中的属性值时，视图就会产生“响应”，同时，页面上使用到属性值的地方也会同步更新。那么，组件作为一个特殊的 Vue 实例，对于 data 选项的使用上是不是和在 Vue 实例中的使用方式相同呢。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们还是先创建一个全局组件，按照 Vue 实例中使用 data 选项的使用方法，将 data 选项添加到组件的定义中，同时，使用插值表达式在页面中显示出属性值，示例代码如下。123456789101112131415161718192021222324&lt;div id=\"app\"&gt; &lt;tmpl&gt;&lt;/tmpl&gt;&lt;/div&gt;&lt;template id=\"tmpl\"&gt; &lt;div&gt; &lt;h3&gt;这是全局组件，啊啊啊啊啊啊&lt;/h3&gt; &lt;h4&gt;{{name}}&lt;/h4&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; Vue.component('tmpl', { template: '#tmpl', data: { name: 'zhangsan' } }); var vm = new Vue({ el: '#app', data: {} });&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行我们的代码，发现页面上并没有显示出数据，看下控制台，嗯，报错了。我们一条条的看报错信息。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一条报错信息，在创建组件实例中的 data 选项时，返回的应该是一个实例对象的方法。什么意思呢？回想一下我们在创建 Vue 实例时添加 data 选项，我们创建的是一个 data 对象，而根据控制台的报错信息提示，当我们在组件中使用 data 选项时，我们需要返回包含实例对象的方法，我们可以按照这个提示修改试试。12345678910&lt;script&gt; Vue.component('tmpl', { template: '#tmpl', data: function () { return { name: 'zhangsan' } } });&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到，在组件的 data 选项中，我们将 data 选项定义成一个方法，并在这个方法中返回了一个对象实例，此时，刷新页面，可以看到两条错误信息已经都不见了，页面也已经可以正常显示出数据。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么会这样呢，查看 Vue 的官方文档后，我们可以找到这样一句解释：一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回对象的独立的拷贝，再联系上面报错信息提到的，在方法中返回对象实例，是不是说，当我们在方法中返回的是一个定义好的对象，会出问题呢？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们来继续试试。这里，我们将在 data 选项中返回的对象改成在外部定义，同时，多次调用这个组件，完整的示例代码如下。1234567891011121314151617181920212223242526272829303132333435&lt;div id=\"app\"&gt; &lt;counter&gt;&lt;/counter&gt; &lt;hr /&gt; &lt;counter&gt;&lt;/counter&gt;&lt;/div&gt;&lt;template id=\"counter\"&gt; &lt;div&gt; &lt;button @click=\"add\"&gt; Add &lt;/button&gt; &lt;h3&gt;count：{{count}}&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var dataObj = { count: 0 } Vue.component('counter', { template: '#counter', data: function () { return dataObj }, methods: { add() { dataObj.count++ } }, }) var vm = new Vue({ el: '#app', data: {} });&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到，因为我们在 data 中返回的对象并不是一个新的对象实例，当我们修改返回对象中的属性值时，所有使用到当前组件的地方都会发生变更，这无疑是无法接受的。因此，为了避免这一情况，当我们需要在创建组件时需要添加 data 选项，我们需要在 data 方法中返回对象实例，而不是一个已经定义好的对象。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、 组件中的 props 选项&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;组件的 Props 选项是我们可以在组件上注册的一些自定义特性，当我们将一个值传递给一个 props 选项中的特性时，那个 prop 特性就变成了组件实例的一个属性，这时候，我们当然就可以获取到这个值了，因此，组件中的 props 经常用于将我们的父组件值传递到子组件或是将 Vue 实例中的属性值传递到组件中使用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在父组件/Vue实例引用子组件的时候，通过属性绑定的方式（v-bind），将需要传递给子组件的数据进行传递，从而在子组件内部，通过绑定的属性值获取到父组件/Vue实例的数据。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，在下面的代码中，我在 Vue 实例中定义了一个局部组件，将实例的 title 属性绑定到组件的 parenttitle 属性上，同时，将 parenttitle 属性赋值给组件的 content 属性，从下面的代码中不难看出，我们希望的是可以实时获取到父组件的 title 属性值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PS：这里和之前定义组件名称一样，因为在 HTML 中，对于大小写是不敏感的，因此，如果这里你采用了 camelCase (驼峰命名法) ，在使用时，依然需要将属性名称用其等价的 kebab-case (短横线分隔命名) 来指明。1234567891011121314151617181920212223242526272829303132&lt;div id=\"app\"&gt; &lt;h4&gt; 请输入需要传递给子组件的值：&lt;input type=\"text\" v-model=\"title\" /&gt; &lt;/h4&gt; &lt;child-node v-bind:parenttitle=\"title\"&gt;&lt;/child-node&gt;&lt;/div&gt;&lt;template id=\"child\"&gt; &lt;div&gt; &lt;h4&gt;Vue 实例中的属性值为：{{content}}&lt;/h4&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { title: '' }, components: { 'childNode': { template: '#child', props: ['parenttitle'], data() { return { content: this.parenttitle } } } }, });&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到，结果似乎和我们想的不一样，虽然可以在绑定的 parenttitle 属性上实时获取到 Vue 实例的属性值，可是，这里却无法同步更新组件的 content 属性。仔细分析下可以我们就不难看出，组件的 data 选项中的 content 属性是一个 String 类型的变量，也就是 js 中的基本数据类型，在创建时就已经将数据值写入到内存栈中，之后与初始赋值的数据就没有任何的关系，因此，后面对于 Vue 实例的 title 属性的任何变更，都不会引起对于实例 content 属性的变化。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，如果我们想完成最开始的需求的话，有两种可行的解决办法：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、将 Vue 实例中的 title 属性改为一个对象，输入的值作为对象中的一个属性，因此，我们在实例中绑定的 parenttitle 也将为一个对象。因为 js 中的对象为引用类型，赋值时，是将存储数据的地址进行拷贝，因此，title 对象和 parenttitle 对象将指向同一地址，这时，任何对于 title 对象的属性值的修改，都会引起 parenttitle 对象中属性值得改变。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、采取 watch 监听 parenttitle 的方式来同步更新实例的 content 属性。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里，我采用第二种方式，使用 watch 监听器来同步变更组件中的 content 属性值，修改代码如下。123456789101112131415161718192021222324&lt;script&gt; var vm = new Vue({ el: '#app', data: { title: '' }, components: { 'childNode': { template: '#child', props: ['parenttitle'], data() { return { content: this.parenttitle } }, watch: { parenttitle() { this.content = this.parenttitle } }, } }, });&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既然可以将 Vue 实例的数据传递到子组件中进行使用，那么，我们是不是可以在子组件进行修改绑定的属性值，从而影响到 Vue 实例呢？我们来继续尝试。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的实例代码的基础上，我们为子组件的 h4 标签添加一个点击事件 change，通过 change 事件，我们来修改绑定的属性值 parenttitle，看看会不会造成对于 Vue 实例中的 title 属性的影响。123456789101112131415161718192021222324252627282930313233343536373839404142&lt;div id=\"app\"&gt; &lt;h4&gt; 请输入需要传递给子组件的值：&lt;input type=\"text\" v-model=\"title\" /&gt; &lt;/h4&gt; &lt;child-node v-bind:parenttitle=\"title\"&gt;&lt;/child-node&gt;&lt;/div&gt;&lt;template id=\"child\"&gt; &lt;div&gt; &lt;h4 @click=\"change\"&gt;Vue 实例中的属性值为：{{content}}&lt;/h4&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { title: '' }, components: { 'childNode': { template: '#child', props: ['parenttitle'], data() { return { content: this.parenttitle } }, watch: { parenttitle() { this.content = this.parenttitle } }, methods: { change() { this.parenttitle = '9999999999999' } } } }, });&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到，我们虽然修改了组件的 parenttitle 属性值，却没有影响到 Vue 实例中的 title 属性，所以我们可以得出，所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本章，主要是介绍了我们如何在组件中使用 data 选项和 props 选项，以及在使用过程中一些与 Vue 实例中使用方式不同的地方，同时，介绍了如何将父组件中的属性值传递到子组件中。既然父组件可以将属性值传递到子组件中，毫无疑问，我们也可以将子组件的属性传递到父组件中，父子组件之间进行属性传递的方式，我将放在下一章中进行介绍。 参考&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、Vue.js——60分钟组件快速入门（上篇）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、认识Vue组件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、Vue 2.0学习笔记：组件的使用&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、初学vue2.0-组件-文档理解笔记v1.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5、Vue组件选项props","link":"/2019/03/09/Vue-Chapter09/"},{"title":"【Vue 牛刀小试】：第八章 - 组件的基础知识","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在之前的学习中，我们对于 Vue 的一些基础语法进行了简单的了解，通过之前的代码可以清晰的看出，我们在使用 Vue 的整个过程，最终都是在对 Vue 实例进行的一系列操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里就会引出一个问题，就像我们刚开始学习 C# 的时候把全部的代码一股脑的写到 Main 方法中，现在我们把所有对于 Vue 实例的操作全部写在一块，这必然会导致 这个方法又长又不好理解。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 C# 的学习过程中，随着不断学习，我们开始将一些相似的业务逻辑进行封装，重用一些代码，从而达到简化的目的。那么，如何在 Vue 中如何实现相似的功能呢？这里就需要提到组件这一概念了，本章，我们就来学习 Vue 中组件的基础知识。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系列目录地址：Vue.js 牛刀小试&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仓储地址：Chapter02-Bronze Component Concept 干货合集&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一、 组件是什么&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;组件是 Vue 中的一个重要概念，它是一种抽象，是一个可以复用的 Vue 实例，它拥有独一无二的组件名称，它可以扩展我们的 HTML 元素，以组件名称的方式作为我们自定义的 HTML 标签。因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，在一个系统的绝大多数的网页中，网页都包含 header、menu、body、footer 等等部分，在很多时候，同一个系统中的多个页面，可能仅仅是页面中 body 部分显示的内容不同，因此，我们就可以将系统中重复出现的页面元素设计成一个个的组件，当我们需要使用到的时候，引用这个组件即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过，与我们在写 C# 时对代码进行模块化的划分不同，模块化主要是为了实现每个模块、方法的职能单一，我们一般是通过代码逻辑的角度进行划分；而 Vue 中的组件化，更多的是为了实现对于前端 UI 组件的重用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Vue 中创建一个新的组件之后，为了能在模板中使用，这些组件必须先进行注册以便 Vue 能够识别。在 Vue 中有两种组件的注册类型：全局注册和局部注册。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;全局注册的组件可以用在其被注册之后的任何 (通过 new Vue) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中使用；而局部注册的组件只能在当前注册的 Vue 实例中进行使用。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、 全局组件的创建方式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Vue 中创建全局组件，通常的做法是先使用 Vue.extend 方法构建模板对象，然后通过 Vue.component 方法来注册我们的组件，因为，组件最后会被解析成自定义的 HTML 代码，因此，我们可以直接在 html 中通过组件名称作为标签使用。123456789101112131415161718&lt;div id=\"app\"&gt; &lt;com&gt;&lt;/com&gt;&lt;/div&gt;&lt;script&gt; //1、使用 Vue.extend 构建模板对象 var comElement = Vue.extend({ template: '&lt;h3&gt;这是使用 Vue.extend 创建的组件，啊啊啊啊啊啊&lt;/h3&gt;' }) //2、使用 Vue.component 注册全局组件 Vue.component('com', comElement) var vm = new Vue({ el: '#app', data: {} });&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从控制台中可以看到，我们自定义的组件已经被解析成了 HTML 元素。这里，需要注意一个问题，当我们采用 Camel 的方式命名我们的组件时，在使用这个组件的时候，需要将大写字母改成小写字母，同时，两个字母之间需要使用 - 进行连接。123456789101112131415161718&lt;div id=\"app\"&gt; &lt;my-com&gt;&lt;/my-com&gt;&lt;/div&gt;&lt;script&gt; //1、使用 Vue.extend 构建模板对象 var comElement = Vue.extend({ template: '&lt;h3&gt;这是使用 Vue.extend 创建的组件，啊啊啊啊啊啊&lt;/h3&gt;' }) //2、使用 Vue.component 注册全局组件 Vue.component('myCom', comElement) var vm = new Vue({ el: '#app', data: {} });&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，我们也可以直接在 Vue.component 中以一种类似 C# 中的匿名对象的方式直接注册全局组件。12345678910111213141516171819&lt;div id=\"app\"&gt; &lt;com2&gt;&lt;/com2&gt; &lt;com3&gt;&lt;/com3&gt;&lt;/div&gt;&lt;script&gt; Vue.component('com2', Vue.extend({ template: '&lt;h3&gt;这是直接使用 Vue.component 创建的组件，啊啊啊啊啊啊&lt;/h3&gt;' })) Vue.component('com3', { template: '&lt;h3&gt;这是直接使用 Vue.component 创建的组件，啊啊啊啊啊啊&lt;/h3&gt;' }) var vm = new Vue({ el: '#app', data: {} });&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的示例中，只是在 template 属性中定义了一个简单的 html 代码，在实际的使用中，template 属性指向的模板内容可能包含很多的元素，而使用 Vue.extend 创建的模板必须有且只有一个根元素，因此，当需要创建具有复杂元素的模板时，你可以在最外层再套一个 div。123456789101112131415161718&lt;div id=\"app\"&gt; &lt;com&gt;&lt;/com&gt;&lt;/div&gt;&lt;script&gt; //1、使用 Vue.extend 构建模板对象 var comElement = Vue.extend({ template: '&lt;h3&gt;这是使用 Vue.extend 创建的组件，啊啊啊啊啊啊&lt;/h3&gt;&lt;h4&gt;呜呜呜呜&lt;/h4&gt;' }) //2、使用 Vue.component 注册全局组件 Vue.component('com', comElement) var vm = new Vue({ el: '#app', data: {} });&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当 template 属性中包含很多的元素时，不能使用代码提示还是会显得比较不方便，这时，我们可以使用 template 标签来定义我们的模板，通过 id 来确定组件的模板信息。12345678910111213141516171819202122&lt;div id=\"app\"&gt; &lt;com&gt;&lt;/com&gt;&lt;/div&gt;&lt;template id=\"tmpl\"&gt; &lt;div&gt; &lt;h3&gt;这是使用 Vue.extend 创建的组件，啊啊啊啊啊啊&lt;/h3&gt; &lt;h4&gt;呜呜呜呜&lt;/h4&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; Vue.component('com', { template: '#tmpl' }) var vm = new Vue({ el: '#app', data: {} });&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三、 局部组件的创建方式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;某些时候，我们注册的组件只想在一个 Vue 实例中使用，如果还是使用全局注册的方式注册组件就显得不太合适了，这时，我们就可以使用局部注册的方式注册组件。在 Vue 实例中，我们可以通过 components 属性注册仅在当前作用域下可用的组件。12345678910111213141516171819202122232425262728&lt;div id=\"app\"&gt; &lt;simple-com&gt;&lt;/simple-com&gt;&lt;/div&gt;&lt;div id=\"app2\"&gt; &lt;simple-com&gt;&lt;/simple-com&gt;&lt;/div&gt;&lt;template id=\"local\"&gt; &lt;h4&gt;我是局部注册的组件啊啊啊啊啊啊啊啊&lt;/h4&gt;&lt;/template&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: {} }); var vm2 = new Vue({ el: '#app2', data: {}, components: { 'simple-com': { template: '#local' } } });&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到，在上面的例子中，局部注册的组件只能在注册的 vm2 实例中完成解析，当我们在 vm 实例中引用这个组件时，是无法正确解析这个自定义的组件元素的。 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本章中，主要介绍了组件是什么，以及如何通过全局/局部的方式注册我们的组件。在我们使用组件的过程中，很大的可能会接触到两个组件之间的数据交互，以及如何为我们的组件设定事件，在下一章中，我们将进一步的学习 Vue 中的组件相关知识点。 参考&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、Vue.js——60分钟组件快速入门（上篇）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、认识Vue组件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、Vue 2.0学习笔记：组件的使用&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、初学vue2.0-组件-文档理解笔记v1.0","link":"/2019/01/03/Vue-Chapter08/"},{"title":"【Vue 牛刀小试】：第十章 - 组件间的数据通信","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上一章的学习中，我们继续学习了 Vue 中组件的相关知识，了解了在 Vue 中如何使用组件的 data、prop 选项。在之前的学习中有提到过，组件是 Vue 中的一个非常重要的概念，我们通过将页面拆分成一个个独立的组件，从而更好地实现代码复用，使我们的代码更加简洁，容易维护。既然在 Vue 中我们会大量的使用到组件，必定会涉及到组件之间的通信，那么本章我们就来学习，如何实现组件间的数据交互。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系列目录地址：Vue.js 牛刀小试&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仓储地址：Chapter02-Bronze Component’s Communication 干货合集&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一、 父组件 =&gt; 子组件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上一章的时候，我们有提到过，我们可以使用 prop 选项在组件中定义一些自定义特性，当有值传递给 prop 特性时，那个 prop 特性就变成了那个组件实例的一个属性，此时我们就可以从组件上获取到接收的值。因此，这里我们就可以在使用子组件时通过 v-bind 指令动态的绑定一个 prop 特性，从而接收到父组件传递的值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到，在下面的示例代码中，我们在子组件中通过 v-bind 指令绑定了一个 prop 特性 parenttitle，用来接收父组件 data 选项中的 title 属性，之后通过 watch 监听属性监听绑定的 parenttitle 属性，从而同步更新子组件 data 选项中的 content 属性值。1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;body&gt; &lt;div id=\"app\"&gt; &lt;h4&gt; 请输入需要传递给子组件的值：&lt;input type=\"text\" v-model=\"title\" /&gt; &lt;/h4&gt; &lt;hr /&gt; &lt;child-node v-bind:parenttitle=\"title\"&gt;&lt;/child-node&gt; &lt;/div&gt;&lt;/body&gt;&lt;template id=\"child\"&gt; &lt;div&gt; &lt;h4&gt; Vue 实例中的属性值为：{{content}} &lt;/h4&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { title: '' }, components: { 'childNode': { template: '#child', props: ['parenttitle'], data() { return { content: this.parenttitle } }, watch: { parenttitle() { this.content = this.parenttitle } }, } } })&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、 子组件 =&gt; 父组件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Vue 中存在着一个单向的下行绑定，父级组件的数据变更可以影响到子集组件，反过来则不行。在实际开发中可能会遇到当子组件的数据更新后，需要同步更新父组件的情况，那么这时我们应该怎么做呢？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既然没办法直接通过修改 prop 选项中的属性进行更新父组件，不如让我们换一个思路思考。我们想要实现的效果，无非是当子组件数据变更时能够同步引起父组件的变更，那么，我们是不是可以在子组件数据发生变化后，触发一个事件方法，告诉父组件我数据更新了，父组件只需要监听这个事件，当捕获到这个事件运行后，再对父组件的数据进行同步变更不就可以了，整个的示意流程如下。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么，如何才能实现事件监听呢？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;嗯，Vue 已经帮我们实现好了解决方案。我们可以使用 v-on 事件监听器监听事件，通过 $emit 去触发当前实例上的事件。当然，这里的事件可以是 Javascript 中的原生 DOM 事件，也可以是我们自定义的事件。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，在下面的代码中，当我点击传递数据按钮后，触发了子组件的 func 方法，在 func 方法中触发了子组件实例上的 show 事件，并把 input 框中的值作为参数进行传递。这时，我们在使用到子组件的地方就可以通过 v-on(@) 指令监听这个 show 事件，从而获取到传递的参数，并触发父组件的监听事件。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;body&gt; &lt;div id=\"app\"&gt; &lt;h4&gt; 子组件中的属性值为：{{msg}} &lt;/h4&gt; &lt;hr /&gt; &lt;child-node @show=\"showMsg\"&gt;&lt;/child-node&gt; &lt;/div&gt;&lt;/body&gt;&lt;template id=\"child\"&gt; &lt;div&gt; &lt;h4&gt; 请输入需要传递给父组件的值：&lt;input v-model=\"childMsg\" type=\"text\" /&gt; &lt;button @click=\"func\"&gt;传递数据&lt;/button&gt; &lt;/h4&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { title: '', msg: '', }, methods: { showMsg(data) { this.msg = data } }, components: { 'childNode': { template: '#child', data() { return { childMsg: '' } } methods: { func() { this.$emit('show', this.childMsg) } }, } } })&lt;/script&gt; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一章主要介绍了组件之间进行数据通信的两种最常用的方式，对于子组件获取父组件数据，一般是采用组件的 prop 选项向子组件传递数据；而父组件获取子组件数据，则是采用事件监听的方式。在实际使用中，组件的通信方式还有 .sync、$attrs、$listeners、slot-scope 等等，这里就先不介绍了，嗯，其实就是我还不会，哈哈，先学习掌握这两种最常见的方式，其它的方式就先放到后面再学习吧。 参考&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、Vue的事件解读&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、Vue事件解读之$emit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、Vue.js 父子组件通信的1212种方式","link":"/2019/03/31/Vue-Chapter10/"},{"title":"【Vue 牛刀小试】：第十三章 - Vue Router 基础使用再探（命名路由、命名视图、路由传参）","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上一章的学习中，我们简单介绍了前端路由的概念，以及如何在 Vue 中通过使用 Vue Router 来实现我们的前端路由。但是在实际使用中，我们经常会遇到路由传参、或者一个页面是由多个组件组成的情况。本章，我们就来介绍下在这两种情况下 Vue Router 的使用方法以及一些可能涉及到的概念。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系列目录地址：Vue.js 牛刀小试&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仓储地址：Chapter02-Bronze Routing Pass in Vue.js 干货合集&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一、 命名路由 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在某些时候，我们期望生成的路由 URL 地址可能会很长，在使用中可能会显得有些不便。这时候通过一个名称来标识一个路会更方便一些，因此在 Vue Router 中，我们可以在创建 Router 实例的时候，通过在 routes 配置中给某个路由设置名称，从而方便的调用路由。123456789const router = new VueRouter({ routes: [ { path: '/form', name: 'form', component: '&lt;div&gt;form 组件&lt;/div&gt;' } ]}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们使用命名路由之后，当需要使用 router-link 标签进行跳转时，就可以采取给 router-link 的 to 属性传一个对象的方式，跳转到指定的路由地址上。1&lt;router-link :to=\"{ name: 'form'}\"&gt;User&lt;/router-link&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、 命名视图 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们打开一个页面时，整个页面可能是由多个 Vue 组件所构成的，例如，我们的后台管理首页可能是由 sidebar (侧导航) 、header（顶部导航）和 main (主内容）这三个 Vue 组件构成的。此时，当我们通过 Vue Router 构建路由信息时，如果一个 URL 只能对应一个 Vue 组件，整个页面肯定是无法正确显示的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上一章的学习中，我们在构建路由信息的时候有使用到两个特殊的标签：router-view 和 router-link。通过 router-view 标签，我们就可以指定组件渲染显示到什么位置。因此，当我们需要在一个页面上显示多个组件的时候，就需要在页面中添加多个的 router-view 标签。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么，是不是可以通过一个路由对应多个组件，然后按需渲染在不同的 router-view 标签上呢？按照上一章中介绍的关于 Vue Router 的使用方法，我们可以很容易的实现下面的代码。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;div id=\"app\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class=\"container\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt;&lt;template id=\"sidebar\"&gt; &lt;div class=\"sidebar\"&gt; sidebar &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 1、定义路由跳转的组件模板 const header = { template: '&lt;div class=\"header\"&gt; header &lt;/div&gt;' } const sidebar = { template: '#sidebar', } const main = { template: '&lt;div class=\"main\"&gt; main &lt;/div&gt;' } // 2、定义路由信息 const routes = [{ path: '/', component: header }, { path: '/', component: sidebar }, { path: '/', component: main }] const router = new VueRouter({ routes }) // 3、挂载到当前 Vue 实例上 const vm = new Vue({ el: '#app', data: {}, methods: {}, router: router });&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到，并没有实现我们想要实现的效果，当我们将一个路由信息对应到多个组件时，不管有多少个的 router-view 标签，程序都会将第一个组件渲染到所有的 router-view 标签上。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，在这种情况下，我们需要实现的是一个路由信息可以按照我们的需要去渲染到页面中指定的 router-view 标签上，而在 Vue Router 中，我们则可以通过命名视图的方式实现我们的需求。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命名视图，从名称上看可能无法阐述的很清楚，与命名路由的实现方式相似，命名视图通过在 router-view 标签上设定 name 属性，之后，在构建路由与组件的对应关系时，以一种 name:component 的形式构造出一个组件对象，从而指明是在哪个 router-view 标签上加载什么组件。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意，这里在指定路由对应的组件时，使用的是 components（包含 s）属性进行配置组件。实现命名视图的代码如下所示。12345678910111213141516171819&lt;div id=\"app\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class=\"container\"&gt; &lt;router-view name=\"sidebar\"&gt;&lt;/router-view&gt; &lt;router-view name=\"main\"&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; // 2、定义路由信息 const routes = [{ path: '/', components: { default: header, sidebar: sidebar, main: main } }]&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 router-view 中，默认的 name 属性值为 default，所以这里的 header 组件对应的 router-view 标签就可以不设定 name 属性值。完整的示例代码如下。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;div id=\"app\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class=\"container\"&gt; &lt;router-view name=\"sidebar\"&gt;&lt;/router-view&gt; &lt;router-view name=\"main\"&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt;&lt;template id=\"sidebar\"&gt; &lt;div class=\"sidebar\"&gt; sidebar &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 1、定义路由跳转的组件模板 const header = { template: '&lt;div class=\"header\"&gt; header &lt;/div&gt;' } const sidebar = { template: '#sidebar' } const main = { template: '&lt;div class=\"main\"&gt; main &lt;/div&gt;' } // 2、定义路由信息 const routes = [{ path: '/', components: { default: header, sidebar: sidebar, main: main } }] const router = new VueRouter({ routes }) // 3、挂载到当前 Vue 实例上 const vm = new Vue({ el: '#app', data: {}, methods: {}, router: router });&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三、 路由传参&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在很多的情况下，例如表单提交，组件跳转之类的操作，我们需要使用到上一个表单、组件的一些数据，这时我们就需要将需要的参数通过参数传参的方式在路由间进行传递。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，在下面的示例中，我们想要实现通过点击 main 组件中的子组件 form 组件上的按钮，将表单的内容传递到 info 子组件中进行显示，功能示意图如下所示。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、 query 传参&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;query 查询参数传参，就是将我们需要的参数以 key=value 的方式放在 url 地址中。例如这里的需求，我们需要在 info 组件中显示上一个页面的数据，所以我们的 info 页面显示的 URL 地址应该为 /info?email=xxx&amp;password=xxx，这里的 email 和 password 参数值则是 form 组件上用户输入的值。之后，我们通过获取这两个参数值即可实现我们的需求。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们将实例化的 VueRouter 对象挂载到 Vue 实例后，Vue Router 在我们的 Vue 实例上创建了两个属性对象 this.$router(router 实例) 和 this.$route(当前页面的路由信息)。从下图可以看到，我们可以通过 vm.$route 获取到当前页面的路由信息，而这里的 query 对象则是我们需要的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到，这时我们就可以直接通过 $route.query.参数名 的方式获取到对应的参数值。同时可以发现，fullPath 属性可以获取到当前页面的地址和 query 查询参数，而 path 属性则只是获取到当前的路由信息。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同时，因为在使用 Vue Router 时已经将 VueRouter 实例挂载到 Vue 实例上，因此就可以直接通过调用 $router.push 方法来导航到另一个页面，所以这里 form 组件中的按钮事件，我们就可以使用这种方式完成路由地址的跳转，完整的代码如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145&lt;div id=\"app\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-sm-2 sidebar\"&gt; &lt;router-view name=\"sidebar\"&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;div class=\"col-sm-10 main\"&gt; &lt;router-view name=\"main\"&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;template id=\"sidebar\"&gt; &lt;div&gt; &lt;ul&gt; &lt;router-link v-for=\"(item,index) in menu\" :key=\"index\" :to=\"item.url\" tag=\"li\"&gt;{{item.name}} &lt;/router-link&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id=\"main\"&gt; &lt;div&gt; &lt;router-view&gt; &lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id=\"form\"&gt; &lt;div&gt; &lt;form&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputEmail1\"&gt;Email address&lt;/label&gt; &lt;input type=\"email\" class=\"form-control\" id=\"exampleInputEmail1\" aria-describedby=\"emailHelp\" placeholder=\"Enter email\" v-model=\"email\"&gt; &lt;small id=\"emailHelp\" class=\"form-text text-muted\"&gt;We'll never share your email with anyone else.&lt;/small&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputPassword1\"&gt;Password&lt;/label&gt; &lt;input type=\"password\" class=\"form-control\" id=\"exampleInputPassword1\" placeholder=\"Password\" v-model=\"password\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\" @click=\"submit\"&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id=\"info\"&gt; &lt;div class=\"card\" style=\"margin-top: 5px;\"&gt; &lt;div class=\"card-header\"&gt; 输入的信息 &lt;/div&gt; &lt;div class=\"card-body\"&gt; &lt;blockquote class=\"blockquote mb-0\"&gt; &lt;p&gt;Email Address：{{ $route.query.email }} &lt;/p&gt; &lt;p&gt;Password：{{ $route.query.password }}&lt;/p&gt; &lt;footer class=\"blockquote-footer\"&gt;Someone famous in &lt;cite title=\"Source Title\"&gt;Source Title&lt;/cite&gt; &lt;/footer&gt; &lt;/blockquote&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 1、定义路由跳转的组件模板 const header = { template: '&lt;div class=\"header\"&gt; header &lt;/div&gt;' } const sidebar = { template: '#sidebar', data() { return { menu: [{ name: 'Form', url: '/form' }, { name: 'Info', url: '/info' }] } }, } const main = { template: '#main' } const form = { template: '#form', data() { return { email: '', password: '' } }, methods: { submit() { this.$router.push({ path: '/info?email=' + this.email + '&amp;password=' + this.password }) } }, } const info = { template: '#info' } // 2、定义路由信息 const routes = [{ path: '/', components: { default: header, sidebar: sidebar, main: main }, children: [{ path: '', redirect: 'form' }, { path: 'form', component: form }, { path: 'info', component: info }] }] const router = new VueRouter({ routes }) // 3、挂载到当前 Vue 实例上 const vm = new Vue({ el: '#app', data: {}, methods: {}, router: router });&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、 param 传参&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与获取 query 参数的方式相同，我们同样可以通过 vm.$route 获取到当前路由信息，从而在 param 对象中通过 $route.params.参数名 的方式获取到通过 param 的方式进行参数传递的值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过，与 query 查询参数传参不同的是，在定义路由信息时，我们需要以占位符（:参数名）的方式将需要传递的参数指定到路由地址中，实现代码如下。1234567891011121314151617181920const routes = [{ path: '/', components: { default: header, sidebar: sidebar, main: main }, children: [{ path: '', redirect: 'form' }, { path: 'form', name: 'form', component: form }, { path: 'info/:email/:password', name: 'info', component: info }]}] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为在使用 $route.push 进行路由跳转时，如果提供了 path 属性，则对象中的 params 属性会被忽略，所以这里我们可以采用命名路由的方式进行跳转或者直接将参数值传递到路由 path 路径中。同时，与使用 query 查询参数传递参数不同，这里的参数如果不进行赋值的话，就无法与我们的匹配规则对应，也就无法跳转到指定的路由地址中。1234567891011121314151617181920212223242526const form = { template: '#form', data() { return { email: '', password: '' } }, methods: { submit() { // 方式1 this.$router.push({ name: 'info', params: { email: this.email, password: this.password } }) // 方式2 this.$router.push({ path: `/info/${this.email}/${this.password}`, }) } },} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其余的部分与使用 query 查询参数传参的方式相同，这里我就直接给出实现代码了，实现的示意图如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158&lt;div id=\"app\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-sm-2 sidebar\"&gt; &lt;router-view name=\"sidebar\"&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;div class=\"col-sm-10 main\"&gt; &lt;router-view name=\"main\"&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;template id=\"sidebar\"&gt; &lt;div&gt; &lt;ul&gt; &lt;router-link v-for=\"(item,index) in menu\" :key=\"index\" :to=\"{name:item.routeName}\" tag=\"li\"&gt; {{item.displayName}} &lt;/router-link&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id=\"main\"&gt; &lt;div&gt; &lt;router-view&gt; &lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id=\"form\"&gt; &lt;div&gt; &lt;form&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputEmail1\"&gt;Email address&lt;/label&gt; &lt;input type=\"email\" class=\"form-control\" id=\"exampleInputEmail1\" aria-describedby=\"emailHelp\" placeholder=\"Enter email\" v-model=\"email\"&gt; &lt;small id=\"emailHelp\" class=\"form-text text-muted\"&gt;We'll never share your email with anyone else.&lt;/small&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputPassword1\"&gt;Password&lt;/label&gt; &lt;input type=\"password\" class=\"form-control\" id=\"exampleInputPassword1\" placeholder=\"Password\" v-model=\"password\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\" @click=\"submit\"&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id=\"info\"&gt; &lt;div class=\"card\" style=\"margin-top: 5px;\"&gt; &lt;div class=\"card-header\"&gt; 输入的信息 &lt;/div&gt; &lt;div class=\"card-body\"&gt; &lt;blockquote class=\"blockquote mb-0\"&gt; &lt;p&gt;Email Address：{{ $route.params.email }} &lt;/p&gt; &lt;p&gt;Password：{{ $route.params.password }}&lt;/p&gt; &lt;footer class=\"blockquote-footer\"&gt;Someone famous in &lt;cite title=\"Source Title\"&gt;Source Title&lt;/cite&gt; &lt;/footer&gt; &lt;/blockquote&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 1、定义路由跳转的组件模板 const header = { template: '&lt;div class=\"header\"&gt; header &lt;/div&gt;' } const sidebar = { template: '#sidebar', data() { return { menu: [{ displayName: 'Form', routeName: 'form' }, { displayName: 'Info', routeName: 'info' }] } }, } const main = { template: '#main' } const form = { template: '#form', data() { return { email: '', password: '' } }, methods: { submit() { // 方式1 this.$router.push({ name: 'info', params: { email: this.email, password: this.password } }) // 方式2 // this.$router.push({ // path: `/info/${this.email}/${this.password}`, // }) } }, } const info = { template: '#info' } // 2、定义路由信息 const routes = [{ path: '/', components: { default: header, sidebar: sidebar, main: main }, children: [{ path: '', redirect: 'form' }, { path: 'form', name: 'form', component: form }, { path: 'info/:email/:password', name: 'info', component: info }] }] const router = new VueRouter({ routes }) // 3、挂载到当前 Vue 实例上 const vm = new Vue({ el: '#app', data: {}, methods: {}, router: router });&lt;/script&gt; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一章主要是介绍了命名路由，以及如何通过使用命名视图在 Vue Router 中将多个组件对应到同一个路由。同时，针对实际使用中我们经常会遇到的路由传参，我们则可以通过 query 或者是 param 的方式进行参数传递。不过，不知道你有没有注意到，不管是 query 传参还是 param 传参，最终我们都是通过 vm.$route 属性获取到参数信息，这无疑意味着组件和路由耦合到了一块，所有需要获取参数值的地方都需要加载 Vue Router，这其实是很不应该的，因此如何实现组件与路由间的解耦，我将在下一章中进行说明。 参考&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、从头开始学习vue-router&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、单页面应用路由的两种实现方式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、你需要知道的单页面路由实现原理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、面试官: 你了解前端路由吗?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5、前端路由实现原理（history）","link":"/2019/06/16/Vue-Chapter13/"},{"title":"【Vue 牛刀小试】：第十一章 - Vue 中 ref 的使用","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在之前的前端开发中，为了实现我们的需求，通常采用的方案是通过 JS/Jquery 直接操纵页面的 DOM 元素，得益于 Jquery 对于 DOM 元素优异的操作能力，我们可以很轻易的对获取到的 DOM 元素进行操作。但是，当我们开始在前端项目中使用 Vue 这类的 MVVM 框架之后，对于 DOM 的操作我们就应当完全的交给框架，而我们只需要关注于数据。难道，在 Vue 中就不能手动获取到页面上的 DOM 元素了吗，答案当然是可以手动获取到 DOM 元素的，在 Vue 中我们可以通过使用 ref 实现获取 DOM 元素的功能，当然，这也只是 ref 其中一项的功能。本章，我们就来学习 Vue 中 ref 的相关使用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系列目录地址：Vue.js 牛刀小试&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仓储地址：Chapter02-Bronze Get Elements 干货合集&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ref 在 Vue 中是用来给元素或是子组件注册引用信息到父组件或是 Vue 实例上，注册后的引用信息都会呈现在父组件/Vue 实例的 $.refs 上，这时，我们就可以通过 $.refs 获取到引用的 DOM 对象或是子组件信息。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，我们可以获取到页面上添加了 ref 的 input 输入框的值，对于子组件来说，我们可以直接获取到子组件 data 选项中的数据，或是直接调用子组件的方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一、 虚拟 DOM &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们使用 JS/Jquery 直接对 DOM 元素进行操作时，不管是对元素样式的修改（背景颜色从红色变成蓝色）还是对页面中的某些布局进行动态调整（通过点击按钮在列表中添加一行新的数据），这都会造成页面的重新渲染，从而影响我们网站的性能。而在 Vue 中，通过在内存中生成与真实 DOM 与之对应的数据结构（虚拟 DOM），当页面发生变化时，通过新的虚拟 DOM 树与旧的虚拟 DOM 树进行比对，就能很快的找出差异点，从而得出应施加到真实 DOM 上的改动。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、 使用 ref 获取页面 DOM 元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用 JS/Jquery 获取页面的 DOM 元素时，我们一般是根据 id、class、标签、属性等其它标识来获取到页面上的 DOM 元素。嗯，可以说，我们很难抛弃 Jquery 的一个重大原因，就是当我们需要获取到页面上的 DOM 元素时，使用 Jquery 的 API 相比于原生的 JS 代码，简单到极致，有木有。1document.getElementById('id').value =&gt; $('#id').val() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么，难道我们在 Vue 中获取 DOM 元素还是采用这样的方式？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案当然是否定的，这种直接操纵 DOM 元素的方式，与我们使用 Vue 的初衷不符，虽然能达成效果，但是却不提倡，这里我们就可以使用 ref 来获取页面上的 DOM 元素。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在下面的代码中，我在 input 上添加了一个 ref 属性，之后，我们就可以在 Vue 实例中获取到这个 input 输入框的值。这里，我在 beforeMount、mounted 这两个 Vue 中的生命周期钩子函数以及一个按钮的点击事件中尝试获取到这个 input 输入框的值。123456789101112131415161718192021222324&lt;div id=\"app\"&gt; &lt;input type=\"text\" ref=\"msgText\" v-model=\"msg\" /&gt; &lt;button @click=\"getElement\"&gt;获取元素值&lt;/button&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue({ el: \"#app\", data: { msg: 'Hello ref' }, beforeMount() { console.log('beforeMount: ' + this.$refs.msgText.value) }, mounted() { console.log('mounted: ' + this.$refs.msgText.value) }, methods: { getElement() { console.log(this.$refs.msgText.value) } } });&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行代码，从结果中可以看到，在 beforeMount 这个钩子函数中，我们是无法获取到这个 DOM 元素的值，结合之前学习的 Vue 生命周期的相关知识，当执行到 beforeMount 钩子函数时，Vue 虽然已经将模板编译完成，但是尚未挂载到页面 DOM 元素上，因此我们可以得出 ref 是在页面渲染完成后才被创建的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到，当我们在 input 输入框中添加了 ref 属性后，在当前的 Vue 实例的 $.refs 上就挂载了当前的 input 框对象。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三、 使用 ref 获取子组件对象&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同使用 ref 获取页面的 DOM 元素相似，当我们需要获取子组件时，只需要将使用到子组件上的地方添加 ref 属性即可。在下面的示例代码中，我添加了一个子组件，当我们点击 Vue 实例上的按钮时，会先调用子组件的方法，然后获取子组件的数据。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;div id=\"app\"&gt; &lt;input type=\"text\" ref=\"msgText\" v-model=\"msg\" /&gt; &lt;button @click=\"getElement\"&gt;获取元素值&lt;/button&gt; &lt;hr&gt; &lt;child ref=\"childComponent\"&gt;&lt;/child&gt;&lt;/div&gt;&lt;template id=\"child\"&gt; &lt;div&gt; &lt;input type=\"datetime\" name=\"datetime\" v-model=\"local\"&gt; &lt;button @click=\"getLocalData\"&gt;获取当前时间&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var vm = new Vue({ el: \"#app\", data: { msg: 'Hello ref' }, mounted() { console.log('mounted: ' + this.$refs.msgText.value) }, methods: { getElement() { console.log('input 输入框的值为：' + this.$refs.msgText.value) this.$refs.childComponent.getLocalData() console.log('子组件 input 输入框的值为：' + this.$refs.childComponent.local) } }, components: { 'child': { template: '#child', data() { return { local: '' } }, methods: { getLocalData() { var date = new Date() this.local = date.toLocaleString() } }, } } });&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到，当我们将 ref 添加到子组件上，我们就可以在 Vue 实例上获取到这个注册的组件引用，同注册的 DOM 元素一样，我们都可以使用添加的 ref 属性值作为 key 获取到注册的对象。此时，我们就可以获取到这个子组件上的 data 选项和 methods 选项。 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为 Vue 采用 Virtual DOM 的做法渲染网页，如果我们直接操作 DOM，很容易产生实际网页跟 Vue 产生的 Virtual DOM 不同步的问题，而通过使用 ref 属性之后，在一些需要获取 DOM 元素的情况下，我们就可以很方便的获取 DOM 元素。当然，当我们决定在项目中使用 Vue，还是需要转变我们的思路，将操作 DOM 转变成操作数据。同样的，通过将 ref 属性添加到子组件上，我们就可以很轻松的获取到子组件的相关信息，这无疑给父组件获取子组件数据、调用子组件的方法提供了一种新的思路。 参考&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、网页性能管理详解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、重排重绘，看这一篇就够了&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、Vue作者尤雨溪：Vue 2.0，渐进式前端解决方案&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、vue中的 ref 和 $refs","link":"/2019/04/28/Vue-Chapter11/"},{"title":"【Vue 牛刀小试】：第十二章 - 使用 Vue Router 实现 Vue 中的前端路由控制","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前端路由是什么？如果你之前从事的是后端的工作，或者虽然有接触前端，但是并没有使用到单页面应用的话，这个概念对你来说还是会很陌生的。那么，为什么会在单页面应用中存在这么一个概念，以及，前端路由与我们后端的路由有什么异同呢。本章，我们就来简单介绍下前端路由的概念，以及如何在 Vue 中使用 Vue Router 来实现我们的前端路由。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系列目录地址：Vue.js 牛刀小试&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仓储地址：Chapter02-Bronze Build Router in Vue.js 干货合集&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在传统的多页面应用中，网站的每一个 URL 地址都是对应于服务器磁盘上的一个实际物理文件。例如，当我们访问 https://www.yousite.com/index.html 这个网址的时候，服务器会自动把我们的请求对应到当前站点路径下面的 index.html 文件，然后再给予响应，将这个文件返回给浏览器。当我们跳转到别的页面上时，毫无疑问则会再重复一遍上面的过程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是在单页面应用中，整个项目中只会存在一个 html 文件，当用户切换页面时，只是通过对这个唯一的 html 文件进行动态重写，从而达到响应用户的请求。也就是说，从切换页面这个角度上说，应用只是在第一次打开时请求了服务器（非服务端渲染的单页应用）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为访问的页面是并不真实存在的，所以如何正确的在一个 html 文件中展现出用户想要访问的信息就成为单页面应用需要考虑的问题，而对于这一路由问题的解决方案，为了与我们后端传统意义上的路由进行区别，就将此称为前端路由。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一、 前端路由的实现方式 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前的前端路由的实现方式主要是通过 hash 路由匹配或者是采用 html5 中的 history api 这两种，也就是说，不管是 hash 路由还是使用 history 路由模式，其实都是基于浏览器自身的特性。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hash 路由：hash 这个概念，可能听起来有些陌生，不过，其实我们在之前的前端开发中，其实是有所接触的。例如，在某些情况下，我们需要定位页面上的某些位置，就像下面的例子中展现的那样，我想要通过点击不同的按钮就跳转到指定的位置，这里我们使用的锚点定位其实就是 hash。12345678&lt;div id=\"content\"&gt; &lt;div class=\"btn-container\"&gt; &lt;a class=\"btn\" href=\"#image1\"&gt;图片1&lt;/a&gt; &lt;a class=\"btn\" href=\"#image2\"&gt;图片2&lt;/a&gt; &lt;/div&gt; &lt;img src=\"./xxx/xxx.jpg\" id=\"image1\"&gt; &lt;img src=\"./xxx/xxx.jpg\" id=\"image2\"&gt;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hash 路由的本质是浏览器 location 对象中的 hash 属性，它会记录链接地址中 ‘#’ 后面的内容（e.g.：#part1）。因此，我们可以通过监听 window.onhashchange 事件获取到跳转前后访问的地址，从而实现地址切换的目的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;history 路由：在之前的 html 版本中，我们可以通过 history.back(), history.forward()和 history.go() 方法来完成在用户历史记录中向后和向前的跳转。而 history 路由则是使用了 html5 中新增的 pushState 事件和 replaceState() 事件。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过这两个新增的 API，就可以实现无刷新的更改地址栏链接，配合 AJAX 就可以做到整个页面的无刷新跳转，具体实现的原理大家可以看看这篇文章 =》HTML5 简介（三）：利用 History API 无刷新更改地址栏&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Vue 中，Vue Router 是官方提供的路由管理器。它和 Vue.js 的核心深度集成，因此，不管是采用 hash 的方式还是使用 history api 实现我们的前端路由都有很好的支持，所以这里我们采用 Vue Router 这一组件来实现我们的前端路由。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、 路由实现&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们需要将 Vue Router 添加引用到我们的项目中，这里我还是采用直接引用 js 文件的方式为我们的示例代码添加前端路由支持。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Vue 中使用 Vue Router 构建单页面应用，我们只需要将组件 (components) 映射到定义的路由 (routes) 规则中，然后告诉 Vue Router 在哪里渲染它们，并将这个路由配置挂载到 Vue 实例节点上即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Vue Router 中，我们使用 router-link 标签来渲染链接，当然，默认生成的是 a 标签，如果你想要将路由信息生成别的 html 标签，则可以使用 tag 属性指明需要生成的标签类型。12345&lt;!-- 默认渲染成 a 标签 --&gt;&lt;router-link to=\"/home\"&gt;主页&lt;/router-link&gt;&lt;!-- 渲染成 button 标签 --&gt;&lt;router-link to=\"/home\" tag=\"button\"&gt;主页&lt;/router-link&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到，当我们指定 tag 属性为 button 后，页面渲染后的的标签就变成了 button 按钮。同样的，它还是会监听点击，触发导航。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同时，从上图可以看出，当前的链接地址为 #/home，也就是说，通过 router-link 生成的标签，当页面地址与对应的路由规则匹配成功后，将自动设置 class 属性值为 .router-link-active。当然，我们也可以通过指定 active-class 属性或者在构造 VueRouter 对象时使用 linkActiveClass 来自定义链接激活时使用的 CSS 类名。12345678&lt;!-- 使用属性来设定自定义激活类名 --&gt;&lt;router-link to=\"/home\" active-class=\"aaaa\"&gt;主页&lt;/router-link&gt;&lt;!-- 在构造对象时设定全局默认类名 --&gt;const router = new VueRouter({ routes: [], linkActiveClass: 'aaaaa'}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当路由表构建完成后，对于指向路由表中的链接，需要在页面上找一个地方去显示已经渲染完成后的组件，这时，我们就需要使用 router-view 标签去告诉程序，我们需要将渲染后的组件显示在当前位置。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在下面的示例代码中，模拟了 Vue 中路由的使用，当访问 #/home 时会进行加载 home 组件，而当链接跳转到 #/account 时则会加载 account 组件。同时，我们可以发现，在 account 组件中又包含了两个子路由，通过点击 account 组件中的子路由地址，从而加载对应的 login 组件和 register 组件。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;script src=\"../../lib/vue.js\"&gt;&lt;/script&gt;&lt;script src=\"../../lib/vue-router.js\"&gt;&lt;/script&gt;&lt;style&gt; .container { background-color: aquamarine; margin-top: 20px; width: 740px; height: 300px; }&lt;/style&gt;&lt;div id=\"app\"&gt; &lt;!-- 通过 router-link 标签来生成导航链接 --&gt; &lt;router-link to=\"/home\"&gt;主页&lt;/router-link&gt; &lt;router-link to=\"/account\"&gt;账户&lt;/router-link&gt; &lt;div class=\"container\"&gt; &lt;!-- 将选中的路由渲染到 router-view 下--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt;&lt;template id=\"tmpl\"&gt; &lt;div&gt; &lt;h3&gt; account page &lt;/h3&gt; &lt;!-- 生成嵌套子路由地址 --&gt; &lt;router-link to=\"/account/login\"&gt;登录&lt;/router-link&gt; &lt;router-link to=\"/account/register\"&gt;注册&lt;/router-link&gt; &lt;!-- 生成嵌套子路由渲染节点 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 1、定义路由跳转的组件模板 const home = { template: '&lt;div&gt; home page &lt;/div&gt;' } const account = { template: '#tmpl' } const login = { template: '&lt;div&gt; login page&lt;/div&gt;' } const register = { template: '&lt;div&gt; register page&lt;/div&gt;' } // 2、定义路由信息 const routes = [{ path: '/', redirect: '/home' }, { path: '/home', component: home }, { path: '/account', component: account, children: [{ path: 'login', component: login }, { path: 'register', component: register } ] } ] const router = new VueRouter({ //mode: 'history', //使用 history 模式还是 hash 路由模式 routes }) // 3、挂载到当前 Vue 实例上 const vm = new Vue({ el: '#app', data: {}, methods: {}, router: router });&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的代码中，也使用到了嵌套路由和路由的重定向。通过使用路由重定向，我们可以将用户访问网站的根目录 / 时进行重定向到 /home ，而嵌套路由则可以将 URL 中各段动态路径也按某种结构对应到实际嵌套的各层组件。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，这里的 login 组件和 register 组件，它们都是位于 account 组件中的，因此，在构建 url 时，我们应该将该地址位于 /account url 后面，从而更好地表达这种关系。所以这里，我们在 account 组件中又添加了一个 router-view 标签，用来渲染出嵌套的组件内容。同时，通过在定义 routes 时在参数中使用 children 属性，从而达到配置嵌套路由信息的目的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PS：以 / 开头的嵌套路径会被当作根路径，而我们的 login 组件和 register 组件都是包含在 account 中，所以这里直接定义 path 参数即可。 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一章主要是介绍了如何使用 Vue Router 在 Vue 中构建我们的前端路由。在实际开发中，对于一个路径，可能会对应到多个组件，这时，如何将多个组件绑定到一个路径下，就是我们需要解决的问题。另外，在实际使用中我们会遇到路由传参，可能会因为 hash 路由不漂亮，从而准备采用 history 路由，对于这些需求的实现，将放在下一章中进行学习。 参考&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、从头开始学习vue-router&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、单页面应用路由的两种实现方式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、你需要知道的单页面路由实现原理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、面试官: 你了解前端路由吗?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5、前端路由实现原理（history）","link":"/2019/05/21/Vue-Chapter12/"},{"title":"【Vue 牛刀小试】：第十四章 - 编程式导航与实现组件与 Vue Router 之间的解耦","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上一章的学习中，通过举例说明，我们了解了 Vue Router 中命名路由、命名视图的使用方法，以及如何通过 query 查询参数传参，或者是采用 param 传参的方式实现路由间的参数传递。通过学习我们可以发现，在实现路由间的参数传递时，我们将 Vue Router 与我们的组件强耦合在一起，这无疑是不合适的，那么本章我们就来学习，如何实现组件和 Vue Router 之间的解耦。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系列目录地址：Vue.js 牛刀小试&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仓储地址：Chapter02-Bronze Decouple Component from Router 干货合集&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一、 编程式导航 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用 Vue Router 的时候，我们通常会通过 router-link 标签去生成跳转到指定路由的链接，但是在实际的前端开发中，我们更多的是通过 js 的方式进行跳转。就像我们很常见的一个交互需求，用户提交表单，提交成功后跳转到上一页面，提交失败则留在当前页。这时候如果我们还是通过 router-link 标签进行跳转就不合适了，我们需要通过 js 根据表单返回的状态进行动态的判断。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用 Vue Router 时，我们已经将 Vue Router 的实例挂载到了 Vue 实例上，因此我们就可以借助 $router 的实例方法，通过编写 js 代码的方式实现路由间的跳转，而这种方式就是一种编程式的路由导航。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Vue Router 中具有三种导航方法，分别为 push、replace 和 go。我们最常见的通过在页面上设置 router-link 标签进行路由地址间的跳转，就等同于执行了一次 push 方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这一小节的示例中，我将使用编程式导航实现通过点击不同的按钮实现路由间的跳转，最终实现的示意图如下所示。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在之前学习 Vue Router 的基础使用方法时，我们了解到，前端路由的实现方式，实际上就是对于浏览器的 history api 的操作。浏览器的 history 对象提供了对浏览器的会话历史的访问，它暴露了很多有用的方法和属性，允许我们在用户浏览历史中向前和向后跳转，同时从 HTML5 开始提供了对 history 栈中内容的操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而 Vue Router 所提供的 push、replace 和 go 方法则完全可以对应到浏览器 history api 中所提供的 history.pushState、history.replaceState 和 history.go 方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、 push &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们需要跳转新页面时，我们就可以通过 push 方法将一条新的路由记录添加到浏览器的 history 栈中，通过 history 的自身特性，从而驱使浏览器进行页面的跳转。同时，因为在 history 会话历史中会一直保留着这个路由信息，所以当我们后退时还是可以退回到当前的页面。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 push 方法中，参数可以是一个字符串路径，或者是一个描述地址的对象，这里其实就等同于我们调用了 history.pushState 方法。12345678// 字符串 =&gt; /firstthis.$router.push('first')// 对象 =&gt; /firstthis.$router.push({ path: 'first' })// 带查询参数 =&gt; /first?abc=123this.$router.push({ path: 'first', query: { abc: '123' }}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里需要注意，当我们传递的参数为一个对象并且当 path 与 params 共同使用时，对象中的 params 属性不会起任何的作用，我们需要采用命名路由的方式进行跳转，或者是直接使用带有参数的全路径。12345678910const userId = '123'// 使用命名路由 =&gt; /user/123this.$router.push({ name: 'user', params: { userId }})// 使用带有参数的全路径 =&gt; /user/123this.$router.push({ path: `/user/${userId}` })// 这里的 params 不生效 =&gt; /userthis.$router.push({ path: '/user', params: { userId }}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、 go &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们使用 go 方法时，我们就可以在 history 记录中向前或者后退多少步，也就是说通过 go 方法你可以在已经存储的 history 路由历史中来回跳。123456789101112// 在浏览器记录中前进一步，等同于 history.forward()this.$router.go(1)// 后退一步记录，等同于 history.back()this.$router.go(-1)// 前进 3 步记录this.$router.go(3)// 如果 history 记录不够用，那就默默地失败呗this.$router.go(-100)this.$router.go(100) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、 replace &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace 方法同样可以达到实现路由跳转的目的，不过，从名字中你也可以看出，与使用 push 方法跳转不同是，当我们使用 replace 方法时，并不会往 history 栈中新增一条新的记录，而是会替换掉当前的记录，因此，你无法通过后退按钮再回到被替换前的页面。123this.$router.replace({ path: '/special'}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过编程式路由实现路由间切换的示例代码如下所示，你可以自己尝试一下，去熟悉如何通过 js 来实现路由地址间的切换。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;div id=\"app\"&gt; &lt;div class=\"main\"&gt; &lt;div class=\"btn-toolbar\" role=\"toolbar\" aria-label=\"Toolbar with button groups\"&gt; &lt;div class=\"btn-group mr-2\" role=\"group\" aria-label=\"First group\"&gt; &lt;button type=\"button\" class=\"btn btn-secondary\" @click=\"goFirst\"&gt;第一页&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-secondary\" @click=\"goSecond\"&gt;第二页&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-secondary\" @click=\"goThird\"&gt;第三页&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-secondary\" @click=\"goFourth\"&gt;第四页&lt;/button&gt; &lt;/div&gt; &lt;div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Second group\"&gt; &lt;button type=\"button\" class=\"btn btn-secondary\" @click=\"pre\"&gt;后退&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-secondary\" @click=\"next\"&gt;前进&lt;/button&gt; &lt;/div&gt; &lt;div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Third group\"&gt; &lt;button type=\"button\" class=\"btn btn-secondary\" @click=\"replace\"&gt;替换当前页为特殊页&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; const first = { template: '&lt;h3&gt;当前是第一页&lt;/h3&gt;' } const second = { template: '&lt;h3&gt;当前是第二页&lt;/h3&gt;' } const third = { template: '&lt;h3&gt;当前是第三页&lt;/h3&gt;' } const fourth = { template: '&lt;h3&gt;当前是第四页&lt;/h3&gt;' } const special = { template: '&lt;h3&gt;特殊页面&lt;/h3&gt;' } const router = new VueRouter({ routes: [{ path: '/first', component: first }, { path: '/second', component: second }, { path: '/third', component: third }, { path: '/fourth', component: fourth }, { path: '/special', component: special }] }) const vm = new Vue({ el: '#app', data: {}, methods: { goFirst() { this.$router.push({ path: '/first' }) }, goSecond() { this.$router.push({ path: '/second' }) }, goThird() { this.$router.push({ path: '/third' }) }, goFourth() { this.$router.push({ path: '/fourth' }) }, next() { this.$router.go(1) }, pre() { this.$router.go(-1) }, replace() { this.$router.replace({ path: '/special' }) } }, router: router })&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、 解耦 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在文章开头我们有提到过，在使用路由传参的时候，我们将组件与 Vue Router 强绑定在了一块，这意味着在任何需要获取路由参数的地方，我们都需要加载 Vue Router。那么，如何解决这一强绑定呢？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在之前学习组件相关的知识时，我们提到了可以通过组件的 props 选项来实现子组件接收父组件传递的值。而在 Vue Router 中，同样给我们提供了通过使用组件的 props 选项来进行解耦的功能。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在下面的示例中，在定义路由模板时，我们通过指定需要传递的参数为 props 选项中的一个数据项，之后，我们通过在定义路由规则时，指定 props 属性为 true，即可实现对于组件以及 Vue Router 之间的解耦。123456789101112131415161718192021222324252627&lt;script&gt; const second = { props: ['id'], template: '&lt;h3&gt;当前是第二页 --- {{id}} &lt;/h3&gt;' } const router = new VueRouter({ routes: [{ path: '/second/:id', component: second, props: true }] }) const vm = new Vue({ el: '#app', data: {}, methods: { goSecond() { this.$router.push({ path: '/second' }) } }, router: router })&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到，这里采用 param 传参的方式进行参数传递，而在组件中我们并没有加载 Vue Router 实例，也完成了对于路由参数的获取。需要注意的是，采用此方法，只能实现基于 param 方式进行传参的解耦。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对定义路由规则时，指定 props 属性为 true 这一种情况，在 Vue Router 中，我们还可以给路由规则的 props 属性定义成一个对象或是函数。不过，如果定义成对象或是函数，此时并不能实现对于组件以及 Vue Router 间的解耦。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在将路由规则的 props 定义成对象后，此时不管路由参数中传递是任何值，最终获取到的都是对象中的值。同时，需要注意的是，props 中的属性值必须是静态的，也就是说，你不能采用类似于子组件同步获取父组件传递的值作为 props 中的属性值。1234567891011121314151617181920212223242526272829&lt;script&gt; const third = { props: ['name'], template: '&lt;h3&gt;当前是第三页 --- {{name}} &lt;/h3&gt;' } const router = new VueRouter({ routes: [{ path: '/third/:name', component: third, props: { name: 'zhangsan' } }] }) const vm = new Vue({ el: '#app', data: {}, methods: { goThird() { this.$router.push({ path: '/third' }) } }, router: router })&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在对象模式中，我们只能接收静态的 props 属性值，而当我们使用函数模式之后，就可以对静态值做数据的进一步加工或者是与路由传参的值进行结合。123456789101112131415161718192021222324252627282930&lt;script&gt; const fourth = { props: ['id', 'name'], template: '&lt;h3&gt;当前是第四页 --- {{id}} --- {{name}} &lt;/h3&gt;' } const router = new VueRouter({ routes: [{ path: '/fourth', component: fourth, props: (route) =&gt; ({ id: route.query.id, name: 'zhangsan' }) }] }) const vm = new Vue({ el: '#app', data: {}, methods: { goFourth() { this.$router.push({ path: '/fourth' }) } }, router: router })&lt;/script&gt; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一章主要学习了如何通过使用 Vue Router 的实例方法，从而实现编程式导航，以及如何实现组件与 Vue Router 之间的解耦。至此，Vue Router 的一些基础使用方法也就大概介绍完了，其它的知识点将在后面的项目中具体使用到的时候再进行介绍，欢迎持续关注哈~~~ 参考&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、History API与浏览器历史堆栈管理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、可能比文档还详细–VueRouter完全指北&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、十全大补vue-router","link":"/2019/07/02/Vue-Chapter14/"},{"title":"【Vue 牛刀小试】：第十五章 - 传统开发模式下的 axios 使用入门","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在没有接触 React、Angular、Vue 这类 MVVM 的前端框架之前，无法抛弃 Jquery 的重要理由，除了优秀的前端 DOM 元素操作性以外，能够非常便捷的发起 http 请求也占有非常重要的地位。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既然我们已经开始使用 Vue 进行前端开发，抛弃了对页面 DOM 元素的操作，难道，为了方便的发起 http 请求，还需要在项目中加载 jquery 或者是手动创建 http 请求吗？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案当然是不用的，作为目前主流的前端框架，开发者、社区早已经为我们提供好了解决方案。随着 Vue 作者尤雨溪宣布不再维护 vue-resource，转而推荐大家使用 axios，目前在 Vue 社区中 axios 开始占据 http 库的主导地位，所以这一章我们就介绍下如何使用 axios 发起 http 请求。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系列目录地址：Vue.js 牛刀小试&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仓储地址（前端）：Chapter02-Bronze Use Axios To Make HTTP Request&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仓储地址（后端）：Chapter02-Bronze ASP.NET Core Sample API 干货合集&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;axios 是一个基于 Promise 的 http 客户端，可以用于浏览器和 node.js。官方文档对于 axios 库的使用方法已经写的很清楚了，所以这里只介绍如何与 Vue 进行结合，从而使用 axios 发起 http 请求。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一章会涉及到简单的前后端的数据交互，作为一名 .NETer，本篇文章将采用 ASP.NET Core Web API 作为后端服务，你可以根据自己的喜好进行选择。当然，如果你之前并没有接触过后端，不知道怎么选择的话，推荐你尝试 .NET Core，示例的后端项目我也会同步放在 Github 上。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PS：在后端模板项目上，我会添加对于 Swagger API 文档的支持，以及在后端程序中进行配置跨域请求，从而允许后端接口可以接受跨域请求的访问。这些内容并不会在本篇文章中展现，如果你需要详细了解，你可以查看另一个系列的文章（ASP.NET Core 项目实战）那里会介绍一些关于 ASP.NET Core 项目的开发，两个系列相辅相成，后续所有涉及到前后端的交互开发，全部在此系列（ASP.NET Core 项目实战）中进行呈现。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一、加载 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同目前的前端发展方向相同，axios 可以从 npm、yarn、bower 这种前端包管理工具中进行下载，同时，也提供了 cdn 链接，方便我们在传统的项目中进行使用。12345678// 使用 npm 加载npm install axios// 使用 bower 加载bower install axios// 使用 yarn 加载yarn add axios &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这篇文章中，我还是与之前一样，采用下载源文件的方式进行使用，在后续的前端框架搭建完成后再改用前端包管理工具进行加载。12// 使用 cdn 加载&lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、get &amp; post &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相比于 put 请求和 delete 请求，get 请求和 post 请求是我们最常用的两个方法，一个很常见的使用场景，我们通过 get 请求来搜索数据，通过 post 请求来提交数据。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在示例的后端接口中，提供了五个接口方法，分别对应了 get、post、put、delete 这四个 HTTP 谓词。put 和 delete 对应的接口方法这里并没有实现，这篇文章主要使用的是 get 和 post 谓词对应的三个接口。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、获取所有的用户数据（/api/user） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get 请求，加载全部的用户数据，按照创建时间进行降序排列。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、根据搜索条件搜索用户数据(/api/user/query) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get 请求，根据用户输入框输入的数据，从全部的用户数据中查找出符合条件的数据，因为这里会存在多个查询条件，其实并不太符合 Restful 的接口设计，所以这里我采用 ASP.NET Core 中的特性路由的方式，指定此路由为专门的数据查询接口。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、新增用户数据(/api/user) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;post 请求，提交一条新的用户数据，因为是采用 Restful 风格的接口设计，所以请求的地址与获取所有的用户数据相同，仅仅是 http 谓词的不同。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终实现的前端页面如下所示，页面第一次加载时会加载全部的用户数据；当用户点击搜索按钮时，会根据顶部的三个输入框中的值，从用户数据中进行筛选；当点击新增按钮时，则会根据 Name 和 Email 输入框中的值新增一条新的用户数据。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们需要在页面加载的时候请求后端接口，去获取我们的用户数据，这里我们在 Vue 实例的 methods 中定义一个 getList 方法，在这个方法中我们去请求后端接口。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在之前学习 Vue 的生命周期钩子函数时我们了解到，在 created 钩子函数中，对于 Vue 实例的 data 和 methods 已经初始化完成，此时，整个 Vue 实例已经初始化完成。但是，初始化完成的 Vue 实例没有与 DOM 进行绑定。所以，如果我们想要在页面初始加载时就渲染出整个用户信息表格，created 函数是能够调用 getList 方法最早的一个钩子函数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 axios 中，我们发起一个 http 请求后，在 then 回掉方法中进行请求成功后的数据处理，在 catch 回掉方法中捕获请求失败的信息。这里的 then 方法就相当于我们在 Jquery 中使用 ajax 时的 success 回调方法，而 catch 方法则是 error 回调。123456axios.get('http://localhost:5000/api/user') .then(function (response) { console.log(response) }).catch(function (error) { console.log(error) }) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从接口打印出的返回结果可以看到，接口返回的 response 中包含了五部分的信息。这里 data 属性显示的就是整个的用户数据集合，在实际使用中，你需要与 http 响应状态码进行结合，考虑如果后端出现错误如何使前端知晓，从而相对友好的通知用户。12345678910111213141516171819{ // 后端接口返回的数据 data: {}, // 服务端接口返回的 HTTP 状态码 status: 200, // 服务端接口返回的 HTTP 状态信息 statusText: 'OK', // 后端接口返回的响应 header 信息 headers: {}, // axios 发起的接口请求时的配置信息 config: {}, // 接口响应的请求信息 request: {}} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对 axios 发起请求时的配置信息，我们可以自己进行配置。例如我们可以设置请求的接口域名是什么，设置 post 请求时的 Content-Type，或者针对前后端数据交互时经常使用的 Jwt Token 验证，我们可以在请求的 header 中添加 token 信息，从而通过后端的权限验证。123axios.defaults.baseURL = 'https://api.example.com';axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们获取到所有的用户数据后，我们就可以将结果值赋值给我们 Vue 实例中的 users 数据集合对象（这个 users 需要你事先在 Vue 实例的 data 中进行提前定义好）。1234567axios.get('http://localhost:5000/api/user') .then(function (response) { console.log(response) this.users = response.data }).catch(function (error) { console.log(error) }) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你按照上面的写法进行赋值，你会发现页面上并没有按照我们的想法渲染出数据。既然我们已经获取到了后端接口返回的数据值，那么这里的问题就可能出现在赋值这上面。我们可以在 then 回调中打印 this.users 看看。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到，这里的 this 指向的其实是浏览器的 window 对象，因此我们给 this.users 赋值最终是赋值到 window 对象上了。因为是 this 指向出了问题，所以这里我就直接采用箭头函数的方式进行数据赋值，最终的实现代码如下所示。12345678910111213141516171819202122var vm = new Vue({ el: '#app', data: { id: '', name: '', email: '', users: [] }, created() { this.getList() }, methods: { getList() { axios.get('http://localhost:5000/api/user') .then(response =&gt; { this.users = response.data }).catch(error =&gt; { console.log(error) }) } },}); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;搜索按钮的功能与获取所有用户信息的代码比较相似，这里我们需要将搜索的参数添加到 get 请求中。从下图的浏览器控制台中可以看到，当点击查询按钮之后，我们添加的参数会以 query 查询字符串的方式添加到请求的 url 地址上。123456789101112131415161718192021222324var vm = new Vue({ el: '#app', data: { id: '', name: '', email: '', users: [] }, methods: { search() { axios.get('http://localhost:5000/api/user/query', { params: { id: this.id, name: this.name, email: this.email, } }).then(response =&gt; { this.users = response.data }).catch(error =&gt; { console.log(error) }) } },}); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与 get 请求相似，使用 axios 发起 post 请求也是在 then 回掉方法中获取接口返回值，在 catch 回掉方法中捕获错误信息。123456789101112131415161718192021222324252627282930var vm = new Vue({ el: '#app', data: { id: '', name: '', email: '', users: [] }, methods: { getList() { axios.get('http://localhost:5000/api/user') .then(response =&gt; { this.users = response.data }).catch(error =&gt; { console.log(error) }) }, add() { axios.post('http://localhost:5000/api/user', { name: this.name, email: this.email, }).then(response =&gt; { console.log(response) this.getList() }).catch(error =&gt; { console.log(error) }) } },}); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像我们使用 jquery 发起 ajax 请求一样，我们可以使用 $.ajax/$.post 方法去发起一个 get/post 请求，也可以在 $.ajax 方法中通过指定请求的 type 类型来确定我们是以 get 请求还是 post 请求的方式执行，在 axios 中也提供了相似的功能。 123456789101112131415// get 请求axios({ method: 'get', url: 'http://localhost:5000/api/user'})// post 请求axios({ method: 'post', url: 'http://localhost:5000/api/user', data: { name: this.name, email: this.email, }}); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整个前端页面完整的示例代码以及实现的效果如下所示。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;div id=\"app\"&gt; &lt;div class=\"card border-info mb-3\" style=\"margin-top: 20px;\"&gt; &lt;div class=\"card-header text-info\"&gt; &lt;b&gt;用户信息&lt;/b&gt; &lt;/div&gt; &lt;div class=\"card-body text-info form-inline\"&gt; &lt;div class=\"form-row\"&gt; &lt;div class=\"form-group\"&gt; &lt;div class=\"input-group mb-2 mr-sm-2\"&gt; &lt;div class=\"input-group-prepend\"&gt; &lt;div class=\"input-group-text text-info\"&gt; Id &lt;/div&gt; &lt;/div&gt; &lt;input type=\"text\" class=\"form-control\" id=\"id\" v-model=\"id\" autocomplete=\"off\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;div class=\"input-group mb-2 mr-sm-2\"&gt; &lt;div class=\"input-group-prepend\"&gt; &lt;div class=\"input-group-text text-info\"&gt; Name &lt;/div&gt; &lt;/div&gt; &lt;input type=\"text\" class=\"form-control\" id=\"name\" v-model=\"name\" autocomplete=\"off\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;div class=\"input-group mb-2 mr-sm-2\"&gt; &lt;div class=\"input-group-prepend\"&gt; &lt;div class=\"input-group-text text-info\"&gt; Email &lt;/div&gt; &lt;/div&gt; &lt;input type=\"email\" class=\"form-control\" id=\"email\" v-model=\"email\" autocomplete=\"off\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;a class=\"btn btn-info\" href=\"#\" role=\"button\" @click=\"search\"&gt;搜索&lt;/a&gt; &lt;a class=\"btn btn-success\" href=\"#\" role=\"button\" @click=\"add\"&gt;新增&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;table class=\"table table-striped table-bordered table-hover text-info\"&gt; &lt;thead class=\"thead-inverse\"&gt; &lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Email&lt;/th&gt; &lt;th&gt;Created On&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=\"item in users\" :key=\"item.id\"&gt; &lt;td scope=\"row\"&gt;{{item.id}}&lt;/td&gt; &lt;td&gt;{{item.name}}&lt;/td&gt; &lt;td&gt;{{item.email}}&lt;/td&gt; &lt;td&gt;{{item.createdTime}}&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { id: '', name: '', email: '', users: [] }, created() { this.getList() }, methods: { getList() { axios.get('http://localhost:5000/api/user') .then(response =&gt; { this.users = response.data }).catch(error =&gt; { console.log(error) }) }, search() { axios.get('http://localhost:5000/api/user/query', { params: { id: this.id, name: this.name, email: this.email, } }).then(response =&gt; { this.users = response.data }).catch(error =&gt; { console.log(error) }) }, add() { axios.post('http://localhost:5000/api/user', { name: this.name, email: this.email, }).then(response =&gt; { console.log(response) this.getList() }).catch(error =&gt; { console.log(error) }) } }, });&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三、 拦截器 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在前后端分离的项目中，我们一般采用 Jwt token 的方式进行权限控制。前端在获取数据之前，需要从后端获取到 token 令牌。当前端获取到后端回传的 token 信息后，我们需要将此 token 信息保存下来，此后所有的请求都需要在请求的 header 信息中添加此 token 信息。那么，能不能有一种方式可以在触发后端验证之前，统一的进行 token 信息校验，当判断没有包含 token 信息之后，前端直接跳转到登录页面。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 axios 中，我们可以将此类操作放置到拦截器中。你可以将 axios 中的拦截器看成是 ASP.NET Core 中的 Filters 过滤器，例如，这里的需求，我们完全可以将获取到的 token 信息置于 request 请求拦截器中，在发起的每一次 http 请求时去校验是否包含 token 信息，当没有包含 token 信息时，就可以直接跳转到登录页面。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里因为我并没有实现后端 token 验证，所以这里就只是进行一个演示，你可以从浏览器的控制台中看到只要我们发起一个 http 请求，就会输出的我们打印的信息。1234567891011// request 请求拦截axios.interceptors.request.use(function (request) { // 对 request 进行拦截 if(true){ console.log('跳转到登录页面') } return request;}, function (error) { // 在错误请求时进行操作 return Promise.reject(error);}); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既然有针对发起 request 请求时的拦截器，毫无疑问，对于获取到接口返回的 response 信息，我们同样可以使用拦截器进行拦截。例如，在定义 restful 接口时，我们一般会根据 http 响应状态码去反映接口的调用是否成功。在每一个通过 axios 发起请求的 then 回掉方法中，我们都需要对获取到响应状态码进行判断，判断接口的调用是否成功。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们使用拦截器后，我们完全可以在针对 response 的拦截器中进行统一的判断。例如，当调用接口不成功时，http 响应状态码为 400，同时返回错误信息，我们完全可以在拦截器中进行判断，当所有的接口响应状态码为 400 时，弹出后端返回的错误信息。1234567891011121314151617181920// response 请求拦截axios.interceptors.response.use(function (response) { // 对 response 进行拦截 switch (response.status) { case 200: console.log('接口访问成功') break case 400: console.log('提示错误信息') break case 401: console.log('重定向到登录页面') break } return response;}, function (error) { // 在错误请求时进行操作 return Promise.reject(error);}); 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇文章主要是简单介绍如何使用 axios 去实现发起一个 http 请求。至此，在现阶段的 Vue 学习使用中，对于一些基础知识点就已经完成了一个初步的梳理，接下来，从下一章开始，我会从 0 开始通过 Vue CLI 去搭建一个前端的项目模板，因为自己并不是一个前端开发人员，个人的关注点还在于 .NET Core 后端，所以这里可能并不会涉及到 webpack 相关的知识点。同时，一些在之前的学习中没有涉及到的知识点也会在后续的文章中进行补充。之后，就像开篇时所说的那样，Vue.js 牛刀小试 和 ASP.NET Core 项目实战 相辅相成，后期的关注点将聚焦于如何通过 ASP.NET Core 和 Vue 进行前后端开发，欢迎持续关注~~~","link":"/2019/07/08/Vue-Chapter15/"},{"title":"【Vue 牛刀小试】：第十六章 - 针对传统后端开发人员的前端项目框架搭建","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在之前学习 Vue 基础知识点的文章中，我们还是采用传统的方式，通过在 html 页面上引用 vue.js 这个文件，从而将 Vue 引入到我们的项目开发中。伴随着 Node.js 的出现，以及 React、Angular、Vue 这类的前端 MVVM 框架的发展，前端越来越像后端靠拢，前端工程化的思想开始出现。现在的前端开发，已经不再只是一个 html 页面，上面引用各种 js、css 文件就可以完成开发的了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与后端类似，前端开始出现各种已经很完善的框架模板、开始出现针对前端组件包的管理工具、各种各样的单元测试库，以及针对前端所特有的 js、css、image…这种静态资源文件的模块打包器。那么，从本篇文章开始，我们就从零开始，结合之前学习的 Vue 相关的基础知识，通过 Vue CLI 和 Element UI 去搭建一个基于 Vue 的 SPA 前端项目框架模板。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系列目录地址：Vue.js 牛刀小试&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仓储地址：Chapter03-Silver Use Vue CLI To Build Vue Project 干货合集&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统框架，它是一个框架生成脚手架工具，可以帮助我们生成基于 Vue 的前端框架模板，我们可以在这个基础上进行基于 Vue 的前端开发。你可以把它理解为我们 .NET 平台中微软所提供的各种基础的开发框架模板，就像 ASP.NET Core Web API 或者是 ASP.NET Core MVC 这一类的基础框架，我们可以在这个框架模板上进行开发，从而开发出具有统一标准、规范化的项目。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Element UI 则是饿了么基于 Vue.js 所做的一套前端组件库，你可以把它理解成类似于 Boostrap 或是 EasyUI 这种前端的 UI 库基于 Vue 中组件的思想所实现的前端库。通过使用这套组件库，我们就可以更好地统一整个项目的前端样式以及更加方便的进行开发。当然，你也可以采用别的组件库或是自己手写一套。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一、安装 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用 Vue CLI 之前，我们首先需要安装这个组件包，你可以通过 npm 或是 yarn 的方式进行安装，当然，前提是你需要在你的电脑上安装好 Node.js。整个安装的过程很简单，你可以从我之前写的 ASP.NET Core 实战：使用 ASP.NET Core Web API 和 Vue.js，搭建前后端分离框架 这篇文章中来查看如何安装 Node.js 和 Vue CLI。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你安装已经完成，我们就可以通过命令行或是脚手架自带的项目管理页面去搭建一个属于你的 Vue 前端项目框架模板，这里我就选择命令行的方式进行创建项目。当然，在创建项目前我们需要通过命令来查看组件包的安装是否正确。你可以通过下面的命令去检查安装是否正确，当控制台输出版本信息后，则代表你的组件包已经成功安装了。1vue --version ## 查看安装的 vue cli 版本信息 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、初始化创建 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们安装完成后，我们就可以通过命令行去创建一个前端项目模板。首先，进入你需要创建项目的路径下，打开终端，然后使用下面的命令来创建我们的项目。因为某些原因，连接 npm 源的速度可能会比较慢，所以在创建项目时，Vue CLI 会提示我们是否将淘宝的镜像源添加 npm 中，从而加快我们访问的速度，你可以自由选择。12# vue create 项目名称vue create grapefruit.ui &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时，从控制台中可以看到给出了两个选项，第一项为系统预设的项目模板配置，而第二项则是我们可以自己选择我们的项目模板需要加载什么前端组件。这里，我们选择第二项，自己来决定加载什么组件。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在选择前端组件时，我们可以通过上下方向键进行切换，通过空格键进行选择，当决定好项目加载的组件后，我们可以通过 Enter 键来进行确定。在这个模板项目中，我添加了上图所示的五个组件，你可以根据自己的需求进行按需加载。每个组件的基本功能介绍如下。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Babel：这是一个 JavaScript 转码器，当我们使用新的语法时，旧版本的浏览器可能就无法支持这种新的语法，通过 Babel，我们就可以添加不同的转换规则，从而就可以自动的将新版本的语法糖转换成传统的 JavaScript 语法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TypeScript：它提供了一些 JavaScript 不支持的强语言特性，例如，类、接口、参数类型约束等等，它使 JavaScript 写起来更像我们的 C# 或是 Java 这种强类型语言，当然最终还是会编译成 js 文件从而让浏览器识别出。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PWA：渐进式的 Web 应用，主要是利用提供的标准化框架，在网页应用中实现和原生应用相近的用户体验，让用户以为自己正在使用的是原生应用，微信的小程序其实就可以看成是一种 PWA 应用的载体。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Router：这个大家应该很熟悉了，在前面的文章中我们也有介绍过，是 Vue 官方的路由管理组件。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vuex：一个 Vue.js 中的状态管理模式，这里的状态可以简单理解为数据。因为在使用 Vue 的开发中，我们会编写各种组件，有些时候，多个组件之间需要共享相同的数据，以及，各个组件之间的数据传递也比较复杂，所以我们需要一个集中式的状态管理器从而更好的管理数据，方便组件之间的通信。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CSS Pre-processors：CSS 的预处理器，可以让我们以一种编程的方式来写 CSS 文件，当然最终它们都会被编译器编译成标准 css 文件。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linter / Foramtter：代码格式检查和格式化工具，主要是为了让我们的项目中写的代码可以更好的采用统一的风格。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unit Testing / E2E Testing：单元测试工具&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们选择好需要加载的组件后，就可以继续了。因为我们加载了 Vue Router，所以这里我们需要对前端路由的模式进行设定，这里我们继续使用 history 路由模式。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后，我们需要选择一个 CSS 的预处理器，根据你自己的使用习惯选择即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为之前有加载 ESLint 代码格式化组件，所以这里我们需要加载格式化和代码风格的规则，这里我选择的是 Airbnb 的规范，你可以自己选择其他的，当然你也可以编写出属于你自己的代码规范。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行 ESLint 检查的时间节点，这里我全部勾选上。同时，如果你和我一样使用的是 VS Code 进行开发的话，你可以安装 ESLint 插件，这样在编写代码时，就会自动提示出不符合规范的代码。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加载的这些组件，需要一个配置文件进行配置，你可以选择全部放到 package.json 中，也可以选择将每个组件的配置单独放到一个配置文件中。这里我选择一个组件一个配置文件。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后一步，是否保存这次的设置，如果保存的话，下次在创建项目时就可以直接使用了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，慢慢等待项目依赖的组件加载完成，这一步的快慢，取决你的网速和人品，请坐和放宽。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当所有的依赖加载完成后，系统提示我们进入到项目路径，然后执行 npm run serve 命令。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们执行 npm 命令后，可以看到项目已经运行起来了，我们可以打开浏览器进行查看，当出现下面的页面时，恭喜你，项目的基础模板已经搭建的差不多了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;项目的基础模板已经可以正常运行了，现在我们就可以将 Element UI 添加到我们的项目中。饿了么为 Vue CLI 3 准备了相应的模板插件，所以这里我们就可以直接通过命令来加载 Element 插件到我们的项目中。1vue add element &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为整个项目会基于 Element 的组件进行搭建，所以这里我们直接选择全局引入；对于默认的样式，这里我们不做任何的修改，之后选择简体中文。当插件安装完成后，我们可以重新运行我们的项目进行查看。可以看到，页面上已经添加了一个 Element UI 中的按钮组件。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当 Element UI 安装完成后，饿了么官方也有针对 VS Code 的插件，所以这里我们也可以安装，从而更便捷在项目开发中使用到 Element 中的组件。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同时，作为一个完整的项目，我们需要与采用 ASP.NET Core Web API 开发的后端进行数据交互，所以我们需要添加 axios 这个组件库，这里我们使用 npm 安装即可。至此，我们的项目的基础框架模板就已经创建完成了。1npm install axios 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一章主要是学习如何通过 Vue CLI 3 和 Element UI 去搭建一个基础的前端项目。在下一篇文章中，我将参考文章最后列出的参考文章和 vue-admin-template 这个模板对我们的项目进行调整，从而适应我们自己的开发习惯。 参考&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、从0到1搭建Element的后台框架&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、vue-cli3 项目从搭建优化到docker部署&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、一张图教你快速玩转vue-cli3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、手摸手，带你用vue撸后台 系列四(vueAdmin 一个极简的后台基础模板)","link":"/2019/07/14/Vue-Chapter16/"},{"title":"Vue.js 牛刀小试（持续更新~~~）","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个系列的文章开始于今年9月从上一家公司辞职后，在找工作的过程中，觉得自己应该学习一些新的东西，从前几章的更新日期也可以看出，中间隔了很长的时间，自己也经历了一些事情，既然现在已经稳定了，就要继续下去啊。作为一个 .NET 后端程序员，自己的侧重点肯定还是在后端，这个系列的学习主要是为了为后面使用 ASP.NET Core Web API 创建前后端分离的项目提供一些基础知识的准备，当然，整个前后端分离的项目也会在后面的文章中体现出来，希望可以多多关注。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果在文章中有说的不对的地方欢迎指出，当然，如果能帮到你一星半点的，不胜荣幸。 章节目录 一、基础知识概览 第一章 - 一些基础概念（posted at 2018-08-27） 第二章 - 常见的指令的使用（posted at 2018-08-28） 第三章 - 事件修饰符的使用（posted at 2018-10-31） 第四章 - 页面元素样式的设定（posted at 2018-11-04） 第五章 - 计算属性与监听器（posted at 2018-11-08） 第六章 - 按键修饰符的使用（posted at 2018-11-15） 第七章 - Vue 实例的生命周期（posted at 2018-12-12） 二、深入了解 Vue 第八章 - 组件的基础知识（posted at 2019-01-03） 第九章 - 组件基础再探（data、props）（posted at 2019-03-09） 第十章 - 组件间的数据通信（posted at 2019-03-31） 第十一章 - Vue 中 ref 的使用（posted at 2019-04-28） 第十二章 - 使用 Vue Router 实现 Vue 中的前端路由控制（posted at 2019-05-21） 第十三章 - Vue Router 基础使用再探（命名视图、路由传参）（posted at 2019-06-16） 第十四章 - 编程式导航与实现组件与 Vue Router 之间的解耦（posted at 2019-07-02） 第十五章 - 传统开发模式下的 axios 使用入门（posted at 2019-07-08） 三、项目模板搭建 第十六章 - 针对传统后端开发人员的前端项目框架搭建（posted at 2019-07-14） 第十七章 - 优化 Vue CLI 3 构建的前端项目模板（1）- 基础项目模板介绍（posted at 2019-09-15） 链接地址 Vue官网地址：https://cn.vuejs.org/ 学习记录仓储地址：https://github.com/Lanesra712/VueTrial","link":"/2018/08/27/Vue-Overview/"},{"title":"从学生到社会银，我的两年记","text":"碎碎念&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不知不觉又到了年末，这一年又要过完了，算上实习的经历，工作也有两年的时间了，这两年的时间，谈不上自己做的有多出彩，只是这两年的经历，让自己也慢慢的想明白了一些事情，从走出大学校园到进入社会，时间的车轮一直在往前行进，由不得你作出半点停留。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;废话有点多，思维有点跳，见谅见谅~~~ 谈梦想？现实点！&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;近一年半的实习经历，将大学生涯骤然的分成了两个部分：学习时对未来工作的美好设想，实习时认清现实的无奈。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为学校的缘故，自己的大学同学大多都在16年底17年初出去实习，也就是在那个时间节点之后，某次在异地的相遇、约好的聚会，以往三句不离游戏的同学，渐渐的会谈工作、工资、生活。最近加班多吗？有没有涨工资？实习结束后会留下来吗？第一次以一个成年人的角色独自面对这个社会，人也在慢慢改变。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说来奇怪，实习之前，好像我这么多年来，从来没有想过工作时我会住在哪里，大学之前一直住在家中，大学时第一次住校。对于自己未来的归属，似乎一直抱有大学生般的 “天真” 。直到从学校出去实习时，前二十年来四平八稳的人生，终究是在第一次踏入社会时，在走进这座陌生的城市去寻找自己归宿点的冲击下裂的粉碎。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了缩短每天的通勤距离，公司周边的小区一个个的来回跑，找小区内张贴的租房小广告、中介、房东，打一个个的电话。当第一次真正面对房屋租金与期望价格以及实际居住环境间的巨大落差，在心中思考着去掉租金和吃饭，自己一个月还会剩下多少工资时，那种复杂感，真的会让人成长。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你看着这城市的霓虹灯在闪烁，马路上车水马龙，这城市的万家灯火，似乎却没有一盏为你点亮。第一次，我真正认识到，房子，是有多么的重要。 在路上&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作为一个 Nokia 的老用户，我一直很喜欢当初的那种聚酯塑料的美感，当 Nokia 转投 Microsoft，决心投身 Windows Phone 之后，作为一个计算机学院的小学生，我决定自己投身于 Windows Phone 的洪流中，当然，最后的结局大家也都知道了，Windows Phone 一直保持着不温不火直到淡出视野，而 Lumia 亦或是说 Nokia 也早已退出。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是在这一段时间内，我第一次知道了 C#，知道了 .NET。之后，在大二小学期选专业方向时，也就没有过多纠结的选择了 .NET 开发。当然，这其中没选 Java 很大的原因是我不喜 Java 那种一个环境都需要很多的配置，以及，Visual Studio 真的很好用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这两年的工作经历中，在外包公司待过，在互联网公司待过，以及在一家入职时没说要做 delphi 的医疗行业公司短暂待过，目前就职于一家制造业公司，嗯，几家公司所在的行业跨越幅度很大。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;八个月外包公司的工作，是我的第一份 .NET 软件开发工作，第一次真正进入这个行业之中，这段工作经历让我对自己未来的工作有了一定的规划，明确了找工作时基本不再考虑外包公司，之后选择入职了一家互联网创业公司，虽然真的比原来累很多，晚上加班、周末加班也成为常态。可是，也就是这段职场经历，让我能够慢慢跟随上当前技术发展的方向，能够工作中抛弃 Web Form，开始在工作中使用 MVC、使用 Web API、开始参与到构建前后端分离的项目中、明确自学 .NET Core 的目标，并以此作为自己未来发展的方向。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是在这个过程中，渐渐发现，原来，在工作中 .NET Web 不仅仅只有 Web Form。原来，.NET 也并没有与这个时代脱节。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为快毕业时毕设、论文还没弄完，自己选择了辞职，这近一年半的实习经历也让我开始了解到软件开发这个行业。在赶毕业设计、修改论文，准备毕业所需的资料时，又一次回到了学校，可是，一切也变得不同了。偶尔在校园中听到学弟学妹在谈着期末怎么办，项目还没做完，四六级还没过的时候，也会感叹到，当个学生真好。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在准备毕业的间隙，也在忙着找工作，作为一个毕业生，却没有参加过校招。因为两份实习工作的缘故，在找工作时默认排除掉了还在做 Web Form 的。嗯，筛选了一番，最后发现，真的没有多少了，坐标中部某二线城市，实属无奈。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后，毕业后入职了一家做医疗行业软件的公司，结果发现 delphi 这个坑实在填不满，没有转正也就毅然决然的离职了。短暂的工作后，又面临着找工作的情况。不同的是，不再是学生，也开始需要考虑房租、吃饭的问题。裸辞穷半年，各位慎重。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;空闲了接近有一个月，期间真的有考虑，是不是我的要求真的太高了，管他做什么，工资给够不就可以了吗？或者，要不要去上海，去杭州，去中国互联网的一线中去看看。后来，入职了本地的一家制造业公司，入职的这几个月来，因为新任的老大也是从互联网公司跳过去的，整个部门也在慢慢接触新的技术，自己也在慢慢的学习中，渐渐感觉自己的时间不太够了。 未完待续&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;近一年来，开始接触 git，自学 .NET Core，试着坚持写博客，虽然中间有间断，但还是在坚持中。Github 提交了300多次，写了15篇左右的技术类博客，诚然，我自己也明白，自己的文章能够给予别人的帮助也不大，毕竟，有些东西我也仅仅是知道怎么用，却无法真正的解释清楚为什么要这样，可是，这也算是一个好的开始吧。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说道了半天，最后，贴上我很喜欢的大师兄的一句话，嗯，就是这样。 我听闻最美的故事，是公主死去了，屠龙的少年还在燃烧。所谓热血的少年，青涩的爱恋，死亡与梦之约。这么好的故事。你可别演砸了。 — 年少荒唐·朱炫","link":"/2018/12/28/Year-End-Summary-For-2018/"},{"title":"Angular 从入坑到挖坑 - 组件食用指南","text":"Overviewangular 入坑记录的笔记第二篇，介绍组件中的相关概念，以及如何在 angular 中通过使用组件来完成系统功能的实现。 对应官方文档地址： 显示数据 模板语法 用户输入 组件之间的交互 管道 生命周期钩子 配套代码地址：angular-practice/src/components-guide Contents Angular 从入坑到弃坑 - Angular 使用入门 Angular 从入坑到挖坑 - 组件食用指南 Knowledge Graph Step by Step组件与模板组件的基础概念组件包含了一组特定的功能，每个组件的功能都单一且独立，可以进行重复使用；组件可以通过 angular cli 进行创建，生成的组件位于工作空间的 src/app/ 路径下面 12## 创建一个 product-list 组件ng g component product-list 当需要将组件放置在某个指定的目录下时，可以直接在 ng g 命令中添加路径 12## 将 hero 组件生成到 components 路径下ng g component components/hero angular 应用就是通过一个个的组件所构成的组件树，一个组件包含了如下的四个部分 product-list.component.ts：组件类，用来处理数据和功能，为视图呈现提供支持 product-list.component.html：组件对应的页面 HTML 模板，用来呈现组件的功能 product-list.component.scss：只针对当前组件的样式 product-list.component.spec.ts：当前组件的单元测试文件（非必须） 当通过命令行创建一个新的组件之后，会自动将新创建的组件注册到应用的根模块（app.module.ts）中 在组件类中，通过使用 @Component 装饰器 [^1] 用来将类声明为组件类，并为这个组件类配置一些元数据 [^2]，以决定该组件在运行期间该如何处理、实例化和使用 装饰器中存在三个基础的配置参数，用来完成组件与视图之间的关联 selector：选择器，当我们在页面上添加了这个选择器指定的标签（&lt;app-product-list&gt;&lt;/app-product-list&gt;）后，就会在当前使用位置上创建并插入这个组件的一个实例 templateUrl：该组件所对应的 HTML 模板文件地址 styleUrls：该组件视图所特有的 css 样式文件地址 当需要使用这个组件时，直接在页面上添加选择器对应的标签就可以了 模板绑定语法在 angular 应用中，组件扮演着控制器或是视图模型的作用，在创建组件时会关联一个 html 文件，这个 html 文件则是一个基础的 angular 模板文件 在这个模板文件中，可以通过 angular 内置的模板语法与 html 元素进行结合，从而告诉 angular 如何根据我们的应用逻辑和数据来渲染页面 插值表达式插值表达式可以将组件中的属性值或者是模板上的数据通过模板表达式运算符进行计算，最终将值渲染到视图页面上 1234567891011121314151617import { Component, OnInit } from '@angular/core';@Component({ selector: 'app-product-list', templateUrl: './product-list.component.html', styleUrls: ['./product-list.component.scss']})export class ProductListComponent implements OnInit { public title = '我是 title 属性值'; constructor() { } ngOnInit(): void { }} 123&lt;p&gt;title：{{title}}&lt;/p&gt;&lt;p&gt;1+2+3+4+5={{1+2+3+4+5}}&lt;/p&gt; 模板表达式的变量来源 模板本身的变量 指令的上下文变量 组件的成员信息（属性 or 方法） 在使用模板表达式时，如果变量名在多个来源中都存在的话，则模板变量是最优先的，其次是指令的上下文变量，最后是组件的成员 在使用模板表达式时应该遵循如下的原则 简单：正常情况下，应该将业务逻辑或是数据运算放到组件中，模板表达式只作为属性或方法的调用 快速执行：模板表达式得出的数据应该快速结束，否则就会对于用户体验造成影响 没有可见的副作用：模板表达式只作为数据的展示，不应该改变任何的数据；应该构建出幂等的表达式，除非依赖的值发生变化，否则多次调用时，应该返回相同的数据信息 模板绑定语法通过数据绑定机制，将数据源与视图进行绑定，从而实现源数据与用户呈现的一致性 从数据源到视图：插值、组件中的属性、dom 元素的 property [^3]、css 样式、css 类 从视图到数据源：事件 视图与数据源之间的双向绑定：数据对象 分类 语法 单向从数据源到视图 1、插值表达式：2、使用 [] 进行绑定：&lt;a [href]='expression'&gt;&lt;/a&gt;3、使用 bind 进行绑定：&lt;a bind-href='expression'&gt;&lt;/a&gt; 单向从视图到数据源 1、使用 () 进行绑定：&lt;a (click)='statement'&gt;&lt;/a&gt;2、使用 on 进行绑定：&lt;a on-click='statement'&gt;&lt;/a&gt; 双向视图到数据源；数据源到视图 1、使用 [()] 进行绑定：&lt;input type=&quot;text&quot; [(ngModel)]=&quot;product.Name&quot;&gt;2、使用 bindon 进行绑定：&lt;input type=&quot;text&quot; bindon-ngModel=&quot;product.Name&quot;&gt; 1234567891011121314151617181920212223242526272829import { Component, OnInit } from '@angular/core';@Component({ selector: 'app-product-list', templateUrl: './product-list.component.html', styleUrls: ['./product-list.component.scss']})export class ProductListComponent implements OnInit { public title = '我是 title 属性值'; public styleProperty = '&lt;b&gt;我是包含 html 标签的属性&lt;/b&gt;'; public fontColor = 'red'; public url = 'https://yuiter.com'; public name: string; constructor() { } ngOnInit(): void { } getUser() { alert('111111111'); }} 1234567891011121314151617181920212223242526272829303132&lt;h3&gt;2.1、从数据源到视图&lt;/h3&gt;&lt;p&gt; &lt;a href='{{url}}'&gt;使用插值表达式进行绑定&lt;/a&gt;&lt;/p&gt;&lt;p&gt; &lt;a [href]='url' [style.color]='fontColor'&gt;使用 [] 进行绑定&lt;/a&gt;&lt;/p&gt;&lt;p&gt; &lt;a bind-href='url'&gt;使用 bind 进行绑定&lt;/a&gt;&lt;/p&gt;&lt;p&gt; &lt;span [innerHtml]=\"styleProperty\"&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;2.2、从视图到数据源&lt;/h3&gt;&lt;p&gt; &lt;button (click)=\"getUser()\"&gt;使用 () 进行绑定&lt;/button&gt;&lt;/p&gt;&lt;p&gt; &lt;button on-click=\"getUser()\"&gt;使用 on 进行绑定&lt;/button&gt;&lt;/p&gt;&lt;h3&gt;2.3、数据双向绑定 --- 需要在 AppModule 中添加对于 FormsModule 的引用&lt;/h3&gt;&lt;p&gt; &lt;input type=\"text\" id=\"userName\" [(ngModel)]=\"name\"&gt;&lt;/p&gt;&lt;p&gt; &lt;input type=\"text\" bindon-ngModel=\"name\"&gt;&lt;/p&gt; 数据绑定 单向数据绑定 1&lt;p&gt;{{title}}&lt;/p&gt; 双向数据绑定 123456&lt;input type=\"text\" id=\"userName\" [(ngModel)]=\"name\"&gt;&lt;!-- 当没有 NgModel 时，双向数据绑定等同于下面的写法 --&gt;&lt;input type=\"text\" id=\"userName\" [value]=\"name\" (input)=\"name=$event.target.value\"&gt; 属性、样式绑定 dom 元素的 property 绑定 123&lt;img [src]=\"productImageUrl\"&gt;&lt;img bind-src=\"productImageUrl\"&gt; html 标签的 attribute 绑定 attribute 绑定的语法类似于 property 绑定，由前缀 attr、点（ . ）和 attribute 名称组成 attribute 绑定的主要用例之一是设置 ARIA attribute（给残障人士提供便利） 1&lt;button [attr.aria-label]=\"actionName\"&gt;{{actionName}} with Aria&lt;/button&gt; style 内联样式绑定 1234567891011121314// 1、[style.width]=\"width\" ：string | undefined | nullpublic width = \"100px\";//2、[style.width.px]=\"width\"：number | undefined | nullpublic width = \"20\";// 3、[style]=\"styleExpr\"：stringpublic styleExpr = \"width: 100px; color:red\";// 4、[style]=\"styleExpr\"：{key:value}public styleExpr = {width: '100px', height: '100px'};// 5、[style]=\"styleExpr\"：arraypublic styleExpr = [\"width\", \"100px\"]; class 属性绑定 1234567891011// 1、[class.foo]=\"hasFoo\"：bool | undefined | nullpublic hasFoo = true;// 2、[class]=\"classExpr\"：stringpublic classExpr = \"my-class1 my-class2\";// 3、[class]=\"classExpr\"：{key:value}public classExpr= {my-class1: true, my-class2: true};// 4、[class]=\"classExpr\"：arraypublic classExpr= [\"my-class1\", \"my-class2\"]; 事件绑定在事件绑定中，可以通过 $event 参数获取到 dom 事件对象的属性从而获取到模板信息 12&lt;input type=\"text\" (keyup)=\"getMsg($event)\"&gt;&lt;p&gt;输入的值：{{msg}}&lt;/p&gt; 12345678910111213141516171819202122import { Component, OnInit } from '@angular/core';@Component({ selector: 'app-product-list', templateUrl: './product-list.component.html', styleUrls: ['./product-list.component.scss']})export class ProductListComponent implements OnInit { public msg: string; constructor() { } ngOnInit(): void { } getMsg(event: KeyboardEvent) { console.log(event); this.msg = (event.target as HTMLInputElement).value; }} 通过使用 $event 作为方法的参数会将许多用不到的模板信息传递到组件中，导致我们在仅仅是为了获取数据的前提下，却需要对于页面元素十分了解，违背了模板（用户所能看到的）与组件（应用如何去处理用户数据）之间的关注点分类的原则。因此，这里应该使用模板引用变量的方式获取数据信息。 模板引用变量是对模板中 DOM 元素的引用，提供了从模块中直接访问元素的能力。 12&lt;input type=\"text\" #refMsgInput (keyup)=\"getRefMsg(refMsgInput.value)\"&gt;&lt;p&gt;通过模板引入变量的方式获取到输入的值：{{refMsg}}&lt;/p&gt; 123456789101112131415161718192021import { Component, OnInit } from '@angular/core';@Component({ selector: 'app-product-list', templateUrl: './product-list.component.html', styleUrls: ['./product-list.component.scss']})export class ProductListComponent implements OnInit { public refMsg: string; constructor() { } ngOnInit(): void { } getRefMes(msg: string) { this.refMsg = msg; }} 模板引用变量的作用域是整个模板，因此要确保一个模板中的引用变量名称是唯一的，同时，在声明引用变量时，也可以使用 ref- 代替 # 12&lt;input type=\"text\" ref-refMsgInput (keyup)=\"getRefMsg(refMsgInput.value)\"&gt;&lt;p&gt;通过模板引入变量的方式获取到输入的值：{{refMsg}}&lt;/p&gt; 指令属性型指令属性型指令被应用在视图 dom 元素上，用来改变 dom 元素的外观或行为 NgClass：用来设置元素的多个 css 类属性，如果只设置一个 css 类，应该使用模板绑定语法中 class 类绑定 1&lt;p [ngClass]=\"inlineStyle\"&gt;NgClass 属性指令&lt;/p&gt; 12345678910111213141516171819202122232425import { Component, OnInit } from '@angular/core';@Component({ selector: 'app-product-list', templateUrl: './product-list.component.html', styleUrls: ['./product-list.component.scss']})export class ProductListComponent implements OnInit { public inlineStyle: {}; constructor() { } ngOnInit(): void { this.setInlineStyle(); } setInlineStyle() { this.inlineStyle = { 'text-red': true, 'bg-blue': false, }; }} 这里的 text-red、bg-blue 都是 css 类名，如果想要在指定的元素上添加该类，则 css 类名对应的值为 true，反之则为 false NgStyle：用来设置元素的多个内联样式，如果只设置一个内联样式，应该使用模板绑定语法中的样式绑定 1&lt;p [ngStyle]=\"currentStyles\"&gt;NgStyle 属性指令&lt;/p&gt; 1234567891011121314151617181920212223242526import { Component, OnInit } from '@angular/core';@Component({ selector: 'app-product-list', templateUrl: './product-list.component.html', styleUrls: ['./product-list.component.scss']})export class ProductListComponent implements OnInit { public currentStyles: {}; constructor() { } ngOnInit(): void { this.setCurrentStyles(); } setCurrentStyles() { this.currentStyles = { 'font-style': 'italic', 'font-weight': 'bold', 'font-size': '24px' }; }} 通过在组件的属性中设置多个内联样式对象的形式，完成对于页面元素样式的批量设置 NgModel：双向数据绑定 1&lt;input type=&quot;text&quot; id=&quot;userName&quot; [(ngModel)]=&quot;name&quot;&gt; 结构型指令结构型指令用来操作 dom 树，通过进行一些的逻辑判断，从而完成对于页面布局的修改 NgIf：根据表达式的值（true or false）来创建或者销毁 dom 元素 1&lt;p *ngIf=\"expr\"&gt;NgIf 结构型指令&lt;/p&gt; 当 expr 属性为 true 时，这个元素则会显示在页面上，当属性值为 false 时，则不显示该元素 ngIf 指令并不是通过使用 css 样式来隐藏元素的，当值为 false 时，则这些元素会从 dom 中被销毁，并且所有监听该 dom 元素的事件会被取消，当重新显示该元素时，会重新执行初始化的过程 与销毁元素不同，对于隐藏的元素来说，所有的元素监听事件还会执行监听的，再次显示时不用重新进行初始化过程 NgFor：通过定义单条数据的显示格式，angular 以此为模板，循环渲染出所有的数据 1&lt;p *ngFor=\"let item of products; let i = index\"&gt;{{i+1}} - {{item.name}} --- {{item.price}}&lt;/p&gt; 1234567891011121314151617181920212223242526272829import { Component, OnInit } from '@angular/core';@Component({ selector: 'app-product-list', templateUrl: './product-list.component.html', styleUrls: ['./product-list.component.scss']})export class ProductListComponent implements OnInit { public products = [{ 'name': 'lalala', 'price': '$200' }, { 'name': 'hehehe', 'price': '$400' }, { 'name': 'wuwuwu', 'price': '$120' }, { 'name': 'xixi', 'price': '$570' }]; constructor() { } ngOnInit(): void { }} NgFor 指令上下文中的 index 属性在每次迭代中，会获取到条数据的索引值 当渲染的数据发生改变时 [^4]，会导致 dom 元素的重新渲染，此时可以采用 trackBy 的方式，通过在组件中添加一个方法，指定循环需要跟踪的属性值，此时当渲染的数据发生改变时，只会重新渲染变更了指定的属性值的数据 12345678910111213&lt;p&gt;不使用 trackBy 跟踪属性&lt;/p&gt;&lt;div&gt; &lt;p *ngFor=\"let item of products; let i = index;\"&gt; {{i+1}} - {{item.name}} --- {{item.price}} &lt;/p&gt;&lt;/div&gt;&lt;p&gt;使用 trackBy 跟踪属性&lt;/p&gt;&lt;div&gt; &lt;p *ngFor=\"let item of products; let i = index; trackBy: trackByIndex\"&gt; {{i+1}} - {{item.name}} --- {{item.price}} &lt;/p&gt;&lt;/div&gt;&lt;button (click)=\"addProduct()\"&gt;新增&lt;/button&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import { Component, OnInit } from '@angular/core';@Component({ selector: 'app-product-list', templateUrl: './product-list.component.html', styleUrls: ['./product-list.component.scss']})export class ProductListComponent implements OnInit { public products = [{ 'name': 'lalala', 'price': '$200' }, { 'name': 'hehehe', 'price': '$400' }, { 'name': 'wuwuwu', 'price': '$120' }, { 'name': 'xixi', 'price': '$570' }]; constructor() { } ngOnInit(): void { } trackByIndex(index: number, item: any): string { return item.price; } addProduct() { this.products = [{ 'name': 'lalala', 'price': '$200' }, { 'name': 'hehehe', 'price': '$400' }, { 'name': 'wuwuwu', 'price': '$120' }, { 'name': 'xixi', 'price': '$570' }, { 'name': 'lululu', 'price': '$' + (Math.random() * 100).toFixed() }]; }} NgSwitch：根据条件切换，从候选的几个元素中选择匹配的，放到 dom 元素中 123456789101112131415161718192021222324&lt;p&gt; 请选择配置 &lt;select [(ngModel)]=\"config\"&gt; &lt;option value=\"\"&gt;请选择&lt;/option&gt; &lt;option value=\"r7-3700x\"&gt;AMD Ryzen 7 3700X&lt;/option&gt; &lt;option value=\"i5-9400f\"&gt;Intel i5 9400F&lt;/option&gt; &lt;option value=\"i5-9600kf\"&gt;Intel i5 9600KF&lt;/option&gt; &lt;/select&gt;&lt;/p&gt;&lt;p&gt; 配置描述 &lt;/p&gt;&lt;div [ngSwitch]=\"config\"&gt; &lt;p *ngSwitchCase=\"'r7-3700x'\"&gt; 一个能打得都木的~~~ &lt;/p&gt; &lt;p *ngSwitchCase=\"'i5-9400f'\"&gt; 挤牙膏的。。。 &lt;/p&gt; &lt;p *ngSwitchCase=\"'i5-9600kf'\"&gt; 别看了，我不是开封菜。。。 &lt;/p&gt; &lt;p *ngSwitchDefault&gt; 你选一个啊~~~ &lt;/p&gt;&lt;/div&gt; 1234567891011121314151617import { Component, OnInit } from '@angular/core';@Component({ selector: 'app-product-list', templateUrl: './product-list.component.html', styleUrls: ['./product-list.component.scss']})export class ProductListComponent implements OnInit { public config = ''; constructor() { } ngOnInit(): void { }} NgSwitch 本身是一个属性型指令，它不会直接操作 dom 元素，而是通过它所控制的两个结构型指令（NgSwitchCase、ngSwitchDefault）来操作 dom 元素 管道在使用模板表达式绑定数据时，可以使用管道对于表达式的结果进行转换 管道是一种简单的函数，它们接受输入值并返回转换后的值。通过在模板表达式中使用管道运算符（|）则可以完成相应的结果转换 模板表达式中的特殊运算符angular 模板表达式是 javascript 的子集，相对于常见的 javascript 运算符，添加了三个特殊的运算符 管道运算符 管道是一种特殊的函数，可以把运算符（|）左边的数据转换成期望呈现给视图的数据格式，例如，将时间进行格式化、将数据转换成 json 字符串的形式等等 可以针对一个数据使用多个管道进行串联，并且管道运算符的优先级比三元运算符（ ?: ）高 12345&lt;h3&gt;5.1、管道运算符&lt;/h3&gt;&lt;div&gt; &lt;p&gt;产品信息 json 字符串&lt;/p&gt; {{products | json}}&lt;/div&gt; 安全导航运算符 在视图中使用的属性值为 null or undefined 时，javascript 和 angular 会引发空指针异常并中断视图的渲染过程， 从而视图会渲染失败，而使用了安全导航运算符（?）后，视图依然会渲染，只是显示的值为空白 12&lt;h3&gt;5.2、安全导航运算符&lt;/h3&gt;&lt;p&gt;第五个专案的名称为：{{products[5].name}}&lt;/p&gt; 1&lt;p&gt;第五个专案的名称为：{{products[5]?.name}}&lt;/p&gt; 非空断言运算符 在 tsconfig.json 中启用 strictNullChecks 属性，typescript 将会强制开启严格的空值检查，在这种模式下，所有定义了类型的属性是不允许赋值为 null 的，当将属性赋值为 null，则会编译报错 非空断言运算符用来告诉编译器对特定的属性不做严格的空值校验，当属性值为 null or undefined 时，不抛错误。在下面的代码中，在判断 obj 存在后，就不再针对 obj.name 进行校验 123456789101112131415161718192021222324import { Component, OnInit } from '@angular/core';interface Person { name: string; age: number; } @Component({ selector: 'app-product-list', templateUrl: './product-list.component.html', styleUrls: ['./product-list.component.scss'] }) export class ProductListComponent implements OnInit { public obj: Person; constructor() { } ngOnInit(): void { } } 123&lt;p *ngIf=\"obj\"&gt; &lt;span&gt;{{obj!.name}}&lt;/span&gt;&lt;/p&gt; 非空断言运算符不会防止出现 null 或 undefined，只是不提示 常用的管道函数 纯管道 只有在它检测到输入值发生了纯变更时才会执行，但是会忽略对象内部的变更 纯变更是指对原始类型值（String、Number、Boolean、Symbol）的更改， 或者对对象引用（Date、Array、Function、Object）的更改 非纯管道 每个组件的变更周期都会执行 管道 作用 JsonPipe 将一个值转换成 json 字符串 DatePipe 根据区域设置规则格式化日期值 UpperCasePipe 把文本转换成全大写形式 LowerCasePipe 把文本转换成全小写形式 1234567891011&lt;h3&gt;6.1、json 管道&lt;/h3&gt;&lt;p&gt;{{products | json}}&lt;/p&gt;&lt;h3&gt;6.2、date 管道&lt;/h3&gt;&lt;p&gt;现在时间：{{date | date:'yyyy-MM-dd HH:mm:ss'}}&lt;/p&gt;&lt;h3&gt;6.3、upper 管道&lt;/h3&gt;&lt;p&gt;转换成全大写：{{url | uppercase}}&lt;/p&gt;&lt;h3&gt;6.4、lower 管道&lt;/h3&gt;&lt;p&gt;转换成全小写：{{url | lowercase}}&lt;/p&gt; 组件之间的通信输入属性与输出属性输入属性（@Input）和输出属性（@Output）用来在父子组件或指令中进行共享数据。@Input 用来获取数据，@Output 用来向外发送数据 子组件获取父组件信息 在父组件中，添加对于子组件的引用，并将需要传递的数据 or 方法绑定到子组件上 传递数据直接将父组件中的属性值赋值给绑定在子组件上的属性就可以了 传递方法时，绑定在子组件上的属性是父组件方法的名称，此处不能加 () ，否则就会直接执行该父组件的方法 在传递数据给子组件时，也可以通过 this 来指代父组件，从而将整个父组件作为数据绑定子组件上 123456789101112131415&lt;h2&gt;父组件内容：&lt;/h2&gt;&lt;p&gt; &lt;label for=\"title\"&gt;标题：&lt;/label&gt; &lt;input id=\"title\" type=\"text\" [(ngModel)]=\"title\"&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;子组件内容：&lt;/h2&gt;&lt;!-- 将父组件的数据绑定到子组件上 --&gt;&lt;app-child-component [parentTitle]=\"title\" [parentGetMsg]='getMsg'&gt;&lt;/app-child-component&gt; 在子组件中引入 Inupt，同时使用 @Input 装饰器来接收父组件传递的数据 1234567891011121314151617181920212223242526272829303132// 引入 Input 接口import { Component, OnInit, Input } from '@angular/core';@Component({ selector: 'app-child-component', templateUrl: './child-component.component.html', styleUrls: ['./child-component.component.scss']})export class ChildComponentComponent implements OnInit { // 获取父组件的数据 @Input() parentGetMsg: any; // 使用 setter 对父组件的数据进行深加工 private _title: string; @Input() set parentTitle(title: string) { this._title = (title &amp;&amp; title.trim()) || '父组件的 title 属性值为空'; } get parentTitle(): string { return this._title; } constructor() { } ngOnInit(): void { } runParentFunc() { this.parentGetMsg(); }} 1234&lt;p&gt;父组件的 title 属性值：{{parentTitle}}&lt;/p&gt;&lt;p&gt; &lt;button (click)=\"runParentFunc()\"&gt;调用父组件的方法&lt;/button&gt;&lt;/p&gt; 对于使用 @Input 装饰器获取到的父组件数据，可以通过输入属性中的 setter 方法中进行重新赋值 父组件获取子组件信息 使用 @ViewChild 装饰器获取 在子组件上定义一个模板引用变量 1234567891011121314151617181920&lt;h2&gt;父组件内容：&lt;/h2&gt;&lt;h3&gt;1、使用 @ViewChild 装饰器获取子组件数据&lt;/h3&gt;&lt;p&gt; &lt;button (click)=\"getChildMsg()\"&gt;获取子组件的 msg 数据&lt;/button&gt;&lt;/p&gt;&lt;p&gt; &lt;button (click)=\"runChildFunc()\"&gt;调用子组件的方法&lt;/button&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;子组件内容：&lt;/h2&gt;&lt;!-- 在子组件上定义一个模板引用变量 --&gt;&lt;app-child-component #childComponent&gt;&lt;/app-child-component&gt; 在父组件中添加对于 ViewChild 的引用，然后使用 @ViewChild 装饰器来接收子组件的 dom 信息，从而获取到子组件的数据或方法 123456789101112131415161718192021222324252627// 引入 ViewChildimport { Component, OnInit, ViewChild } from '@angular/core';@Component({ selector: 'app-parent-component', templateUrl: './parent-component.component.html', styleUrls: ['./parent-component.component.scss']})export class ParentComponentComponent implements OnInit { // 通过 @ViewChild 装饰器来接收字组件的 dom 信息 @ViewChild('childComponent') child: any; constructor() { } ngOnInit(): void { } getMsg() { alert('我是父组件的 getMsg 方法'); } getChildMsg() { alert(this.child.msg); }} 使用 @Output 装饰器配合 EventEmitter 实现 在子组件中引入 Output 和 EventEmitter，通过 @Output 装饰器定义一个事件触发器，然后就可以通过这个事件触发器的 emit 方法进行事件广播 12345678910111213141516171819202122232425262728// 引入 Output、EventEmitterimport { Component, OnInit, Output, EventEmitter } from '@angular/core';@Component({ selector: 'app-child-component', templateUrl: './child-component.component.html', styleUrls: ['./child-component.component.scss']})export class ChildComponentComponent implements OnInit { public msg = 'child title'; // 定义一个事件触发器 @Output() childEmitter = new EventEmitter&lt;string&gt;(); constructor() { } ngOnInit(): void { } runParentFunc() { this.parentGetMsg(); } sendMsg() { this.childEmitter.emit(this.msg); }} 当子组件进行事件广播时，就可以通过在子组件上使用事件绑定的方式绑定到一个父组件事件，通过 $event 获取到子组件传递的数据值 1234567891011121314&lt;h2&gt;父组件内容：&lt;/h2&gt;&lt;h3&gt;2、使用 @Output 装饰器配合 EventEmitter 获取子组件数据&lt;/h3&gt;&lt;p&gt;{{childMsg}}&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;子组件内容：&lt;/h2&gt;&lt;!-- 将子组件的事件广播绑定到父组件事件上 --&gt;&lt;app-child-component (childEmitter)='childEmitMsg($event)'&gt;&lt;/app-child-component&gt; 123456789101112131415161718192021import { Component, OnInit } from '@angular/core';@Component({ selector: 'app-parent-component', templateUrl: './parent-component.component.html', styleUrls: ['./parent-component.component.scss']})export class ParentComponentComponent implements OnInit { public childMsg: string; constructor() { } ngOnInit(): void { } childEmitMsg(event) { this.childMsg = event; }} 非父子组件之间的通信不管组件之间是否具有关联关系，都可以通过共享一个服务的方式来进行数据交互，也可以将需要进行共享的数据存储到一些存储介质中，通过直接读取这个存储介质中的数据进行通信 创建一个服务，并添加到模块中 12## 在 services/storage 路径下创建一个 storage 服务ng g service services/storage/storage 123456789101112131415161718192021222324252627282930import { BrowserModule } from '@angular/platform-browser';import { NgModule } from '@angular/core';import { AppRoutingModule } from './app-routing.module';import { AppComponent } from './app.component';import { ProductListComponent } from './product-list/product-list.component';import { FormsModule } from '@angular/forms';import { ParentComponentComponent } from './parent-component/parent-component.component';import { ChildComponentComponent } from './child-component/child-component.component';// 引入自定义的服务import { StorageService } from './services/storage/storage.service';@NgModule({ declarations: [ AppComponent, ProductListComponent, ParentComponentComponent, ChildComponentComponent ], imports: [ BrowserModule, AppRoutingModule, FormsModule ], // 配置自定义的服务 providers: [StorageService], bootstrap: [AppComponent]})export class AppModule { } 在组件中使用服务 在需要使用的组件中引入服务，然后在组件的构造函数中通过依赖注入的方式注入这个服务，就可以在组件中完成对于这个服务的使用 在父组件中对数据进行赋值，然后调用服务的方法改变数据信息 12345678910111213141516171819202122232425import { Component, OnInit } from '@angular/core';// 引入服务import { StorageService } from '../services/storage/storage.service';@Component({ selector: 'app-parent-component', templateUrl: './parent-component.component.html', styleUrls: ['./parent-component.component.scss']})export class ParentComponentComponent implements OnInit { public msg = 'this is a service default value writen in parent component'; constructor(private storage: StorageService) { this.storage.setMsg(this.msg); } ngOnInit(): void { } submit() { this.storage.setMsg(this.msg); }} 1234567891011121314151617&lt;h2&gt;父组件内容：&lt;/h2&gt;&lt;h3&gt;3、通过服务在属性中共享数据&lt;/h3&gt;&lt;p&gt; 修改服务中的数据值 &lt;input type=\"text\" [(ngModel)]=\"msg\"&gt; &lt;button (click)=\"submit()\"&gt;提交&lt;/button&gt;&lt;/p&gt;&lt;p&gt;服务中的数据：{{msg}}&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;子组件内容：&lt;/h2&gt;&lt;app-child-component&gt;&lt;/app-child-component&gt; 在子组件中引入服务，从而同步获取到父组件修改后的服务中的数据信息 123456789101112131415161718192021222324import { Component, OnInit } from '@angular/core';// 引入服务import { StorageService } from '../services/storage/storage.service';@Component({ selector: 'app-child-component', templateUrl: './child-component.component.html', styleUrls: ['./child-component.component.scss']})export class ChildComponentComponent implements OnInit { public storageMsg: string; constructor(private storage: StorageService) { } ngOnInit(): void { } getServiceMsg() { this.storageMsg = this.storage.getMsg(); }} 1234&lt;button (click)=\"getServiceMsg()\"&gt;获取服务中的数据值&lt;/button&gt;&lt;p&gt; 服务中 msg 属性值：{{storageMsg}}&lt;/p&gt; 组件的生命周期钩子函数当 angular 在创建、更新、销毁组件时都会触发组件的生命周期钩子函数，通过在组件中实现这些生命周期函数，从而介入到这些关键时刻 钩子函数 触发时机 ngOnChanges 被绑定的输入属性值发生变化时触发，会调用多次；如果没有使用到父子组件传值，则不会触发 ngOnInit 初始化组件时会调用一次，一般是用来在构造函数之后执行组件复杂的初始化逻辑 ngDoCheck 只要数据发生改变就会被调用 ngAfterContentInit 组件内容渲染完成后调用一次 ngAfterContentChecked 只要组件的内容发生改变就会被调用 ngAfterViewInit 视图加载完成后触发一次，一般用来对视图的 dom 元素进行操作 ngAfterViewChecked 视图发生变化时调用，在组件的生命周期中会调用多次 ngOnDestroy 只在销毁组件时调用一次，一般用来在组件销毁前执行某些操作 在组件加载过程中，会按照上面列出的钩子函数顺序，在组件的构造函数执行之后依次执行，在页面加载过程中会涉及绑定数据的操作，因此会再次出发 ngDoCheck、ngAfterContentChecked、ngAfterViewChecked 这三个生命周期钩子函数。后续只要页面数据有发生改变，都会触发这几个事件 [^1]: 装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上，就像是 C# 中的特性 [^2]: 元数据是用来描述数据的数据项，例如这里的 selector 是为了描述 Component 这个数据信息资源中抽取出来用于说明其特征的一个结构化的数据 [^3]: property 是 dom 元素默认的基本属性，在 dom 初始化时会被全部创建，而 attribute 是 html 标签上定义的属性和值 =》DOM 中 Property 和 Attribute 的区别 [^4]: 这里的数据改变指的是会将原来的数据对象重新销毁然后重建的过程，因此像 push、unshift 这样的方法即使不添加 trackBy 也不会重新渲染整个 DOM，只会重新渲染改变的数据","link":"/2020/02/23/angular-components-guide/"},{"title":"Angular 从入坑到挖坑 - 表单控件概览","text":"Overviewangular 入坑记录的笔记第三篇，介绍 angular 中表单控件的相关概念，了解如何在 angular 中创建一个表单，以及如何针对表单控件进行数据校验。 对应官方文档地址： Angular 表单简介 响应式表单 模板驱动表单 表单验证 配套代码地址：angular-practice/src/forms-overview Contents Angular 从入坑到弃坑 - Angular 使用入门 Angular 从入坑到挖坑 - 组件食用指南 Angular 从入坑到挖坑 - 表单控件概览 Knowledge Graph Step by Step表单简介用来处理用户的输入，通过从视图中捕获用户的输入事件、验证用户输入的是否满足条件，从而创建出表单模型修改组件中的数据模型，达到获取用户输入数据的功能 模板驱动表单 响应式表单 建立表单 由组件隐式的创建表单控件实例 在组件类中进行显示的创建控件实例 表单验证 指令 函数 在表单数据发生变更时，模板驱动表单通过修改 ngModel 绑定的数据模型来完成数据更新，而响应式表单在表单数据发生变更时，FormControl 实例会返回一个新的数据模型，而不是直接修改原来的数据模型 模板驱动表单通过使用表单的专属指令（例如 ngModel 进行双向数据绑定）将数据值和一些对于用户的行为约束（某个字段必须填啊、某个字段长度超过了长度限制啊）绑定到组件的模板中，从而完成与用户的交互 模板驱动表单的双向数据绑定在根模块中引入 FormsModule，并添加到根模块的 imports 数组中 1234567891011121314151617181920212223242526import { BrowserModule } from '@angular/platform-browser';import { NgModule } from '@angular/core';// 引入 FormsModuleimport { FormsModule } from '@angular/forms';import { AppRoutingModule } from './app-routing.module';import { AppComponent } from './app.component';import { TemplateDrivenFormsComponent } from './template-driven-forms/template-driven-forms.component';@NgModule({ declarations: [ AppComponent, ReactiveFormsComponent, DynamicFormsComponent, TemplateDrivenFormsComponent ], imports: [ BrowserModule, AppRoutingModule, FormsModule // 添加到应用模块中 ], providers: [], bootstrap: [AppComponent]})export class AppModule { } 新建一个类文件，用来承载组件与模板之间进行双向数据绑定的数据信息 1ng g class classes/hero 123456789101112export class Hero { /** * ctor * @param name 姓名 * @param age 年纪 * @param gender 性别 * @param location 住址 */ constructor(public name: string, public age: number, public gender: string, public location: string) { }} 在组件的模板中创建承载数据的表单信息，并使用 ngModel 完成组件与模板之间的数据双向绑定 12345678910111213141516171819202122232425262728293031&lt;form&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"name\"&gt;姓名：&lt;/label&gt; &lt;input type=\"text\" name=\"name\" id=\"name\" [(ngModel)]=\"hero.name\" class=\"form-control\" autocomplete=\"off\" required minlength=\"4\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"age\"&gt;年龄：&lt;/label&gt; &lt;input type=\"number\" name=\"age\" id=\"age\" [(ngModel)]=\"hero.age\" class=\"form-control\" required&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"gender\"&gt;性别：&lt;/label&gt; &lt;div class=\"form-check\" *ngFor=\"let gender of genders\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" id=\"{{gender.id}}\" value=\"{{gender.value}}\" [(ngModel)]=\"hero.gender\"&gt; &lt;label class=\"form-check-label\" for=\"{{gender.id}}\"&gt; {{gender.text}} &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"location\"&gt;住址：&lt;/label&gt; &lt;select name=\"location\" id=\"location\" [(ngModel)]=\"hero.location\" class=\"form-control\" required&gt; &lt;option value=\"{{location}}\" *ngFor=\"let location of locations\"&gt;{{location}}&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;button type=\"submit\" (click)=\"submit()\" class=\"btn btn-primary\"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;p&gt; 表单的数据信息：{{hero | json}}&lt;/p&gt; 123456789101112131415161718192021222324252627282930313233import { Component, OnInit } from '@angular/core';import { Hero } from './../classes/hero';@Component({ selector: 'app-template-driven-forms', templateUrl: './template-driven-forms.component.html', styleUrls: ['./template-driven-forms.component.scss']})export class TemplateDrivenFormsComponent implements OnInit { constructor() { } // 性别选项 public genders = [{ id: 'male', text: '男', value: true }, { id: 'female', text: '女', value: false }]; /** * 住址下拉 */ public locations: Array&lt;string&gt; = ['beijing', 'shanghai', 'hangzhou', 'wuhan']; hero = new Hero('', 18, 'true', 'beijing'); ngOnInit(): void { } submit() { }} 在使用 ngModel 进行模板绑定时，angular 在 form 标签上自动附加了一个 NgForm 指令，因为 NgForm 指令会控制表单中带有 ngModel 指令和 name 属性的元素，而 name 属性则是 angular 用来注册控件的 key，所以在表单中使用 ngModel 进行双向数据绑定时，必须要添加 name 属性 跟踪表单控件的状态在表单中使用 ngModel 之后，NgModel 指令通过更新控件的 css 类，达到反映控件状态的目的 状态 发生时的 css 类 没发生的 css 类 控件被访问 ng-touched ng-untouched 控件的值发生变化 ng-dirty ng-pristine 控件的值是否有效 ng-valid ng-invalid 通过这些控件的 css 类样式，就可以通过添加自定义的 css 样式在用户输入内容不满足条件时进行提示 1234567.ng-valid[required], .ng-valid.required { border-left: 5px solid #42A948; /* green */}.ng-invalid:not(form) { border-left: 5px solid #a94442; /* red */} 数据的有效性验证某些时候需要对于用户输入的信息做有效性验证，此时可以在控件上添加上原生的 HTML 表单验证器来设定验证条件，当表单控件的数据发生变化时，angular 会通过指令的方式对数据进行验证，从而生成错误信息列表 在进行用户输入数据有效性验证时，在控件上通过添加一个模板引用变量来暴露出 ngModel，从而在模板中获取到指定控件的状态信息，之后就可以通过获取错误信息列表来进行反馈 12345678910111213141516171819&lt;div class=\"form-group\"&gt; &lt;label for=\"name\"&gt;姓名：&lt;/label&gt; &lt;!-- 将 ngModel 指令通过模板引用变量的形式暴露出来，从而获取到控件的状态 --&gt; &lt;input type=\"text\" name=\"name\" id=\"name\" [(ngModel)]=\"hero.name\" class=\"form-control\" autocomplete=\"off\" required minlength=\"4\" #name=\"ngModel\"&gt; &lt;!-- 在用户有改动数据 or 访问控件之后才对数据的有效性进行验证 --&gt; &lt;div *ngIf=\"name.invalid &amp;&amp; (name.dirty || name.touched)\" class=\"alert alert-danger\"&gt; &lt;div *ngIf=\"name.errors.required\"&gt; 姓名不能为空 &lt;/div&gt; &lt;div *ngIf=\"name.errors.minlength\"&gt; 姓名信息不能少于 4 个字符长度 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 在数据验证失败的情况下，对于系统来说，表单是不允许提交的，因此可以将提交事件绑定到表单的 ngSubmit 事件属性上，通过模板引用变量的形式，在提交按钮处进行数据有效性判断，当无效时，禁用表单的提交按钮 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;form (ngSubmit)=\"submit()\" #heroForm=\"ngForm\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"name\"&gt;姓名：&lt;/label&gt; &lt;!-- 将 ngModel 指令通过模板引用变量的形式暴露出来，从而获取到控件的状态 --&gt; &lt;input type=\"text\" name=\"name\" id=\"name\" [(ngModel)]=\"hero.name\" class=\"form-control\" autocomplete=\"off\" required minlength=\"4\" #name=\"ngModel\"&gt; &lt;!-- 在用户有改动数据 or 访问控件之后才对数据的有效性进行验证 --&gt; &lt;div *ngIf=\"name.invalid &amp;&amp; (name.dirty || name.touched)\" class=\"alert alert-danger\"&gt; &lt;div *ngIf=\"name.errors.required\"&gt; 姓名不能为空 &lt;/div&gt; &lt;div *ngIf=\"name.errors.minlength\"&gt; 姓名信息不能少于 4 个字符长度 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"age\"&gt;年龄：&lt;/label&gt; &lt;input type=\"number\" name=\"age\" id=\"age\" [(ngModel)]=\"hero.age\" class=\"form-control\" required&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"gender\"&gt;性别：&lt;/label&gt; &lt;div class=\"form-check\" *ngFor=\"let gender of genders\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" id=\"{{gender.id}}\" value=\"{{gender.value}}\" [(ngModel)]=\"hero.gender\"&gt; &lt;label class=\"form-check-label\" for=\"{{gender.id}}\"&gt; {{gender.text}} &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"location\"&gt;住址：&lt;/label&gt; &lt;select name=\"location\" id=\"location\" [(ngModel)]=\"hero.location\" class=\"form-control\" required&gt; &lt;option value=\"{{location}}\" *ngFor=\"let location of locations\"&gt;{{location}}&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;button type=\"submit\" [disabled]=\"!heroForm.form.valid\" class=\"btn btn-primary\"&gt;Submit&lt;/button&gt;&lt;/form&gt; 响应式表单快速上手响应式表单依赖于 ReactiveFormsModule 模块，因此在使用前需要在根模块中引入 1234567891011121314151617181920212223242526import { BrowserModule } from '@angular/platform-browser';import { NgModule } from '@angular/core';// 引入 ReactiveFormsModuleimport { ReactiveFormsModule } from '@angular/forms';import { AppRoutingModule } from './app-routing.module';import { AppComponent } from './app.component';import { ReactiveFormsComponent } from './reactive-forms/reactive-forms.component';@NgModule({ declarations: [ AppComponent, ReactiveFormsComponent, DynamicFormsComponent, TemplateDrivenFormsComponent ], imports: [ BrowserModule, AppRoutingModule, ReactiveFormsModule // 添加到应用模块中 ], providers: [], bootstrap: [AppComponent]})export class AppModule { } 在使用响应式表单时，一个 FormControl 类的实例对应于一个表单控件，在使用时，通过将控件的实例赋值给属性，后续则可以通过监听这个自定义的属性来跟踪表单控件的值和状态 123456789101112131415161718192021import { Component, OnInit } from '@angular/core';// 引入 FormControl 对象import { FormControl } from '@angular/forms';@Component({ selector: 'app-reactive-forms', templateUrl: './reactive-forms.component.html', styleUrls: ['./reactive-forms.component.scss']})export class ReactiveFormsComponent implements OnInit { // 定义属性用来承接 FormControl 实例 public name = new FormControl(''); constructor() { } ngOnInit(): void { }} 当在组件中创建好控件实例后，通过给视图模板上的表单控件添加 formControl 属性绑定，从而将控件实例与模板中的表单控件关联起来 1234567891011&lt;form&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"name\"&gt;姓名：&lt;/label&gt; &lt;input type=\"text\" id=\"name\" [formControl]='name' class=\"form-control\" autocomplete=\"off\"&gt; &lt;/div&gt;&lt;/form&gt;&lt;div&gt; name 控件的数据值： {{ name | json }}&lt;/div&gt; 通过使用 FormControl 控件的 value 属性，可以获得当前表单控件的一份数据值拷贝，通过 setValue 方法则可以更新表单的控件值 12345678910111213141516171819202122232425262728import { Component, OnInit } from '@angular/core';// 引入 FormControl 对象import { FormControl } from '@angular/forms';@Component({ selector: 'app-reactive-forms', templateUrl: './reactive-forms.component.html', styleUrls: ['./reactive-forms.component.scss']})export class ReactiveFormsComponent implements OnInit { // 定义属性用来承接 FormControl 实例 public name = new FormControl('12345'); constructor() { } ngOnInit(): void { } getName() { alert(this.name.value); } setName() { this.name.setValue(1111111); }} 通过 FomGroup 组合多个控件一个表单不可能只有一个控件，通过在组件中构造 FormGroup 实例来完成对于多个表单控件的统一管理 在使用 FormGroup 时，同样在组件中定义一个属性用来承载控件组实例，然后将控件组中的每一个控件作为属性值添加到实例中 1234567891011121314151617181920212223import { Component, OnInit } from '@angular/core';// 引入 FormControl 和 FormGroup 对象import { FormControl, FormGroup } from '@angular/forms';@Component({ selector: 'app-reactive-forms', templateUrl: './reactive-forms.component.html', styleUrls: ['./reactive-forms.component.scss']})export class ReactiveFormsComponent implements OnInit { // 定义对象属性来承接 FormGroup 实例 public profileForm = new FormGroup({ name: new FormControl('啦啦啦'), age: new FormControl(12) }); constructor() { } ngOnInit(): void { }} 在视图模板中，将承接 FormGroup 实例的属性通过 formGroup 指令绑定到 form 元素，然后将控件组的每一个属性通过 formControlName 绑定到具体对应的表单控件上 123456789101112131415&lt;form [formGroup]='profileForm'&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"name\"&gt;姓名：&lt;/label&gt; &lt;input type=\"text\" id=\"name\" formControlName='name' class=\"form-control\" autocomplete=\"off\" required minlength=\"4\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"age\"&gt;年龄：&lt;/label&gt; &lt;input type=\"number\" id=\"age\" formControlName='age' class=\"form-control\" autocomplete=\"off\" required step=\"1\" max=\"100\" min=\"1\"&gt; &lt;/div&gt;&lt;/form&gt;&lt;div&gt; FormGroup 表单组控件的值： {{ profileForm.value | json }}&lt;/div&gt; 当构建复杂表单时，可以在 FormGroup 中通过嵌套 FormGroup 使表单的结构更合理 123456789101112131415161718192021222324252627282930313233import { Component, OnInit } from '@angular/core';// 引入 FormControl 和 FormGroup 对象import { FormControl, FormGroup } from '@angular/forms';@Component({ selector: 'app-reactive-forms', templateUrl: './reactive-forms.component.html', styleUrls: ['./reactive-forms.component.scss']})export class ReactiveFormsComponent implements OnInit { // 定义对象属性来承接 FormGroup 实例 public profileForm = new FormGroup({ name: new FormControl('啦啦啦'), age: new FormControl(12), address: new FormGroup({ province: new FormControl('北京市'), city: new FormControl('北京'), district: new FormControl('朝阳区'), street: new FormControl('三里屯街道') }) }); constructor() { } ngOnInit(): void { } submit() { alert(JSON.stringify(this.profileForm.value)); }} 在视图模板中，通过使用 formGroupName 属性将 FormGroup 控件组中的 FormGroup 实例绑定到控件上 123456789101112131415161718192021222324252627282930313233343536&lt;form [formGroup]='profileForm' (ngSubmit)='submit()'&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"name\"&gt;姓名：&lt;/label&gt; &lt;input type=\"text\" id=\"name\" formControlName='name' class=\"form-control\" autocomplete=\"off\" required minlength=\"4\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"age\"&gt;年龄：&lt;/label&gt; &lt;input type=\"number\" id=\"age\" formControlName='age' class=\"form-control\" autocomplete=\"off\" required step=\"1\" max=\"100\" min=\"1\"&gt; &lt;/div&gt; &lt;div formGroupName='address'&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"province\"&gt;省：&lt;/label&gt; &lt;input type=\"text\" id=\"province\" formControlName='province' class=\"form-control\" autocomplete=\"off\" required&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"city\"&gt;市：&lt;/label&gt; &lt;input type=\"text\" id=\"city\" formControlName='city' class=\"form-control\" autocomplete=\"off\" required&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"district\"&gt;区：&lt;/label&gt; &lt;input type=\"text\" id=\"district\" formControlName='district' class=\"form-control\" autocomplete=\"off\" required&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"street\"&gt;街道：&lt;/label&gt; &lt;input type=\"text\" id=\"street\" formControlName='street' class=\"form-control\" autocomplete=\"off\" required&gt; &lt;/div&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\" [disabled]=\"!profileForm.valid\"&gt;数据提交&lt;/button&gt;&lt;/form&gt;&lt;div&gt; FormGroup 表单组控件的值： {{ profileForm.value | json }}&lt;/div&gt; 对于使用了 FormGroup 的表单来说，当使用 setValue 进行数据更新时，必须保证新的数据结构与原来的结构相同，否则就会报错 123456789101112131415161718192021222324252627282930313233343536373839import { Component, OnInit } from '@angular/core';// 引入 FormControl 和 FormGroup 对象import { FormControl, FormGroup } from '@angular/forms';@Component({ selector: 'app-reactive-forms', templateUrl: './reactive-forms.component.html', styleUrls: ['./reactive-forms.component.scss']})export class ReactiveFormsComponent implements OnInit { // 定义对象属性来承接 FormGroup 实例 public profileForm = new FormGroup({ name: new FormControl('啦啦啦'), age: new FormControl(12), address: new FormGroup({ province: new FormControl('北京市'), city: new FormControl('北京'), district: new FormControl('朝阳区'), street: new FormControl('三里屯街道') }) }); constructor() { } ngOnInit(): void { } submit() { alert(JSON.stringify(this.profileForm.value)); } updateProfile() { this.profileForm.setValue({ name: '423' }); }} 某些情况下，我们只是想要更新控件组中的某个控件的数据值，这时需要使用 patchValue 的方式进行更新 123456789101112131415161718192021222324252627282930313233343536373839import { Component, OnInit } from '@angular/core';// 引入 FormControl 和 FormGroup 对象import { FormControl, FormGroup } from '@angular/forms';@Component({ selector: 'app-reactive-forms', templateUrl: './reactive-forms.component.html', styleUrls: ['./reactive-forms.component.scss']})export class ReactiveFormsComponent implements OnInit { // 定义对象属性来承接 FormGroup 实例 public profileForm = new FormGroup({ name: new FormControl('啦啦啦'), age: new FormControl(12), address: new FormGroup({ province: new FormControl('北京市'), city: new FormControl('北京'), district: new FormControl('朝阳区'), street: new FormControl('三里屯街道') }) }); constructor() { } ngOnInit(): void { } submit() { alert(JSON.stringify(this.profileForm.value)); } updateProfile() { this.profileForm.patchValue({ name: '12345' }); }} 使用 FormBuilder 生成表单控件当控件过多时，通过 FormGroup or FormControl 手动的构建表单控件的方式会很麻烦，因此这里可以通过依赖注入 FormBuilder 类的方式来简化的完成表单的构建 FormBuilder 服务有三个方法：control、group 和 array，用于在组件类中分别生成 FormControl、FormGroup 和 FormArray 使用 FormBuilder 构建的控件，每个控件名对应的值都是一个数组，第一个值为控件的默认值，第二项和第三项则是针对这个值设定的同步、异步验证方法 1234567891011121314151617181920212223242526272829303132import { Component, OnInit } from '@angular/core';// 引入 FormBuilder 构建表单控件import { FormBuilder } from '@angular/forms';@Component({ selector: 'app-reactive-forms', templateUrl: './reactive-forms.component.html', styleUrls: ['./reactive-forms.component.scss']})export class ReactiveFormsComponent implements OnInit { /** * ctor * @param formBuilder 表单构造器 */ constructor(private formBuilder: FormBuilder) { } public profileForm = this.formBuilder.group({ name: ['啦啦啦'], age: [12], address: this.formBuilder.group({ province: ['北京市'], city: ['北京'], district: ['朝阳区'], street: ['三里屯街道'] }) }); ngOnInit(): void { }} 数据的有效性验证同模板驱动表单的数据有效性验证相同，在响应式表单中同样可以使用原生的表单验证器，在设定规则时，需要将模板中控件名对应的数据值的第二个参数改为验证的规则 在响应式表单中，数据源来源于组件类，因此应该在组件类中直接把验证器函数添加到对应的 FormControl 的构造函数上。然后，一旦控件数据发生了变化，angular 就会调用这些函数 这里创建针对指定控件的 getter 方法，从而在模板中通过此方法来获取到指定控件的状态信息 12345678910111213141516171819202122232425262728293031323334353637383940414243import { Component, OnInit } from '@angular/core';// 引入 FormBuilder 构建表单控件import { FormBuilder } from '@angular/forms';// 引入 Validators 验证器import { Validators } from '@angular/forms';@Component({ selector: 'app-reactive-forms', templateUrl: './reactive-forms.component.html', styleUrls: ['./reactive-forms.component.scss']})export class ReactiveFormsComponent implements OnInit { /** * ctor * @param formBuilder 表单构造器 */ constructor(private formBuilder: FormBuilder) { } public profileForm = this.formBuilder.group({ name: ['', [ Validators.required, Validators.minLength(4) ]], age: [12], address: this.formBuilder.group({ province: ['北京市'], city: ['北京'], district: ['朝阳区'], street: ['三里屯街道'] }) }); // 添加需要验证控件 getter 方法，用来在模板中获取状态值 get name() { return this.profileForm.get('name'); } ngOnInit(): void { }} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;form [formGroup]='profileForm' (ngSubmit)='submit()'&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"name\"&gt;姓名：&lt;/label&gt; &lt;input type=\"text\" id=\"name\" formControlName='name' class=\"form-control\" autocomplete=\"off\" required minlength=\"4\"&gt; &lt;!-- 在用户有改动数据 or 访问控件之后才对数据的有效性进行验证 --&gt; &lt;div *ngIf=\"name.invalid &amp;&amp; (name.dirty || name.touched)\" class=\"alert alert-danger\"&gt; &lt;div *ngIf=\"name.errors.required\"&gt; 姓名不能为空 &lt;/div&gt; &lt;div *ngIf=\"name.errors.minlength\"&gt; 姓名信息不能少于 4 个字符长度 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"age\"&gt;年龄：&lt;/label&gt; &lt;input type=\"number\" id=\"age\" formControlName='age' class=\"form-control\" autocomplete=\"off\" required step=\"1\" max=\"100\" min=\"1\"&gt; &lt;/div&gt; &lt;div formGroupName='address'&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"province\"&gt;省：&lt;/label&gt; &lt;input type=\"text\" id=\"province\" formControlName='province' class=\"form-control\" autocomplete=\"off\" required&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"city\"&gt;市：&lt;/label&gt; &lt;input type=\"text\" id=\"city\" formControlName='city' class=\"form-control\" autocomplete=\"off\" required&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"district\"&gt;区：&lt;/label&gt; &lt;input type=\"text\" id=\"district\" formControlName='district' class=\"form-control\" autocomplete=\"off\" required&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"street\"&gt;街道：&lt;/label&gt; &lt;input type=\"text\" id=\"street\" formControlName='street' class=\"form-control\" autocomplete=\"off\" required&gt; &lt;/div&gt; &lt;/div&gt; &lt;button type=\"button\" class=\"btn btn-primary\" (click)=\"updateProfile()\"&gt;更新信息&lt;/button&gt; &amp;nbsp; &lt;button type=\"submit\" class=\"btn btn-primary\" [disabled]=\"!profileForm.valid\"&gt;数据提交&lt;/button&gt;&lt;/form&gt;&lt;div&gt; FormGroup 表单组控件的值： {{ profileForm.value | json }}&lt;/div&gt; 表单的自定义数据验证自定义验证器在很多的情况下，原生的验证规则无法满足我们的需要，此时需要创建自定义的验证器来实现 对于响应式表单，我们可以定义一个方法，对控件的数据进行校验，之后将方法作为参数添加到控件定义处即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import { Component, OnInit } from '@angular/core';// 引入 FormBuilder 构建表单控件import { FormBuilder } from '@angular/forms';// 引入 Validators 验证器import { Validators } from '@angular/forms';/** * 自定义验证方法 * @param name 控件信息 */function validatorName(name: FormControl) { return name.value === 'lala' ? { nameinvalid: true } : null;}@Component({ selector: 'app-reactive-forms', templateUrl: './reactive-forms.component.html', styleUrls: ['./reactive-forms.component.scss']})export class ReactiveFormsComponent implements OnInit { /** * ctor * @param formBuilder 表单构造器 */ constructor(private formBuilder: FormBuilder) { } public profileForm = this.formBuilder.group({ name: ['', [ Validators.required, Validators.minLength(4), validatorName // 添加自定义验证方法 ]], age: [12], address: this.formBuilder.group({ province: ['北京市'], city: ['北京'], district: ['朝阳区'], street: ['三里屯街道'] }) }); // 添加需要验证控件 getter 方法，用来在模板中获取状态值 get name() { return this.profileForm.get('name'); } ngOnInit(): void { }} 在验证方法中，当数据有效时，返回 null，当数据无效时，则会返回一个对象信息，这里的 nameinvalid 就是我们在模板中获取到的错误信息的 key 值 12345678910111213141516171819&lt;div class=\"form-group\"&gt; &lt;label for=\"name\"&gt;姓名：&lt;/label&gt; &lt;input type=\"text\" id=\"name\" formControlName='name' class=\"form-control\" autocomplete=\"off\" required minlength=\"4\"&gt; &lt;!-- 在用户有改动数据 or 访问控件之后才对数据的有效性进行验证 --&gt; &lt;div *ngIf=\"name.invalid &amp;&amp; (name.dirty || name.touched)\" class=\"alert alert-danger\"&gt; &lt;div *ngIf=\"name.errors.required\"&gt; 姓名不能为空 &lt;/div&gt; &lt;div *ngIf=\"name.errors.minlength\"&gt; 姓名信息不能少于 4 个字符长度 &lt;/div&gt; &lt;div *ngIf=\"name.errors.nameinvalid\"&gt; 姓名无效 &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 在模板驱动表单中，因为不是直接使用的 FormControl 实例，因此这里应该在模板上添加一个自定义的指令来完成对于控件数据的校验 使用 angular cli 创建一个用来进行表单验证的指令 1ng g directive direactives/hero-validate 在创建完成指令之后，我们需要将这个指令将该验证器添加到已经存在的验证器集合中，同时为了使这个指令可以与 angular 表单集成在一起，我们需要继承 Validator 接口 1234567891011121314151617181920import { Directive, Input } from '@angular/core';import { AbstractControl, Validator, ValidationErrors, NG_VALIDATORS } from '@angular/forms';@Directive({ selector: '[appHeroValidate]', // 将指令注册到 NG_VALIDATORS 使用 multi: true 将该验证器添加到现存的验证器集合中 providers: [{ provide: NG_VALIDATORS, useExisting: HeroValidateDirective, multi: true }]})export class HeroValidateDirective implements Validator { constructor() { } /** * 对指定的控件执行同步验证方法 * @param control 控件 */ validate(control: AbstractControl): ValidationErrors | null { return control.value === 'lala' ? { 'nameInvalid': true } : null; }} 当实现了继承的 validate 方法后，就可以在模板的控件上添加该指令 12345678910111213141516171819202122&lt;div class=\"form-group\"&gt; &lt;label for=\"name\"&gt;姓名：&lt;/label&gt; &lt;!-- 将 ngModel 指令通过模板引用变量的形式暴露出来，从而获取到控件的状态 --&gt; &lt;input type=\"text\" name=\"name\" id=\"name\" [(ngModel)]=\"hero.name\" class=\"form-control\" autocomplete=\"off\" required minlength=\"4\" #name=\"ngModel\" appHeroValidate&gt; &lt;!-- 在用户有改动数据 or 访问控件之后才对数据的有效性进行验证 --&gt; &lt;div *ngIf=\"name.invalid &amp;&amp; (name.dirty || name.touched)\" class=\"alert alert-danger\"&gt; &lt;div *ngIf=\"name.errors.required\"&gt; 姓名不能为空 &lt;/div&gt; &lt;div *ngIf=\"name.errors.minlength\"&gt; 姓名信息不能少于 4 个字符长度 &lt;/div&gt; &lt;div *ngIf=\"name.errors.nameInvalid\"&gt; 姓名无效 &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 跨字段的交叉验证有时候需要针对表单中的多个控件数据进行交叉验证，此时就需要针对整个 FormGroup 进行验证。因此这里的验证方法需要在定义控件组时作为 FormGroup 的参数传入 与单个字段的验证方式相似，通过实现 ValidatorFn 接口，当表单数据有效时，它返回一个 null，否则返回 ValidationErrors 对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import { Component, OnInit } from '@angular/core';// 引入 FormControl 和 FormGroup 对象import { FormControl, FormGroup, ValidatorFn, ValidationErrors } from '@angular/forms';// 引入 FormBuilder 构建表单控件import { FormBuilder } from '@angular/forms';// 引入 Validators 验证器import { Validators } from '@angular/forms';/** * 跨字段验证 * @param controlGroup 控件组 */const nameAgeCrossValidator: ValidatorFn = (controlGroup: FormGroup): ValidationErrors | null =&gt; { // 获取子控件的信息 // const name = controlGroup.get('name'); const age = controlGroup.get('age'); return name &amp;&amp; age &amp;&amp; name.value === 'lala' &amp;&amp; age.value === 12 ? { 'nameAgeInvalid': true } : null;};@Component({ selector: 'app-reactive-forms', templateUrl: './reactive-forms.component.html', styleUrls: ['./reactive-forms.component.scss']})export class ReactiveFormsComponent implements OnInit { /** * ctor * @param formBuilder 表单构造器 */ constructor(private formBuilder: FormBuilder) { } public profileForm = this.formBuilder.group({ name: ['', [ Validators.required, Validators.minLength(4), validatorName ]], age: [12], address: this.formBuilder.group({ province: ['北京市'], city: ['北京'], district: ['朝阳区'], street: ['三里屯街道'] }) }, { validators: [nameAgeCrossValidator] }); // 添加针对控件组的验证器 ngOnInit(): void { }} 在针对多个字段进行交叉验证时，在模板页面中，则需要通过获取整个表单的错误对象信息来获取到交叉验证的错误信息 12345678910111213141516171819202122232425262728&lt;div class=\"form-group\"&gt; &lt;label for=\"name\"&gt;姓名：&lt;/label&gt; &lt;input type=\"text\" id=\"name\" formControlName='name' class=\"form-control\" autocomplete=\"off\" required minlength=\"4\"&gt; &lt;!-- 在用户有改动数据 or 访问控件之后才对数据的有效性进行验证 --&gt; &lt;div *ngIf=\"name.invalid &amp;&amp; (name.dirty || name.touched)\" class=\"alert alert-danger\"&gt; &lt;div *ngIf=\"name.errors.required\"&gt; 姓名不能为空 &lt;/div&gt; &lt;div *ngIf=\"name.errors.minlength\"&gt; 姓名信息不能少于 4 个字符长度 &lt;/div&gt; &lt;div *ngIf=\"name.errors.nameinvalid\"&gt; 姓名无效 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"age\"&gt;年龄：&lt;/label&gt; &lt;input type=\"number\" id=\"age\" formControlName='age' class=\"form-control\" autocomplete=\"off\" required step=\"1\" max=\"100\" min=\"1\"&gt; &lt;div *ngIf=\"profileForm.errors?.nameAgeInvalid &amp;&amp; (profileForm.touched || profileForm.dirty)\" class=\"alert alert-danger\"&gt; lala 不能是 12 岁 &lt;/div&gt;&lt;/div&gt; 对于模板驱动表单，同样是采用自定义指令的方式进行跨字段的交叉验证，与单个控件的验证不同，此时需要将指令添加到 form 标签上，然后使用模板引用变量来获取错误信息 1234567891011121314151617181920212223242526272829import { Directive } from '@angular/core';import { Validator, AbstractControl, ValidationErrors, ValidatorFn, FormGroup, NG_VALIDATORS } from '@angular/forms';/** * 跨字段验证 * @param controlGroup 控件组 */const nameAgeCrossValidator: ValidatorFn = (controlGroup: FormGroup): ValidationErrors | null =&gt; { // 获取子控件的信息 // const name = controlGroup.get('name'); const age = controlGroup.get('age'); return name &amp;&amp; age &amp;&amp; name.value === 'lala' &amp;&amp; age.value === 12 ? { 'nameAgeInvalid': true } : null;};@Directive({ selector: '[appCrossFieldValidate]', providers: [{ provide: NG_VALIDATORS, useExisting: CrossFieldValidateDirective, multi: true }]})export class CrossFieldValidateDirective implements Validator { constructor() { } validate(control: AbstractControl): ValidationErrors | null { return nameAgeCrossValidator(control); }}","link":"/2020/03/04/angular-forms-overview/"},{"title":"Angular 从入坑到挖坑 - HTTP 请求概览","text":"Overviewangular 入坑记录的笔记第四篇，介绍在 angular 中如何通过 HttpClient 类发起 http 请求，从而完成与后端的数据交互。 对应官方文档地址： Angular HttpClient 配套代码地址：angular-practice/src/http-guide Contents Angular 从入坑到弃坑 - Angular 使用入门 Angular 从入坑到挖坑 - 组件食用指南 Angular 从入坑到挖坑 - 表单控件概览 Angular 从入坑到挖坑 - HTTP 请求概览 Knowledge Graph Step by Step与后端进行数据交互前置工作在前端项目与后端进行数据交互时，绝大多数都是通过 HTTP 协议进行的，现代浏览器支持两种方式向后端发起 HTTP 请求：XMLHttpRequest 和 fetch 在以前的项目中，通常使用 jquery 的简化版 ajax 请求向后端请求数据，归根到底最终还是通过 XMLHttpRequest 与后端进行数据交互 在 Angular 中， 为了简化 XMLHttpRequest 的使用，框架提供了 HttpClient 类来封装 HTTP API，用来实现前端与后端的数据交互。 在使用之前，首先需要在应用的根模块中，引入 HttpClientModule 模块，并添加到 imports 数组中 12345678910111213141516171819202122import { BrowserModule } from '@angular/platform-browser';import { NgModule } from '@angular/core';import { AppRoutingModule } from './app-routing.module';import { AppComponent } from './app.component';// 添加对于 HttpClientModule 模块的引用import { HttpClientModule } from '@angular/common/http';@NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, AppRoutingModule, HttpClientModule // 添加到根应用模块中 ], providers: [], bootstrap: [AppComponent]})export class AppModule { } 在需要使用到的地方，引入 HttpClient 类，然后通过依赖注入的方式注入到应用类中 在通常情况下，我们需要将与后端进行交互的行为封装成服务，在这个服务中完成对于获取到的数据的处理，之后再注入到需要使用该服务的组件中，从而确保组件中仅仅包含的是必要的业务逻辑行为 12345678910111213import { Injectable } from '@angular/core';// 引入 HttpClient 类import { HttpClient } from '@angular/common/http';@Injectable({ providedIn: 'root'})export class AntiMotivationalQuotesServicesService { // 通过构造函数注入的方式依赖注入到使用的类中 constructor(private http: HttpClient) { }} 12345678910111213141516171819import { Component, OnInit } from '@angular/core';// 引入服务import { AntiMotivationalQuotesServicesService } from './../services/anti-motivational-quotes-services.service';@Component({ selector: 'app-anti-motivational-quotes', templateUrl: './anti-motivational-quotes.component.html', styleUrls: ['./anti-motivational-quotes.component.scss']})export class AntiMotivationalQuotesComponent implements OnInit { // 通过构造函数注入的方式使用服务 constructor(private services: AntiMotivationalQuotesServicesService) { } ngOnInit(): void { }} 从服务端获取数据这里使用到的后端接口是掘金上一位朋友开发的毒鸡汤接口（https://api.tryto.cn/djt/text），所有权归属于小咸鱼丶 通过使用 postman 进行接口调用可以发现，接口返回的响应信息如下 在项目中创建一个接口，按照后端返回的数据信息进行属性的定义，用来映射请求的响应信息（Angular 只能将请求响应对象转换成接口类型，不能自动转换成类实例） 1ng g interface interfaces/get-quotes-response-model 1234567891011121314151617181920212223242526272829303132export interface GetQuotesResponseModel { /** * 接口响应码 */ code: number; /** * 响应信息 */ msg: string; /** * 响应数据 */ data: ResponseData; /** * 响应时间 */ time: number;}/** * 接口响应的内容信息 */interface ResponseData { /** * 毒鸡汤 */ content: string; /** * 热度 */ hots: number;} 在服务中，引入请求响应对象的接口定义，然后设定 get 请求的响应对象为 GetQuotesResponseModel，之后在使用时就可以以一种结构化数据的方式获取请求返回的数据信息 12345678910111213141516171819202122232425import { Injectable } from '@angular/core';import { Observable } from 'rxjs';// 引入 HttpClient 类import { HttpClient } from '@angular/common/http';// 引入接口响应类import { GetQuotesResponseModel } from '../interfaces/get-quotes-response-model';@Injectable({ providedIn: 'root'})export class AntiMotivationalQuotesServicesService { // 通过构造函数注入的方式依赖注入到使用的类中 constructor(private http: HttpClient) { } /** * 通过 get 请求获取毒鸡汤信息 */ getAntiMotivationalQuotes(): Observable&lt;GetQuotesResponseModel&gt; { const url = 'https://api.tryto.cn/djt/text'; return this.http.get&lt;GetQuotesResponseModel&gt;(url); }} 在组件中，通过调用注入的服务类完成接口数据的获取，因为是以一种结构化对象的形式获取到接口返回的数据，因此这里可以直接通过对象属性获取到指定的属性信息 1234567891011121314151617181920212223242526272829303132import { Component, OnInit } from '@angular/core';// 引入服务import { AntiMotivationalQuotesServicesService } from './../services/anti-motivational-quotes-services.service';// 引入接口响应对象import { GetQuotesResponseModel } from '../interfaces/get-quotes-response-model';@Component({ selector: 'app-anti-motivational-quotes', templateUrl: './anti-motivational-quotes.component.html', styleUrls: ['./anti-motivational-quotes.component.scss']})export class AntiMotivationalQuotesComponent implements OnInit { public quoteResponse: GetQuotesResponseModel; // 通过构造函数注入的方式使用服务 constructor(private services: AntiMotivationalQuotesServicesService) { } ngOnInit(): void { } /** * 获取毒鸡汤 */ getQuotes() { this.services.getAntiMotivationalQuotes().subscribe((response: GetQuotesResponseModel) =&gt; { this.quoteResponse = response; }); }} 因为最终需要的信息是接口返回的响应信息对象中的一个属性，因此这里需要使用安全导航运算符（?）来确保模板的渲染不会因为空指针错误而中断 123456789&lt;p&gt; &lt;button (click)=\"getQuotes()\"&gt;获取毒鸡汤&lt;/button&gt;&lt;/p&gt;&lt;p&gt; 接口返回信息: {{quoteResponse | json}}&lt;/p&gt;&lt;i&gt; 毒鸡汤：{{quoteResponse?.data?.content}}&lt;/i&gt; 在执行服务中的方法时，有时会存在没有回调函数的情况，此时也必须执行 subscribe 方法，否则服务中的 HTTP 请求是没有真正发起的 服务中的 getAntiMotivationalQuotes 只能获取到接口返回的 body 里面的信息，某些情况下需要获取到完整的响应信息，此时需要通过 observe 参数来告诉 HttpClient 此方法需要返回完整的响应信息 12345678910111213141516171819202122232425import { Injectable } from '@angular/core';import { Observable } from 'rxjs';// 引入 HttpClient 类import { HttpClient, HttpResponse } from '@angular/common/http';// 引入接口响应类import { GetQuotesResponseModel } from '../interfaces/get-quotes-response-model';@Injectable({ providedIn: 'root'})export class AntiMotivationalQuotesServicesService { // 通过构造函数注入的方式依赖注入到使用的类中 constructor(private http: HttpClient) { } /** * 获取完整的接口请求信息 */ getAntiMotivationalQuotesResponse(): Observable&lt;HttpResponse&lt;GetQuotesResponseModel&gt;&gt; { const url = 'https://api.tryto.cn/djt/text'; return this.http.get&lt;GetQuotesResponseModel&gt;(url, { observe: 'response' }); }} 123456789101112131415161718192021222324252627282930313233import { HttpResponse } from '@angular/common/http';import { Component, OnInit } from '@angular/core';// 引入服务import { AntiMotivationalQuotesServicesService } from './../services/anti-motivational-quotes-services.service';// 引入接口响应对象import { GetQuotesResponseModel } from '../interfaces/get-quotes-response-model';@Component({ selector: 'app-anti-motivational-quotes', templateUrl: './anti-motivational-quotes.component.html', styleUrls: ['./anti-motivational-quotes.component.scss']})export class AntiMotivationalQuotesComponent implements OnInit { public quoteResponseInfo: HttpResponse&lt;GetQuotesResponseModel&gt;; // 通过构造函数注入的方式使用服务 constructor(private services: AntiMotivationalQuotesServicesService) { } ngOnInit(): void { } /** * 获取毒鸡汤接口完整的请求信息 */ getQuotesResponse() { this.services.getAntiMotivationalQuotesResponse().subscribe((response: HttpResponse&lt;GetQuotesResponseModel&gt;) =&gt; { this.quoteResponseInfo = response; }); }} HttpClient 默认的返回信息格式都是 json 对象，在后端接口返回的并不是 json 对象的情况下，需要手动的设置响应类型（text、blob、arraybuffer…） 12345678910111213141516171819202122232425import { Injectable } from '@angular/core';import { Observable } from 'rxjs';// 引入 HttpClient 类import { HttpClient, HttpResponse } from '@angular/common/http';// 引入接口响应类import { GetQuotesResponseModel } from '../interfaces/get-quotes-response-model';@Injectable({ providedIn: 'root'})export class AntiMotivationalQuotesServicesService { // 通过构造函数注入的方式依赖注入到使用的类中 constructor(private http: HttpClient) { } /** * 获取响应类型非 json 对象的信息 */ getYuiterSitemap(): Observable&lt;string&gt; { const url = 'https://yuiter.com/sitemap.xml'; return this.http.get(url, { responseType: 'text' }); }} 提交数据到服务端在同后端接口进行交互时，获取数据一般用的是 get 请求，而当进行数据新增、更新、删除时则会使用 post、put、delete 这三个 HTTP 谓词 在毒鸡汤这个接口中，可以使用 post 方式调用 https://api.tryto.cn/djt/submit 进行毒鸡汤的提交 根据 postman 的调用示例，在服务中定义一个方法用来提交毒鸡汤信息，这里的 SetQuotesResponseModel 为接口返回的响应对象 12345678910111213141516171819202122232425262728import { Injectable } from '@angular/core';import { Observable } from 'rxjs';// 引入 HttpClient 类import { HttpClient, HttpResponse } from '@angular/common/http';// 引入接口响应类import { SetQuotesResponseModel } from '../interfaces/set-quotes-response-model';@Injectable({ providedIn: 'root'})export class AntiMotivationalQuotesServicesService { // 通过构造函数注入的方式依赖注入到使用的类中 constructor(private http: HttpClient) { } /** * 提交毒鸡汤信息 * @param content 毒鸡汤 */ submitAntiMotivationalQuote(content: string): Observable&lt;SetQuotesResponseModel&gt; { const url = 'https://api.tryto.cn/djt/submit'; return this.http.post&lt;SetQuotesResponseModel&gt;(url, { content }); }} 因为这里是以默认的表单提交的方式进行的数据提交，当后端需要修改请求的 body 格式时，则需要我们修改请求的 MIME 类型 当需要更改请求的 MIME 类型或是需要添加授权访问的 token 信息这一类的操作时，需要在使用 HttpClient 提供的请求方法时添加上 HTTP 请求头配置信息 12345678910111213141516171819202122232425262728293031import { Injectable } from '@angular/core';import { Observable } from 'rxjs';// 引入 HttpClient 类import { HttpClient, HttpResponse, HttpHeaders } from '@angular/common/http';@Injectable({ providedIn: 'root'})export class AntiMotivationalQuotesServicesService { // 通过构造函数注入的方式依赖注入到使用的类中 constructor(private http: HttpClient) { } public httpOptions = { headers: new HttpHeaders({ 'Content-Type': 'application/json', 'Authorization': 'token' }) }; /** * 修改请求头信息 */ submitWithOptions() { const url = ''; return this.http.post(url, { data: '' }, this.httpOptions); }} 捕获错误信息获取错误信息在涉及到前后端交互的过程中，不可避免会出现各种状况，在出现错误时，可以在 subscribe 方法中，添加第二个回调方法来获取错误信息 1234567getQuotes() { this.services.getAntiMotivationalQuotes().subscribe((response: GetQuotesResponseModel) =&gt; { this.quoteResponse = response; }, error =&gt; { console.error(error); });} 在处理错误信息的回调方法中，方法返回了一个 HttpErrorResponse 对象来描述错误信息 因为这里的错误更多是服务在与后端进行通信产生的错误，因此对于错误信息的捕获和处理更应该放到服务中进行，而在组件处仅显示错误提示 在服务中定义一个错误处理器，用来处理与后端请求中发生的错误 1234567891011121314151617181920212223242526272829303132333435363738394041424344import { Injectable } from '@angular/core';import { Observable, throwError } from 'rxjs';import { catchError, retry } from 'rxjs/operators';// 引入 HttpClient 类import { HttpClient, HttpResponse, HttpHeaders, HttpErrorResponse } from '@angular/common/http';@Injectable({ providedIn: 'root'})export class AntiMotivationalQuotesServicesService { // 通过构造函数注入的方式依赖注入到使用的类中 constructor(private http: HttpClient) { } /** * 通过 get 请求获取毒鸡汤信息 */ getAntiMotivationalQuotes(): Observable&lt;GetQuotesResponseModel&gt; { const url = 'https://api.tryto.cn/djt/text32'; return this.http.get&lt;GetQuotesResponseModel&gt;(url) .pipe( catchError(this.handleError) ); } /** * 错误信息捕获处理 * @param error 错误信息 */ private handleError(error: HttpErrorResponse) { if (error.error instanceof ErrorEvent) { // 客户端本身引起的错误信息 console.error(`客户端错误：${error.error.message}`); } else { // 服务端返回的错误信息 console.error(`服务端错误：HTTP 状态码：${error.status} \\n\\r 错误信息：${JSON.stringify(error.error)}`); } // 反馈给用户的错误信息（用于组件中使用 error 回调时的错误提示） return throwError('不好的事情发生了，毕竟我们都有不顺利的时候。。。'); }} 当请求发生错误时，通过在 HttpClient 方法返回的 Observable 对象中使用 pipe 管道将错误传递给自定义的错误处理器，从而完成捕获错误信息的后续操作 请求重试某些情况下存在因为特殊原因导致短时间的请求失败，这时可以在 pipe 管道中，当请求失败后，使用 retry 方法进行多次的请求重试，在进行了多次重试后还是无法进行数据通信后，则进行错误捕获 12345678getAntiMotivationalQuotes(): Observable&lt;GetQuotesResponseModel&gt; { const url = 'https://api.tryto.cn/djt/text32'; return this.http.get&lt;GetQuotesResponseModel&gt;(url) .pipe( retry(3), // 重试三次 catchError(this.handleError) // 捕获错误信息 );} 请求和响应拦截在向服务器发起请求时，一般是需要我们在请求头中添加上授权的 token 信息，与其当后端接口返回我们无权访问时再来处理，是不是可以在发起请求前去进行拦截判断，如果不包含 token 信息，则将允许访问的 token 信息添加到请求中 同样的，当已经定义好后端返回什么信息代表请求出错 or 直接根据后端返回的请求状态码判断请求出错时，完全可以通过对接口返回的响应进行拦截，直接拦截掉请求出错的情况，从而不需要在后续的业务逻辑代码中再进行判断请求是否成功 自定义拦截器在 Angular 中可以新建一个继承于 HttpInterceptor 接口的拦截器类，通过实现 intercept 方法来对请求进行拦截处理 与 ASP.NET Core 中的中间件相似，我们可以在请求中添加多个的拦截器，构成一个拦截器链。当一个拦截器已经处理完成时，需要通过 next 对象将 HTTP 请求传递到下一个拦截器，否则，整个请求将会中断。如果当前的拦截器已经是整个拦截器链的最后一个，则会将请求发送到后端接口 123456789101112131415161718192021222324252627282930313233343536373839import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpResponse } from '@angular/common/http';import { Observable } from 'rxjs/internal/Observable';import { Injectable } from '@angular/core';import { tap, finalize } from 'rxjs/operators';/** * 通过添加 Injectable 特性，表明可以通过依赖注入的方式进行创建 */@Injectable()export class LoggingInterceptor implements HttpInterceptor { /** * 请求拦截 * @param req http 请求 * @param next 下一个拦截器 */ intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; { // 开始时间 const started = Date.now(); let msg: string; // 将 http 请求信息传递给下一个拦截器 return next.handle(req) .pipe( tap( // 捕获当前请求是否成功 or 失败 // 1、通过判断响应的类型是否为 HttpResponse 来判断请求是否成功 event =&gt; msg = event instanceof HttpResponse ? '请求成功' : '请求失败', // 2、如果存在了 error 回调，则请求失败 error =&gt; msg = '请求失败' ), finalize(() =&gt; { const elapsed = Date.now() - started; console.log(`请求方式：${req.method} 请求地址：${req.urlWithParams} 响应耗时：${elapsed} ms 请求结果：${msg}`); })); }} 当定义好拦截器后，与其它的自定义服务一样，我们需要添加到根模块的 providers 中，因为可能会存在定义多个拦截器的情况，这里可以通过定义一个 typescript 文件用来导出我们需要添加的拦截器信息 因为会存在定义多个拦截器的情况，所以这里需要指定 multi 属性为 true 123456789import { HTTP_INTERCEPTORS } from '@angular/common/http';// 需要添加的拦截器import { LoggingInterceptor } from './logging-interceptor';// 返回的拦截器数组export const HttpInterceptorProviders = [ { provide: HTTP_INTERCEPTORS, useClass: LoggingInterceptor, multi: true }]; 由于拦截器具有将发送到服务端的 HTTP 请求进行监视、转化，以及拦截请求的响应信息的双重效果，因此当我们注册了多个拦截器时，在发送请求时会按照我们添加的顺序进行执行，而在接受到请求响应时，则是按照反过来的顺序进行执行 获取到导出的拦截器信息，就可以在根模块中去导入需要注册的拦截器 123456789101112131415161718192021222324252627import { BrowserModule } from '@angular/platform-browser';import { NgModule } from '@angular/core';import { FormsModule } from '@angular/forms';import { AppRoutingModule } from './app-routing.module';import { AppComponent } from './app.component';// 添加自定义拦截器import { HttpInterceptorProviders } from './http-interceptors/http-interceptor-providers';@NgModule({ declarations: [ AppComponent, AntiMotivationalQuotesComponent ], imports: [ BrowserModule, AppRoutingModule, FormsModule, HttpClientModule // 添加到根应用模块中 ], providers: [ HttpInterceptorProviders ], bootstrap: [AppComponent]})export class AppModule { } 修改请求信息由于一个请求可能会存在重试发起的情况，为了确保多次发起请求时的请求信息的不变性，对于 HttpRequest 和 HttpResponse 我们是不可以修改原始的对象属性值的 当我们需要对请求进行修改时，例如在请求的 header 中添加上 token 信息，此时我们需要先克隆一个原始的请求对象，在这个克隆后的请求上进行操作，最终将这个克隆后的请求传递给下一个拦截器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpResponse } from '@angular/common/http';import { Observable } from 'rxjs/internal/Observable';import { Injectable } from '@angular/core';import { tap, finalize } from 'rxjs/operators';/** * 通过添加 Injectable 特性，表明可以通过依赖注入的方式进行创建 */@Injectable()export class LoggingInterceptor implements HttpInterceptor { /** * 请求拦截 * @param req http 请求 * @param next 下一个拦截器 */ intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; { // 开始时间 const started = Date.now(); let msg: string; // 打印原始的请求信息 console.log(`原始的请求信息：${JSON.stringify(req.headers)}`); // 获取请求中的 token 信息 const token = req.headers.get('Authorization') || ''; // 克隆请求信息 const authReq = req.clone({ headers: token === '' ? req.headers.set('Authorization', '123456') : req.headers }); // 打印修改后的请求信息 console.log(`克隆后的请求信息：${JSON.stringify(authReq.headers)}`); // 将克隆后的 http 请求信息传递给下一个拦截器 return next.handle(authReq) .pipe( tap( // 捕获当前请求是否成功 or 失败 // 1、通过判断响应的类型是否为 HttpResponse 来判断请求是否成功 event =&gt; msg = event instanceof HttpResponse ? '请求成功' : '请求失败', // 2、如果存在了 error 回调，则请求失败 error =&gt; msg = '请求失败' ), finalize(() =&gt; { const elapsed = Date.now() - started; console.log(`请求方式：${req.method} 请求地址：${req.urlWithParams} 响应耗时：${elapsed} ms 请求结果：${msg}`); })); }}","link":"/2020/03/22/angular-http-guide/"},{"title":"Angular 从入坑到挖坑 - 模块简介","text":"OverviewAngular 入坑记录的笔记第七篇，介绍 Angular 中的模块的相关概念，了解相关的使用场景，以及知晓如何通过特性模块来组织我们的 Angular 应用 对应官方文档地址： NgModule 简介 NgModules JavaScript 模块 vs. NgModule 使用根模块启动应用 常用模块 特性模块 Contents Angular 从入坑到弃坑 - Angular 使用入门 Angular 从入坑到挖坑 - 组件食用指南 Angular 从入坑到挖坑 - 表单控件概览 Angular 从入坑到挖坑 - HTTP 请求概览 Angular 从入坑到挖坑 - Router 路由使用入门指北 Angular 从入坑到挖坑 - 路由守卫连连看 Angular 从入坑到挖坑 - 模块简介 Knowledge Graph Step by Step前端模块化前端模块化是指将程序中一组相关的功能按照一定的规则组织在一块，整个模块内部的数据和功能实现是私有的，通过 export 暴露其中的一些接口（方法）与系统中的别的模块进行通信 NgModule 简介在 Angular 应用中，至少会存在一个 NgModule，也就是应用的根模块（AppModule）,通过引导这个根模块就可以启动整个项目 像开发中使用到 FormsModule、HttpClientModule 这种 Angular 内置的库也都是一个个的 NgModule，在开发中通过将组件、指令、管道、服务或其它的代码文件聚合成一个内聚的功能块，专注于系统的某个功能模块 常见的 NgModule 模块 模块名称 模块所在文件 功能点 BrowserModule @angular/platform-browser 用于启动和运行浏览器应用的的基本服务 CommonModule @angular/common 使用 NgIf、NgFor 之类的内置指令 FormsModule @angular/forms 使用 NgModel 构建模板驱动表单 ReactiveFormsModule @angular/forms 构建响应式表单 RouterModule @angular/router 使用前端路由 HttpClientModule @angular/common/http 发起 http 请求 JavaScript 模块与 NgModule在 JavaScript 中，每一个 js 文件就是一个模块，文件中定义的所有对象都从属于那个模块。 通过 export 关键字，模块可以把其中的某些对象声明为公共的，从而其它 JavaScript 模块可以使用 import 语句来访问这些公共对象 例如下面的示例代码中，别的 javascript 模块可以通过导入这个 js 文件来直接使用暴露的 getRoles 和 getUserInfo 方法 123456789101112function getRoles() { // ...}function getUserInfo() { // ...}export { getRoles, getUserInfo} NgModule 是一个带有 @NgModule 装饰器的类，通过函数的参数来描述这个模块，例如在上节笔记中创建的 CrisisModule，定义了我们在该特性模块中创建的组件，以及需要使用到的其它模块 在使用 @NgModule 装饰器时，通常会使用到下面的属性来定义一个模块 declarations：当前模块中的组件、指令、管道 imports：当前模块所需的其它 NgModule 模块 exports：其它模块中可以使用到当前模块可声明的对象 providers：当前模块向当前应用中其它应用模块暴露的服务 bootstrap：用来定义整个应用的根组件，是应用中所有其它视图的宿主，只有根模块中才会存在 应用的根模块根模块是用来启动此 Angular 应用的模块， 按照惯例，它通常命名为 AppModule 通过 Angular CLI 新建一个应用后，默认的根模块代码如下，通过使用 @NgModule 装饰器装饰 AppModule 类，定义了这个模块的一些属性特征，从而告诉 Angular 如何编译和启动本应用 123456789101112131415161718import { BrowserModule } from '@angular/platform-browser';import { NgModule } from '@angular/core';import { AppRoutingModule } from './app-routing.module';import { AppComponent } from './app.component';@NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, AppRoutingModule ], providers: [], bootstrap: [AppComponent]})export class AppModule { } declarationsdeclarations 数组告诉 Angular 哪些组件属于当前模块。 当创建新的组件时，需要将它们添加到 declarations 数组中。每个组件都只能声明在一个 NgModule 类中，同时，如果你使用了未声明过的组件，Angular 将会报错 同样的，对于当前模块使用到的自定义指令、自定义管道，也需要在 declarations 数组中进行声明 importsimports 数组表明当前模块正常工作时需要引入哪些的模块，例如这里使用到的 BrowserModule、AppRoutingModule 或者是我们使用双向数据绑定时使用到的 FormsModule，它表现出当前模块的一个依赖关系 providersproviders 数组定义了当前模块可以提供给当前应用其它模块的各项服务，例如一个用户模块，提供了获取当前登录用户信息的服务，因为应用中的其它地方也会存在调用的可能，因此，可以通过添加到 providers 数组中，提供给别的模块使用 bootstrapAngular 应用通过引导根模块来启动的，因为会涉及到构建组件树，形成实际的 DOM，因此需要在 bootstrap 数组中添加根组件用来作为组件树的根 特性模块特性模块是用来将特定的功能或具有相关特性的代码从其它代码中分离出来，聚焦于特定应用需求。特性模块通过它提供的服务以及共享出的组件、指令和管道来与根模块和其它模块合作 在上一章中，定义了一个 CrisisModule 用来包括包含与危机有关的功能模块，创建特性模块时可以通过 Angular CLI 命令行进行创建 12-- 创建名为 xxx 的特性模块ng new component xxx 1234567891011121314151617181920212223import { NgModule } from '@angular/core';import { CommonModule } from '@angular/common';import { CrisisRoutingModule } from './crisis-routing.module';import { FormsModule } from '@angular/forms';import { CrisisListComponent } from './crisis-list/crisis-list.component';import { CrisisDetailComponent } from './crisis-detail/crisis-detail.component';@NgModule({ declarations: [ CrisisListComponent, CrisisDetailComponent ], imports: [ CommonModule, FormsModule, CrisisRoutingModule ]})export class CrisisModule { } 当创建完成后，为了将该特性模块包含到应用中，需要和 BrowserModule、AppRoutingModule 一样，在根模块中 imports 引入 默认情况下，NgModule 都是急性加载的，也就是说它会在应用加载时尽快加载，所有模块都是如此，无论是否立即要用。对于带有很多路由的大型应用，考虑使用惰性加载的模式。惰性加载可以减小初始包的尺寸，从而减少程序首次的加载时间 12345678910111213141516171819202122232425import { BrowserModule } from '@angular/platform-browser';import { NgModule } from '@angular/core';import { FormsModule } from '@angular/forms';import { AppRoutingModule } from './app-routing.module';import { AppComponent } from './app.component';// 添加自定义的模块import { CrisisModule } from './crisis/crisis.module';@NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, FormsModule, CrisisModule, // 引入自定义模块 AppRoutingModule ], providers: [], bootstrap: [AppComponent]})export class AppModule { }","link":"/2020/06/26/angular-modules-introduction/"},{"title":"或许是你应该了解的一些 ASP.NET Core Web API 使用小技巧","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在目前的软件开发的潮流中，不管是前后端分离还是服务化改造，后端更多的是通过构建 API 接口服务从而为 web、app、desktop 等各种客户端提供业务支持，如何构建一个符合规范、容易理解的 API 接口是我们后端开发人员需要考虑的。在本篇文章中，我将列举一些我在使用 ASP.NET Core Web API 构建接口服务时使用到的一些小技巧，因才疏学浅，可能会存在不对的地方，欢迎指出。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仓储地址：https://github.com/Lanesra712/ingos-server Step by Step&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为本篇文章中涉及到的一些知识点在之前的文章中也已经有具体的解释了，所以这里只会说明如何在 ASP.NET Core Web API 中如何去使用，不会做过多的详细介绍。如果你需要详细了解的话，可以跳转到文章中给出的外链地址去查看。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本篇文章中使用的代码是基于 .NET Core 2.2 + .NET Standard 2.0 进行构建的，如果你采用的版本与我使用的不同，可能最终实现起来的代码会有所不同，请提前知悉。同时，本篇文章中所有示例代码都会存在于前言中所列出的 github repo 中，我会尝试将每个功能点的开发作为一次 commit，并且也会在后续进行不定期的更新完善，最终搭建一个基于领域驱动思想的后端项目模板，如果对你有帮助的话，欢迎持续关注。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一、使用小写路由&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我之前的一篇文章中（构建可读性更高的 ASP.NET Core 路由）有提到过，因为 .NET 默认采用 Pascal 的类命名方式，如果采用默认生成的路由，最终构建出的路由地址会存在大小写混在一起的情况，虽然在 .NET Core 中大小写的路由地址最终都会对于到正确的资源上，但是为了更好的符合前端的规范，所以这里我们首先按照之前的文章中所列出的方法去修改默认生成的路由地址格式。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为这里我们最终想要实现的是符合 Restful 风格的 API 接口，所以这里我们首先需要将默认生成的 URL 地址改为全小写模式。12345678public void ConfigureServices(IServiceCollection services){ // 采用小写的 URL 路由模式 services.AddRouting(options =&gt; { options.LowercaseUrls = true; });} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你有看过构建可读性更高的 ASP.NET Core 路由这篇文章，你会发现其实我们最终实现的是 hyphen(-) 格式的 Url 地址，那么这里我们为什么不进行后续的修改了呢？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你有查看 .NET Core 默认模板中生成的 API Controller，仔细看下，这里其实是使用的特性路由，所以这里我们并不能通过 Startup.UseMvc 定义的传统路由模板，或是直接在 Startup.Configure 中的 UseMvcWithDefaultRoute 方法去修改我们的生成的路由地址格式。12345[Route(\"api/[controller]\")][ApiController]public class ValuesController : ControllerBase{} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、允许跨域请求&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不管是后端接口的服务化改造，还是只是单纯的前后端分离项目开发，我们的前端项目与后端接口通常不会部署在一起，所以我们需要解决前端访问接口时会涉及到的跨域访问的问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对跨域请求，我们可以采用 jsonp、或者是通过给 nginx 服务器配置响应的 header 参数头信息、或者是使用 CORS，又或是其它的解决方案。你可以自由选择，这里我采用在后端接口中直接配置对于 CORS 的支持。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 .NET Core 中，已经在 Microsoft.AspNetCore.Cors 这个类库中添加了对于 CORS 的支持，因为这个类库是存在于我们已经安装的 .NET Core SDK 中，所以这里我们并不需要通过 Nuget 进行安装，可以直接使用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 .NET Core 中配置 CORS 规则，我们可以通过在 Startup.ConfigureServices 这个方法中添加不同的授权策略，之后再针对某个 Controller 或是 Action 通过添加 EnableCors 这个 Attribute 的方式进行配置，这里如果指定了 policy 策略名称，则会使用指定的策略，如果没有指定，则适用于系统的默认配置。同样的，我们也可以只设置一个策略，直接针对整个项目进行配置，这里我采用对整个项目采用通用的跨域请求配置方案。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在配置 CORS 策略时，我们可以设置只允许来源于某些 URL 地址的请求可以访问，或者是指定接口只允许某些 HTTP 方法进行访问，或者是在请求的 header 中必须包含某些信息才可以访问我们的接口。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在下面的代码中，我定义了针对整个项目的跨域请求策略，这里我只是设置了对于接口请求方 URL 地址的控制，通过读取配置文件中的数据，从而达到只允许某些 IP 可以访问的我们接口的目的。12345678910111213141516171819202122232425262728293031public class Startup{ // 默认的跨域请求策略名称 private const string _defaultCorsPolicyName = \"Ingos.Api.Cors\"; // This method gets called by the runtime. Use this method to add services to the container. public void ConfigureServices(IServiceCollection services) { services.AddMvc( // 添加 CORS 授权过滤器 options =&gt; options.Filters.Add(new CorsAuthorizationFilterFactory(_defaultCorsPolicyName)) ).SetCompatibilityVersion(CompatibilityVersion.Version_2_2); // 配置 CORS 授权策略 services.AddCors(options =&gt; options.AddPolicy(_defaultCorsPolicyName, builder =&gt; builder.WithOrigins( Configuration[\"Application:CorsOrigins\"] .Split(\",\", StringSplitOptions.RemoveEmptyEntries).ToArray() ) .AllowAnyHeader() .AllowAnyMethod() .AllowCredentials())); } // This method gets called by the runtime. Use this method to configure the HTTP request pipeline. public void Configure(IApplicationBuilder app, IHostingEnvironment env) { // 允许跨域请求访问 app.UseCors(_defaultCorsPolicyName); }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如在下面的设置中，我只允许这一个地址可以访问我们的接口，如果需要指定多个的话，则可以通过英文的 , 进行分隔。123\"Application\": { \"CorsOrigins\": \"http://127.0.0.1:5050\"} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;某些情况下，如果我们不想进行限制的话，只需要将值改为 * 即可。123\"Application\": { \"CorsOrigins\": \"*\"} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三、添加接口版本控制&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一些涉及到接口功能升级的场景下，当我们需要修改接口逻辑而旧版本的接口无法停用的情况时，为了减少对于原有接口的影响，我们可以采取为接口添加版本信息的形式，从而降低因采用不同版本而造成的影响。如果你想要详细了解的话，可以查看这篇文章，电梯直达 =》ASP.NET Core 实战：构建带有版本控制的 API 接口。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在实现具有版本控制的接口前，首先我们需要通过 Nuget 添加下面的两个 dll，因为我是在 Ingos.Api.Core 这个类库中进行配置的，所以我安装到了这个类库下，你需要根据你自己的情况选择最终是安装到 Api 接口项目中还是在别的类库下。12Install-Package Microsoft.AspNetCore.Mvc.VersioningInstall-Package Microsoft.AspNetCore.Mvc.Versioning.ApiExplorer &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在安装完成之后，我们就可以在 Startup.ConfigureServices 方法中，为项目中的接口配置版本信息，这里我采用的方案是将版本号添加到接口的 URL 地址中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为对于所有中间件的配置都会在 Startup.ConfigureServices 方法中，为了保持该方法的纯净性，这里我写了一个扩展方法用于配置我们的 api 的版本，之后直接调用即可。1234567891011121314151617181920212223242526272829303132public static class ApiVersionExtension{ /// &lt;summary&gt; /// 添加 API 版本控制扩展方法 /// &lt;/summary&gt; /// &lt;param name=\"services\"&gt;生命周期中注入的服务集合 &lt;see cref=\"IServiceCollection\"/&gt;&lt;/param&gt; public static void AddApiVersion(this IServiceCollection services) { // 添加 API 版本支持 services.AddApiVersioning(o =&gt; { // 是否在响应的 header 信息中返回 API 版本信息 o.ReportApiVersions = true; // 默认的 API 版本 o.DefaultApiVersion = new ApiVersion(1, 0); // 未指定 API 版本时，设置 API 版本为默认的版本 o.AssumeDefaultVersionWhenUnspecified = true; }); // 配置 API 版本信息 services.AddVersionedApiExplorer(option =&gt; { // api 版本分组名称 option.GroupNameFormat = \"'v'VVVV\"; // 未指定 API 版本时，设置 API 版本为默认的版本 option.AssumeDefaultVersionWhenUnspecified = true; }); }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;扩展方法最终实现方式如上面的代码所示，之后我们就可以直接在 ConfigureServices 方法中直接进行调用这个扩展方法就可以了。123456// This method gets called by the runtime. Use this method to add services to the container.public void ConfigureServices(IServiceCollection services){ // Config api version services.AddApiVersion();} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们删除项目创建时默认生成的 ValuesController，在 Controllers 目录下建立一个 v1 文件夹，代表此文件夹下都是 v1 版本的控制器。添加一个 UsersController 用来获取系统的用户资源，现在项目的文件结构如下图所示。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们来改造我们的 UsersController，我们只需要在 Controller 或是 Action 上添加 ApiVersion 特性就可以指定当前 Controller/Action 的版本信息。同时，因为我需要将 API 的版本信息添加到生成的 URL 地址中，所以这里我们需要修改特性路由的模板，将我们的版本以占位符的形式添加到生成的路由 URL 地址中，修改完成后的代码及实现的效果如下所示。123456[ApiVersion(\"1.0\")][ApiController][Route(\"api/v{version:apiVersion}/[controller]\")]public class UsersController : ControllerBase{} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;四、添加对于 Swagger 接口文档的支持&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在前后端分离开发的情况下，我们需要提供给前端开发人员一个接口文档，从而让前端开发人员知道以什么样的 HTTP 方法或是传递什么样的参数给后端接口，从而获取到正确的数据，而 Swagger 则提供了一种自动生成接口文档的方式，同时也提供类似于 Postman 的功能，可以实现对于接口的实时调用测试。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们需要通过 Nuget 添加 Swashbuckle.AspNetCore 这个 dll 文件，之后我们就可以在此基础上实现对于 Swagger 的配置。1Install-Package Swashbuckle.AspNetCore &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与上面配置 API 接口的版本信息相似，这里我依旧采用构建扩展方法的方式来实现对于 Swagger 中间件的配置。具体的配置过程可以查看我之前写的文章（ASP.NET Core 实战：构建带有版本控制的 API 接口），这里只列出最终配置完成的代码。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static void AddSwagger(this IServiceCollection services){ // 配置 Swagger 文档信息 services.AddSwaggerGen(s =&gt; { // 根据 API 版本信息生成 API 文档 // var provider = services.BuildServiceProvider().GetRequiredService&lt;IApiVersionDescriptionProvider&gt;(); foreach (var description in provider.ApiVersionDescriptions) { s.SwaggerDoc(description.GroupName, new Info { Contact = new Contact { Name = \"Danvic Wang\", Email = \"danvic96@hotmail.com\", Url = \"https://yuiter.com\" }, Description = \"Ingos.API 接口文档\", Title = \"Ingos.API\", Version = description.ApiVersion.ToString() }); } // 在 Swagger 文档显示的 API 地址中将版本信息参数替换为实际的版本号 s.DocInclusionPredicate((version, apiDescription) =&gt; { if (!version.Equals(apiDescription.GroupName)) return false; var values = apiDescription.RelativePath .Split('/') .Select(v =&gt; v.Replace(\"v{version}\", apiDescription.GroupName)); apiDescription.RelativePath = string.Join(\"/\", values); return true; }); // 参数使用驼峰命名方式 s.DescribeAllParametersInCamelCase(); // 取消 API 文档需要输入版本信息 s.OperationFilter&lt;RemoveVersionFromParameter&gt;(); // 获取接口文档描述信息 var basePath = Path.GetDirectoryName(AppContext.BaseDirectory); var apiPath = Path.Combine(basePath, \"Ingos.Api.xml\"); s.IncludeXmlComments(apiPath, true); });} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们配置完成后就可以在 Startup 类中去启用 Swagger 文档。1234567891011121314151617181920public void ConfigureServices(IServiceCollection services){ // 添加对于 swagger 文档的支持 services.AddSwagger();}public void Configure(IApplicationBuilder app, IHostingEnvironment env, IApiVersionDescriptionProvider provider){ // 启用 Swagger 文档 app.UseSwagger(); app.UseSwaggerUI(s =&gt; { // 默认加载最新版本的 API 文档 foreach (var description in provider.ApiVersionDescriptions.Reverse()) { s.SwaggerEndpoint($\"/swagger/{description.GroupName}/swagger.json\", $\"Sample API {description.GroupName.ToUpperInvariant()}\"); } });} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为我们在之前设置构建的 API 路由时包含了版本信息，所以在最终生成的 Swagger 文档中进行测试时，我们都需要在参数列表中添加 API 版本这个参数。这无疑是有些不方便，所以这里我们可以通过继承 IOperationFilter 接口，控制在生成 API 文档时移除 API 版本参数，接口的实现方法如下所示。12345678public class RemoveVersionFromParameter : IOperationFilter{ public void Apply(Operation operation, OperationFilterContext context) { var versionParameter = operation.Parameters.Single(p =&gt; p.Name == \"version\"); operation.Parameters.Remove(versionParameter); }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们实现自定义的接口后就可以在之前针对 Swagger 的扩展方法中调用这个过滤方法，从而实现移除版本信息的目的，扩展方法中的添加位置如下所示。123456789public static void AddSwagger(this IServiceCollection services){ // 配置 Swagger 文档信息 services.AddSwaggerGen(s =&gt; { // 取消 API 文档需要输入版本信息 s.OperationFilter&lt;RemoveVersionFromParameter&gt;(); });} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终的实现效果如下图所示，可以看到，参数列表中已经没有版本信息这个参数，但是我们在进行接口测试时会自动帮我们添加上版本参数信息。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里需要注意，因为我们需要在最终生成的 Swagger 文档中显示出我们对于 Controller 或是 Action 添加的注释信息，所以这里我们需要在 Web Api 项目的属性选项中勾选上输出 XML 文档文件。同时如果你不想 VS 一直提示你有方法没有添加参数信息，这里我们可以在取消显示警告这里添加上 1591 这个参数。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;五、构建符合 Restful 风格的接口&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在没有采用 Restful 风格来构建接口返回值时，我们可能会习惯于在接口返回的信息中添加一个接口是否请求成功的标识，就像下面代码中示例的这种返回形式。12345678{ sueecss: true msg: '', data: [{ id: '20190720214402', name: 'zhangsan' }]} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，当我们想要构建符合 Restful 风格的接口时，我们就不能再这样进行设计了，我们应该通过返回的 HTTP 响应状态码来标识这次访问是否成功。一些比较常用的 HTTP 状态码如下表所示。 HTTP 状态码 涵义 解释说明 200 OK 用于一般性的成功返回，不可用于请求错误返回 201 Created 资源被创建 202 Accepted 用于资源异步处理的返回，仅表示请求已经收到。对于耗时比较久的处理，一般用异步处理来完成 204 No Content 此状态可能会出现在 PUT、POST、DELETE 的请求中，一般表示资源存在，但消息体中不会返回任何资源相关的状态或信息 400 Bad Request 用于客户端一般性错误信息返回, 在其它 4xx 错误以外的错误，也可以使用，错误信息一般置于 body 中 401 Unauthorized 接口需要授权访问，为通过授权验证 403 Forbidden 当前的资源被禁止访问 404 Not Found 找不到对应的信息 500 Internal Server Error 服务器内部错误 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们知道 HTTP 共有四个谓词方法，分别为 Get、Post、Put 和 Delete，在之前我们可能更多的是使用 Get 和 Post，对于 Put 和 Delete 方法可能并不会使用。同样的，如果我们需要创建符合 Restful 风格的接口，我们则需要根据这四个 HTTP 方法谓词一些约定俗成的功能定义去定义对应接口的 HTTP 方法。 HTTP 谓词方法 解释说明 GET 获取资源信息 POST 提交新的资源信息 PUT 更新已有的资源信息 DELETE 删除资源 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，对于一个获取所有资源的方法，我们可能会定义接口的默认返回 HTTP 状态码为 200 或是 400，当状态码为 200 时，代表数据获取成功，接口可以正常返回数据，当状态码为 400 时，则代表接口访问出现问题，此时则返回错误信息对象。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 ASP.NET Core Web API 中，我们可以通过在 Action 上添加 ProducesResponseType 特性来定义接口的返回状态码。通过 F12 按键我们可以进入 ProducesResponseType 这个特性，可以看到这个特性存在两个构造方法，我们可以只定义接口返回 HTTP 状态码或者是在定义接口返回的状态码时同时返回的具体对象信息。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面给出的接口案例的示例代码如下所示，从下图中可以看到，Swagger 会自动根据我们的 ProducesResponseType 特性来列出我们接口可能返回的 HTTP 状态码和对象信息。这里因为是示例程序，UserListDto 并没有定义具体的属性信息，所以这里显示的是一个不包含任何属性的对象数组。 12345678910111213141516171819202122/// &lt;summary&gt;/// 获取全部的用户信息/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;[HttpGet][ProducesResponseType(typeof(IEnumerable&lt;UserListDto&gt;), StatusCodes.Status200OK)][ProducesResponseType(StatusCodes.Status400BadRequest)]public IActionResult Get(){ // 1、获取资源数据 // 2、判断数据获取是否成功 if (true) return Ok(new List&lt;UserListDto&gt;()); else return BadRequest(new { statusCode = StatusCodes.Status400BadRequest, description = \"错误描述\", msg = \"错误信息\" });} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可能这里你可能会有疑问，当接口返回的 HTTP 状态码为 400 时，返回的信息是什么鬼，与我们定义的错误信息对象字段不同啊？原来，在 ASP.NET Core 2.1 之后的版本中，对于 API 接口返回 400 的 HTPP 状态码会默认返回 ProblemDetails 对象，因为这里我们并没有将接口中的返回 BadRequest 中的错误信息对象作为 ProducesResponseType 特性的构造函数的参数，所以这里就采用了默认的错误信息对象。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，当接口的 HTTP 返回状态码为 400 时，最终还是会返回我们自定义的错误信息对象，所以这里为了不造成前后端对接上的歧义，我们最好将返回的对象信息也作为参数添加到 ProducesResponseType 特性中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同时，除了上面示例的接口中通过返回 OK 方法和 BadRequest 方法来表明接口的返回 HTTP 状态码，在 ASP.NET Core Web API 中还有下列继承于 ObjectResult 的方法来表明接口返回的状态码，对应信息如下。 HTTP 状态码 方法名称 200 OK() 201 Created() 202 Accepted() 204 NoContent() 400 BadRequest() 401 Unauthorized() 403 Forbid() 404 NotFound() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;六、使用 Web API 分析器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的示例中，因为我们需要指定接口需要返回的 HTTP 状态码，所以我们需要提前添加好 ProducesResponseType 特性，在某些时候我们可能在代码中添加了一种 HTTP 状态码的返回结果，可是却忘了添加特性描述，那么有没有一种便捷的方式提示我们呢？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 ASP.NET Core 2.2 及以后更新的 ASP.NET Core 版本中，我们可以通过 Nuget 去添加 Microsoft.AspNetCore.Mvc.Api.Analyze 这个包，从而实现对我们的 API 进行分析，首先我们需要将这个包添加到我们的 API 项目中。1Install-Package Microsoft.AspNetCore.Mvc.Api.Analyzers &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如在下面的接口代码中，我们根据用户的唯一标识去寻找用户数据，当获取不到数据的时候，返回的 HTTP 状态码为 400，而我们只添加了 HTTP 状态码为 200 的特性说明。此时，分析器将 HTTP 404 状态代码的缺失特性说明做为一个警告，并提供了修复此问题的选项，我们进行修复后就可以自动添加特性。1234567891011121314151617/// &lt;summary&gt;/// 获取用户详细信息/// &lt;/summary&gt;/// &lt;param name=\"id\"&gt;用户唯一标识&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;[HttpGet(\"{id}\")][ProducesResponseType(typeof(UserEditDto), StatusCodes.Status200OK)]public IActionResult Get(string id){ // 1、根据 Id 获取用户信息 UserEditDto user = null; if (user == null) return NotFound(); else return Ok(user);} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，在自动完成文档补全后其实还是需要我们进行一些操作的，例如，如果我们需要指定返回值的 Type 类型，还是需要我们自己手动添加到 ProducesResponseType 特性上的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在进行特性补齐的时候，分析器也帮我们填加了一个 ProducesDefaultResponseType 特性。通过在微软的文档中指向的 Swagger 文档（Swagger Default Response）中可以了解到，如果我们接口不管是什么状态，最终返回的 response 响应结构都是相同的，我们就可以直接使用 ProducesDefaultResponseType 特性来指定 response 的响应结构，而不需要每个 HTTP 状态都添加一个特性。 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本篇文章中，主要介绍了一些我在使用 ASP.NET Core Web API 的过程中使用到的一些小技巧，以及在以前踩过坑后的一些解决方案，如果对你能有一点的帮助的话，不胜荣幸。同时，如果你有更好的解决方案，或者是针对一些你之前踩过的 Web API 坑的解决方案，也欢迎你在评论区中提出。","link":"/2019/07/27/asp-net-core-web-api-tutorial/"},{"title":"从零开始针对 .NET 应用的 DevOps 运营实践 - 运行环境搭建","text":"Overview最近的一段时间，在公司里我都在进行基于 Jenkins 和 SonarQube 配合已有的 Gitlab 搭建部门的持续集成环境的工作，虽然之前有使用过 GitHub Actions 和 Azure DevOps，但是从头开始搭建这样的一套 DevOps 环境还是学习到了一些新的知识点，因此，借着这个中秋国庆假期的机会，分享下整个工具链的搭建过程，如果你也有相似的需求的话，希望可以对你有所帮助 Contents 从零开始针对 .NET 应用的 DevOps 运营实践 - 运行环境搭建 Step by Step一些概念DevOps, Development 和 Operations，从名称上就可以看出，这一名词包含了软件的开发与运营。当然，这里提到的 DevOps 是一种方法论，更多的是为了打破开发与运营人员之间的壁垒，用来促进开发人员、运营人员以及 QA 人员之间的沟通与协作。通过引入 DevOps 中使用的各种工具，我们可以通过自动化的方式，完成软件系统的构建、测试、发布，从而降低因人工操作所造成的不确定性，提升软件的交付速度、系统质量 在践行 DevOps 方法论时，经常会提到三个概念，持续集成、持续交付、持续部署，这里借由 Redhat 上介绍相关概念的一张图片来说明三者之间的联系 ​ 持续集成（Continuous Integration）：在传统的软件开发过程中，将个人开发的代码与整个项目代码的合并一般都会置于比较靠后的阶段，而持续集成强调的是开发人员提交了新代码之后，立刻进行构建、单元测试。根据测试的结果，确定新代码和原有代码能否正确地集成在一起 持续交付（Continuous Delivery）：持续交付是一种自动化的软件交付手段，在持续集成的基础上，代码库中的代码已经做好了部署到正式环境的准备，在目前的通用做法中，将构建之后的代码通过持续交付变更部署到测试环境、预发布环境中，实现对持续集成的扩展，出于业务方面的考虑，我们可以手动选择是否部署到正式环境 持续部署（Continuous Deployment）：作为对持续交付的延伸，持续部署能够自动的将最终的代码部署到生产环境中，完成整个的 CI/CD 流程 虽然目前的需求仅仅是为了实现持续集成，完成对于系统的自动化代码检查、自动化单元测试，但是因为后续的功能对于我们完整的实施 DevOps 方法论也是必须的，所以在这几篇的博客内容中，我也会完成对于后续功能的实践分享 前期调研与持续集成的场景存在一些的差异，我们在实际的开发中，并不会在新的功能分支上按照每个开发人员再建立单独的分支，因此，这里的持续集成更多的想要实现的是当开发人员提交代码到 Gitlab 时，自动触发代码检查以及单元测试，产出代码检查报告、单元测试报告、以及整个项目的测试覆盖率 因此，基于目前的需求，整个系统主要依赖于三个主要的软件系统，Gitlab、Jenkins、以及 SonarQube，当然，这里缺少了一个 bug 管理工具，因为我们部门人数不是很多，目前是和别的部门共用的 Redmine 进行的项目管理，所以本次并没有纳入到我们的需求范围内，当然， bug 管理也是推行 DevOps 中不可缺少的一部分 在挑选组件时，本着不给自己和别人挖坑的原则，优先考虑使用人数多的软件系统。因此，作为事实上的开源 CI/CD 工具的标准，毫无疑问选择 Jenkins，而对于代码的自动化检查，结合我们需要实现私有化部署，满足对多种开发语言的支持、能够与 CI/CD 工具进行有效结合的需求，这里最终选择的是 SonarQube 由于历史原因，部门系统的框架版本横跨了 VB.NET、.NET Framework 2.x，4.x 与 .NET Core，.NET 框架的程序涵盖了 Web Form、MVC、Web API，排除掉已经不维护的系统，最终需求的范围限定在支持 .NET Framework 4.x+ 以及 .NET Core 程序上。因此，这里只能选择将 Jenkins 和 SonarQube 部署到 Windows 服务器上，如果你不需要兼容 .NET Framework 的程序，推荐你部署到 Linux 服务器上 在选定好使用的软件后，就需要完成环境的配置，Jenkins 与 SonarQube 都是基于 Java 的软件，因此在安装软件之前，需要我们在服务器上完成 Java 环境的配置，同时，基于我们的系统现状，需要在服务器上安装好 .NET Framework、.NET Core、Git 以及 Node 对于 Git、Node、.NET SDK 的安装，下载安装包后，一直 next 即可，加上这里主要针对的是 .NET 程序员，以及我们的服务器是断网的，所以这里主要列举的是两个相对来说稍微复杂的环境配置，一个是对于 MSBuild 工具的离线下载，另一个则是 Java 环境的配置 MSBuild 安装因为在整个过程中会涉及到对应用程序的编译生成，对于 .NET Core 应用，完全可以采用 .NET Core CLI 中的各种命令来实现，而对于 .NET Framework 程序来说，则需要一个执行应用程序生产的平台，MSBuild 就是这样的一个工具，我们在开发过程中使用 Visual Studio 进行程序编译时，其实也是会借用 MSBuild 来进行的 因此，最简单的办法，就是在服务器上安装 VS 即可，当然，这个过于简单粗暴了，以及在服务器上安装我们开发使用的 IDE 也过于浪费，所以这里还是会选择独立的安装 MSBuild 与 VS 相似，MSBuild 也有不同的版本，为了避免一些莫名其妙的问题，在 MSBuild 的版本选择上，最好选择与你们开发时用的 VS 匹配的版本，因为我们在开发中会使用到了 VS 2017 和 VS 2019 这两个版本，所以这里我会安装两个 MSBuild 到服务器上 对于 MSBuild，之前很多文章中说可以直接把你本地电脑中的 VS 所包含的 MSBuild，丢到服务器上就可以了，经过我的多次尝试，在踩坑的路上越走越远，这里还是建议你通过 Visual Studio Build Tools 进行安装 在 VS 的下载页面，这里是以 VS 2019 的下载页面进行示例，在 Visual Studio 2019 工具这个内容块中，找到生成工具这个下载项，下载即可 这里你可以直接通过我给出的这两个地址，直接下载对应的生成工具，打开软件，找到 MSBuild 这个组件进行安装即可 Visual Studio 2017 Build Tools：https://visualstudio.microsoft.com/zh-hans/thank-you-downloading-visual-studio/?sku=BuildTools&amp;rel=15 Visual Studio 2019 Build Tools：https://visualstudio.microsoft.com/zh-hans/thank-you-downloading-visual-studio/?sku=BuildTools&amp;rel=16 当然，这个下载完成的也只是一个在线安装包，还是需要连接网络进行下载的，如果你们的服务器也是没有连接外网权限的话，这里需要换个方式 对于离线安装，找到下载后的安装器所在的路径，打开 CMD，输入下面的命令，即可按需下载需要的组件到指定的位置，例如这里我是将下载好的文件放在我桌面上的 msbuild 文件夹下的 offline 文件夹中 1vs_buildtools.exe --layout C:\\Users\\danvi\\Desktop\\msbuild\\offline --add Microsoft.VisualStudio.Workload.MSBuildTools --add Microsoft.VisualStudio.Workload.WebBuildTools --lang zh-CN 整个命令包含了三个部分的内容 --layout：指定离线安装文件所在的路径 --add：指定需要下载的组件，因为我们的系统是 Web 项目，为了防止在 MSBuild 中生成出错，所以这里除了 MSBuild 还需要下载了一个 WebBuildTools --lang：指定安装包的语言 同新版本的 VS 的安装一样，当我们输入命令之后，会打开如下的页面，等待安装器的下载完成即可 当下载器安装完成后，会自动弹出一个新的控制台页面，坐和放宽，此时已经开始自动下载我们需要的组件，当全部组件下载完成时，按照提示的内容关闭弹出的页面即可 找到你所指定的下载路径，将整个文件夹拷贝到服务器上，然后点击 vs_buildtools.exe 进行安装，具体安装的组件则可以通过右侧的安装详细信息进行查看，如果你在使用中发现缺少你需要的，按照上面的方法添加新的参数即可 Java 环境配置因为 Jenkins 与 SonarQube 均是 Java 程序，并且 SonarQube 对 Java SDK 的版本有具体的要求，这里我选择的是 OpenJDK 11，你可以从此处（https://jdk.java.net/archive/） 获取到 OpenJDK 的各个发行版本 与 .NET SDK 不同，在习惯了一路 next 就可以安装各种的操作后，在安装 OpenJDK 时，需要手动的将 SDK 的路径以及相关的环境变量添加到操作系统中 解压下载完成的压缩包到指定的路径，例如这里我的路径是 E:\\sdk\\jdk-11.0.2，此时我们需要对环境变量进行配置，从而确保 Java 环境的正确安装 右击我的电脑，选择属性，打开系统信息页面，点击右侧的高级系统设置，打开系统属性弹窗，当然，你也可以通过 Windows 10 的搜索直接搜索环境变量关键字找到这个页面 点击环境变量按钮，在系统变量的类别下，我们执行如下的三步操作 新建系统环境变量 JAVA_HOME，变量值为解压后的 OpenJDK 所在的路径，例如我这里配置的 E:\\sdk\\jdk-11.0.2 新建系统环境变量值 CLASS_PATH，具体对应的值为 %Java_Home%\\lib; 修改已经存在的 PATH 变量，将 %JAVA_HOME%\\bin 添加到环境变量中 至此，针对 Java 的环境配置已经完成，此时为了避免一些奇怪的错误，建议你重启下电脑。在重启之后，可以通过 java --version 命令来查看是否已经配置成功，如果如下图一样可以显示出 Java 的版本信息，则代表 Java 环境已经配置成功 总结自此，目前使用到的软件所需的环境就已经安装配置完成了，在下一篇中就可以安装我们主要使用到的两个软件 Jenkins 和 SonarQube，从而配合我们已经存在的 Gitlab，构建自己的 CI/CD 服务 References 在携程，我们如何实践 DevOps The Product Managers’ Guide to Continuous Delivery and DevOps CI/CD是什么？如何理解持续集成、持续交付和持续部署","link":"/2020/10/02/build-a-devops-environment-for-the-dotnet-application/"},{"title":"使用 Github Actions 自动部署 Angular 应用到 Github Pages","text":"前言最近在学习 Angular，一些基础的语法也学习的差不多了，就在 github 上新建了一个代码仓库，准备用 ng-zorro 搭个后台应用的模板，方便自己以后写些小东西时可以直接使用。前端项目，最主要的还是能够实际看到，因此考虑找个地方部署，因为自己的博客是部署到 github page 上的，并且这个项目也只是一个静态网站，所以这里同样选择使用 github page 同时，考虑到发布项目时，虽然使用 github page 已经帮我们省略了拷贝文件到服务器上这一步，但是还是需要自己手动的敲命令来完成项目的发布，因为发布的流程很单一，所以这里选择通过 github action 这个自动化工具来实现程序的自动化部署 代码仓库地址：ingos-admin 预览地址：https://yuiter.com/ingos-admin Step by Step手动部署示例的 Angular 应用，你可以通过 Angular CLI 直接生成，如有需要，可以点击此链接进行跳转查看（电梯直达），这里就不演示创建的过程了 按照正常的前端项目发布流程，当我们需要发布时，需要使用 npm 命令来完成项目的打包。整个项目中所涉及的 npm 命令，我们可以通过查阅项目的 package.json 文件中的 scripts 节点进行查看 这里通过 Angular CLI 创建的项目可以通过 ng build 命令来完成项目的打包发布 当 build 命令执行完成后，项目根路径下 dist 文件夹中以项目名称命名的文件夹就是我们需要部署的文件。此时，如果是部署到自己的服务器上，只需要把这个文件夹拷贝到服务器上，通过 nginx 之类的服务器指向文件所在路径即可 同样的，当我们想要部署到 github page 时，我们也只需要将文件提交到 github 代码仓库中即可，之后 github 会自动完成应用的部署工作 因为 git 默认是会忽略编译生成的 dist 文件夹的，此时，想要把编译生成的文件推送到远程仓库，你需要修改 .gitignore 文件，或是通过 subtree 的形式，将 dist 文件夹作为一个分支推送到远程服务器 12345678# 创建并切换到 gh-pages 分支git checkout -b gh-pages# 将 dist 文件夹下的文件添加到 gh-pages 分支git add -f dist# 提交到本地分支git commit -m 'created gh-pages'# 推送到远程分支git subtree push --prefix dist origin gh-pages 当然，这样还是显得有些麻烦，对于 angular 应用来说，我们完全可以使用社区提供的 angular-cli-ghpages 插件来简化这个操作 首先我们需要通过 npm 将插件安装到需要部署的程序中 1ng add angular-cli-ghpages 安装完成之后，我们就可以通过 ng deploy 命令来完成部署，插件会自动把打包生成的文件发布到 github 上，并创建一个 gh-pages 分支作为 github page 显示的站点 1ng deploy --base-href=/ingos-admin/ 在之前学习 angular 中路由时有提到，在 angular 应用中，框架会将 index.html 文件中的 base 标签的 href 属性值配置为组件、模板、模块文件以及其它一些静态文件的基础路径地址。而当我们将程序部署到 github page 时，实际对应的网站地址是 https://&lt;username&gt;.github.io/&lt;repositoryname&gt;，因此，这里如果不指定 href 的话，程序会在根路径下去寻找站点相关的静态文件，毫无疑问，最终是无法找到的，所以这里我们需要调整 href 属性值 为我们的仓储名称 可以看到，在打包生成的 index.html 文件中，插件已经帮我们修改了 base 标签的 href 地址。以后当我们需要更新网站时，再使用上面的命令即可发布到 github page 上 因为每次执行 ng deploy 命令时都需要在命令中添加 base-href 参数，所以这里我们可以在 package.json 文件中添加一个 script，这样当后面我们需要发布时，直接执行自定义的 ng deploy 命令即可 12345678910111213{ \"name\": \"ingos-admin\", \"version\": \"1.0.0\", \"scripts\": { \"ng\": \"ng\", \"start\": \"ng serve\", \"build\": \"ng build\", \"deploy\": \"ng deploy --base-href=/ingos-admin/\", \"test\": \"ng test\", \"lint\": \"ng lint\", \"e2e\": \"ng e2e\" }} 自动部署在上面的操作中虽然实现了将程序部署到 github page，但是还是需要我们手动的通过 npm 命令来完成部署，接下来就进行改造，通过 github actions 来实现自动部署 github actions 与其它的各种自动化工具相似，允许我们通过指定特定的 git 事件来触发我们的自动化任务，例如这里我需要在推送代码到服务器的 master 分支时自动触发程序的发布事件 你可以在代码仓库的 Actions tab 页面新增一个 workflow，也可以直接在本地代码根路径中新建一个 .github/workflows 文件夹来存放相关的脚本，因为 github actions 的执行脚本采用的是 yaml 格式，所以这里对于代码格式有着严格的要求，而每一个 yaml 文件则是一个单独的 workflow 这里我通过直接调整 github 默认的 workflow 文件来实现自动化部署功能，整个 yaml 文件包含了如下的三个部分 name：当前 workflow 配置的名称 on：任务触发时机，这里是在向 github 上的 master 分支提交代码以及提交 PR 时进行触发 jobs：需要触发的任务信息，一个 workflow 可以包含多个的 job，这里只有一个名为 build 的 job 123456789101112131415161718192021222324252627282930313233# This is a basic workflow to help you get started with Actionsname: CI# Controls when the action will run. Triggers the workflow on push or pull request# events but only for the master branchon: push: branches: [master] pull_request: branches: [master]# A workflow run is made up of one or more jobs that can run sequentially or in paralleljobs: # This workflow contains a single job called \"build\" build: # The type of runner that the job will run on runs-on: ubuntu-latest # Steps represent a sequence of tasks that will be executed as part of the job steps: # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it - uses: actions/checkout@v2 # Runs a single command using the runners shell - name: Run a one-line script run: echo Hello, world! # Runs a set of commands using the runners shell - name: Run a multi-line script run: | echo Add other actions to build, echo test, and deploy your project. 一个 workflow 文件中最重要的就是包含的 jobs，它表明了当前 workflow 所能实现的功能，一个 job 任务主要包含了如下的属性 runs-on：当前 job 需要运行在的系统环境 steps：实现一个 job 需要执行的各个步骤 env：当前 job 执行时需要的各种环境变量 needs：当我们定义多个 job 时，默认是并行执行的，但是存在 job2 需要等 job1 执行完成后才可以执行的情况，这时，我们就可以在 needs 属性中指定 job2 依赖于 job1，从而确保整个 workflow 的正确执行 在 steps 节点中，定义了当前 job 需要执行的各个步骤，step 分为两种，一种是我们使用 users 属性来直接引用别人已经发布的 action，例如这里通过引用 github 官方的 actions/checkout@v2 在宿主机中执行 git checkout 命令来拉取代码；另一种，则是我们通过 run 属性来手动编写脚本 对于我们想要的实现的功能，其实只包含了如下的四步：拉取代码 =》安装 node.js 环境 =》还原依赖 =》部署发布 对于拉取代码以及安装 node.js 环境，我们可以使用 github 官方的 action 来简化我们的脚本，因为我们在每次构建时都需要执行 npm install 命令来还原项目所需的各种依赖，因此这里在执行 install 命令之前，我们可以通过官方的 actions/cache@v2 来缓存项目依赖，以加快构建的过程 这里在还原依赖时，使用到了 npm ci 而不是 npm install，从命令的名称就可以看出，ci 主要是在各种自动化环境构建时使用，通过读取 package-lock.json 文件中所包含的具体的依赖版本信息来加快还原过程 123456789101112131415161718192021222324252627steps: # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it - uses: actions/checkout@v2 # Install node js - name: Setup Node.js environment uses: actions/setup-node@v1 with: node-version: 12.x # Cache node modules - name: Cache node modules uses: actions/cache@v2 env: cache-name: cache-node-modules with: # npm cache files are stored in `~/.npm` on Linux/macOS path: ~/.npm key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('**/package-lock.json') }} restore-keys: | ${{ runner.os }}-build-${{ env.cache-name }}- ${{ runner.os }}-build- ${{ runner.os }}- # Install required dependencies to build app - name: Install dependencies run: npm ci 当还原完成之后，就可以执行 package.json 文件中的 deploy 命令了，这里需要注意，因为在 action 中执行的命令更多的都是只读权限，所以为了能够有足够的权限执行发布操作，我们需要在执行时在环境变量中附加上 GITHUB_TOKEN 变量 123456steps: # Use angular-cli-ghpages to deploy app - name: Deploy to github pages env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} run: npm run deploy secrets.GITHUB_TOKEN 因为是 github 默认创建的，因此我们可以在 workflow 中直接使用，而对于一些另外需要授权的服务，直接将密码写在 yaml 文件中会不安全，这时你就可以在代码仓库的 settings tab 下通过设置 secrets 密钥信息，然后就可以通过变量的方式在 workflow 中直接使用 当我们添加了环境变量之后，还需要对我们的实际执行的 npm 命令脚本进行一个调整 在本地执行发布命令时，本地的 git 配置中已经包含了相关的账户信息，而当在 workflow 中执行时因为处于一个匿名的状态，angular-cli-ghpages 没办法知道具体的执行人是谁，因此，我们需要在 ng deploy 命令中添加上 git 账户相关的配置参数 1234567{ \"name\": \"ingos-admin\", \"version\": \"1.0.0\", \"scripts\": { \"deploy\": \"ng deploy --no-silent --base-href=/ingos-admin/ --name='账户名' --email='密码'\" }} 至此，完整的 workflow 脚本如下，当我们将本地代码推送到 github 仓库时，就会自动完成程序的发布部署 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# This is a basic workflow to deploy angular app into github pagesname: Deploy Github Pages# Controls when the action will run. Triggers the workflow on push or pull request# events but only for the master branchon: push: branches: [master]# A workflow run is made up of one or more jobs that can run sequentially or in paralleljobs: build: # The type of runner that the job will run on runs-on: ubuntu-latest # Steps represent a sequence of tasks that will be executed as part of the job steps: # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it - uses: actions/checkout@v2 # Install node js - name: Setup Node.js environment uses: actions/setup-node@v1 with: node-version: 12.x # Cache node modules - name: Cache node modules uses: actions/cache@v2 env: cache-name: cache-node-modules with: # npm cache files are stored in `~/.npm` on Linux/macOS path: ~/.npm key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('**/package-lock.json') }} restore-keys: | ${{ runner.os }}-build-${{ env.cache-name }}- ${{ runner.os }}-build- ${{ runner.os }}- # Install required dependencies to build app - name: Install dependencies run: npm ci # Use angular-cli-ghpages to deploy app - name: Deploy to github pages env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} run: npm run deploy 这里需要需要注意，因为代码中包含了 workflow 文件，可能在推送到 github 时遇到如下的错误，此时需要我们对 access token 进行重新的设置 打开 GitHub Personal Access Tokens 页面，点击右侧的 Generate new token 按钮，选择新建一个 token 信息，在编辑权限时确保 workflow 有被勾选上， 复制生成的 token 信息，打开电脑的凭据管理器，在 Windows 凭据标签内，找到 github 相关的凭据，此时你可以将已经存在的凭据密码更新成刚才复制的 token 信息，或者直接将已经存在的 github 凭据删除，这样再推送到 github 时会要求你进行登录，重新登录时将密码录入为你复制的 token 信息即可 当推送成功之后，再次点击代码仓库的 Actions 菜单，则会显示已经执行的 workflow 记录，当我们点击具体的一个 workflow 记录，则可以显示出 workflow 中每个步骤的执行详情，你可以根据执行情况自行调整，至此，也就完成自动化部署的功能 参考 GitHub Actions 入门教程 是时候体验一下 github action 的魅力了 npm-ci Git Extensions is a great tool but the credential management is very weak","link":"/2020/07/19/deploy-angular-app-to-github-pages-with-github-actions/"},{"title":"在 ASP.NET Core 项目中使用 AutoMapper 进行实体映射","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在实际项目开发过程中，我们使用到的各种 ORM 组件都可以很便捷的将我们获取到的数据绑定到对应的 List&lt;T&gt; 集合中，因为我们最终想要在页面上展示的数据与数据库实体类之间可能存在很大的差异，所以这里更常见的方法是去创建一些对应于页面数据展示的 视图模型 类，通过对获取到的数据进行二次加工，从而满足实际页面显示的需要。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，如何更便捷的去实现 数据库持久化对象 与 视图对象 间的实体映射，避免我们在代码中去一次次的手工实现这一过程，就可以降低开发的工作量，而 AutoMapper 则是可以帮助我们便捷的实现实体转换这一过程的利器。所以，本章我们就来学习如何在 ASP.NET Core 项目中通过使用 AutoMapper 去完成实体间的映射。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，如果你习惯于从视图展现到持久化到数据库都采用数据库实体，那么本篇文章对你可能不会有任何的帮助。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仓储地址：https://github.com/Lanesra712/ingos-common/tree/master/sample/aspnetcore/aspnetcore-automapper-tutorial Step by Step&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AutoMapper 是一个 OOM(Object-Object-Mapping) 组件，从名字上就可以看出来，这一系列的组件主要是为了帮助我们实现实体间的相互转换，从而避免我们每次都采用手工编写代码的方式进行转换。在没有采用 OOM 组件之前，如果我们需要实现类似于一份数据在不同客户端显示不同的字段，我们只能以手工的、逐个属性赋值的方式实现数据在各个客户端数据类型间的数据传递，而 OOM 组件则可以很方便的帮我们实现这一需求。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一、几个概念&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面我们有提到 数据库持久化对象 和 视图对象 这两个概念，其实除了这两个对象的概念之外，还存在一个 数据传输对象 的概念，这里我们来简单阐述下这三种对象的概念。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据库持久化对象（Persistent Object）：顾名思义，这个对象是用来将我们的数据持久化到数据库，一般来说，持久化对象中的字段会与数据库中对应的 table 保持一致。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里，如果你采用了 DDD 的思想去指导设计系统架构，其实最终落地到我们代码中的其实是 领域对象（Domain Object），它与 数据库持久化对象 最显著的差异在于 领域对象 会包含当前业务领域的各种事件，而 数据库持久化对象 仅是包含了数据库中对应 table 的数据字段信息。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;视图对象（View Object）：视图对象 VO 是面向前端用户页面的，一般会包含呈现给用户的某个页面/组件中所包含的所有数据字段信息。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据传输对象（Data Transfer Object）：数据传输对象 DTO 一般用于前端展示层与后台服务层之间的数据传递，以一种媒介的形式完成 数据库持久化对象 与 视图对象 之间的数据传递。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里通过一个简单的示意图去解释下这三种对象的具体使用场景，在这个示例的项目中，我省略了数据传输对象，将数据库持久化对象直接转换成页面显示的视图对象。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、组件加载&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们需要通过 Nuget 将 AutoMapper 加载到项目中，因为这个示例项目只包含一个 MVC 的项目，并没有多余的分层，所以这里需要将两个使用到的 dll 都添加到这个 MVC 项目中。12Install-Package AutoMapperInstall-Package AutoMapper.Extensions.Microsoft.DependencyInjection &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我添加了 AutoMapper.Extensions.Microsoft.DependencyInjection 这个程序集，从这个程序集的名字就可以看出来，这个程序集主要是为了我们可以通过依赖注入的方式在项目中去使用 AutoMapper。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 .NET Fx 的时代，我们使用 AutoMapper 时，可能就像下面的代码一样，更多的是通过 Mapper 的几个静态方法来实现实体间的映射，不过在 .NET Core 程序中，我们首选还是采用依赖注入的方式去完成实体间的映射。123456// 构建实体映射规则Mapper.Initialize(cfg =&gt; cfg.CreateMap&lt;OrderModel, OrderDto&gt;());// 实体映射var order = new OrderModel{};OrderDto dto = Mapper.Map&lt;OrderModel,OrderDto&gt;(order); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三、使用案例&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为原本想要使用的示例项目是之前的 ingos-server 这个项目，由于目前自己有在学习 DDD 的知识，并且有在按照微软的 eShopOnContainers 这个项目中基于 DDD 思想设计的框架，对自己的这个 ingos-server 项目进行 DDD 化的调整，嗯，其实就是照葫芦画瓢，所以目前整个项目被我改的乱七八糟的，不太适合作为示例项目了，所以这里新创建了一个比较单纯的 ASP.NET Core MVC 项目来作为这篇文章的演示项目。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为这个示例项目只是为了演示如何在 ASP.NET Core 项目中去使用 AutoMapper，所以这里并没有进行分层，整个示例页面的运行流程就是，PostController 中的 List Action 调用 PostAppService 类中的 GetPostLists 方法去获取所有的文章数据，同时在这个方法中会进行实体映射，将我们从 PostDomain 中获取到的 PO 对象转换成页面展示的 VO 对象，项目中每个文件夹的作用见下图所示。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的示例项目是演示当我们从数据库获取到需要的数据后，如何完成从 PO 到 VO 的实体映射，PostModel（PO）和 PostViewModel（VO）的类定义如下所示。1234567891011121314151617181920212223242526public class PostModel{ public Guid Id { get; set; } public long SerialNo { get; set; } public string Title { get; set; } public string Author { get; set; } public string Image { get; set; } public short CategoryCode { get; set; } public bool IsDraft { get; set; } public string Content { get; set; } public DateTime ReleaseDate { get; set; } public virtual IList&lt;CommentModel&gt; Comments { get; set; }}public class PostViewModel{ public Guid Id { get; set; } public long SerialNo { get; set; } public string Title { get; set; } public string Author { get; set; } public short CategoryCode { get; set; } public string Category =&gt; CategoryCode == 1001 ? \".NET\" : \"杂谈\"; public string ReleaseDate { get; set; } public short CommentCounts { get; set; } public virtual int Count { get; set; }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们需要创建一个实体映射的配置类，需要继承于 AutoMapper 的 Profile 类，在无参构造函数中，我们就可以通过 CreateMap 方法去创建两个实体间的映射关系。123456789101112public class PostProfile : Profile{ /// &lt;summary&gt; /// ctor /// &lt;/summary&gt; public PostProfile() { // 配置 mapping 规则 // CreateMap&lt;PostModel, PostViewModel&gt;(); }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过泛型的 CreateMap 方法就可以完成我们从 PostModel(PO) 到 PostViewModel(VO) 的实体映射。当然，因为 AutoMapper 默认是通过匹配字段名称和类型进行自动匹配，所以如果你进行转换的两个类的中的某些字段名称不一样，这里我们就需要进行手动的编写转换规则。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像在这个需要进行实体映射的示例代码中，PostViewModel 中的 CommentCounts 字段是根据 PostModel 中 CommentModel 集合的数据个数进行赋值的，所以这里我们就需要对这个字段的转换规则进行修改。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 AutoMapper 中，我们可以通过 ForMember 方法对映射规则做进一步的加工。这里我们需要指明 PostViewModel 的 CommentCounts 字段的值是通过对 PostModel 中的 Comments 信息进行求和从而获取到的，最终实现的转换代码如下所示。12345678910111213public class PostProfile : Profile{ /// &lt;summary&gt; /// ctor /// &lt;/summary&gt; public PostProfile() { // 配置 mapping 规则 // CreateMap&lt;PostModel, PostViewModel&gt;() .ForMember(destination =&gt; destination.CommentCounts, source =&gt; source.MapFrom(i =&gt; i.Comments.Count())); }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ForMember 方法不仅可以进行指定不同名称的字段进行转换，也可以通过编写规则实现字段类型的转换。例如这里 PO 中的 ReleaseDate 字段其实是 DateTime 类型的，我们需要通过编写规则将该字段对应到 VO 中 string 类型的 ReleaseDate 字段上，最终的实现代码如下所示。1234567891011121314151617181920public class PostProfile : Profile{ /// &lt;summary&gt; /// ctor /// &lt;/summary&gt; public PostProfile() { // Config mapping rules // CreateMap&lt;PostModel, PostViewModel&gt;() .ForMember(destination =&gt; destination.CommentCounts, source =&gt; source.MapFrom(i =&gt; i.Comments.Count())) .ForMember(destination =&gt; destination.ReleaseDate, source =&gt; source.ConvertUsing(new DateTimeConverter())); }}public class DateTimeConverter : IValueConverter&lt;DateTime, string&gt;{ public string Convert(DateTime source, ResolutionContext context) =&gt; source.ToString(\"yyyy-MM-dd HH:mm:ss\");} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里很多人可能习惯将所有的实体映射规则都放到同一个 Profile 文件里面，因为这里采用是单体架构的项目，所以整个项目中会存在不同的模块，所以这里我是按照每个模块去创建对应的 Profile 文件。实际在 ingos-server 这个项目中的使用方式见下图所示。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们创建好对应的映射规则后，因为我们是采用依赖注入的方式进行使用，所以这里我们就需要将我们的匹配规则注入到 IServiceCollection 中。从之前加载的程序集的 github readme 描述中可以看到，我们需要将配置好的 Profile 类通过 AddAutoMapper 这个扩展方法进行注入。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为我们在实际项目中可能存在多个自定义的 Profile 文件，而我们肯定是需要将这些自定义规则都注入到 IServiceCollection 中。所以我在 AddAutoMapper 这个方法的基础上创建了一个 AddAutoMapperProfiles 方法去注入我们的实体映射规则。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过 AutoMapper 的说明我们可以看出来，所有的自定义的 Profile 类都是需要继承于 AutoMapper 的 Profile 基类，所以这里我是采用反射的方式，通过获取到程序集中所有继承于 Profile 类的类文件进行批量的注入到 IServiceCollection 中，具体的实现代码如下所示。123456789101112131415161718192021222324252627282930313233343536/// &lt;summary&gt;/// Automapper 映射规则配置扩展方法/// &lt;/summary&gt;public static class AutoMapperExtension{ public static IServiceCollection AddAutoMapperProfiles(this IServiceCollection services) { // 从 appsettings.json 中获取包含配置规则的程序集信息 string assemblies = ConfigurationManager.GetConfig(\"Assembly:Mapper\"); if (!string.IsNullOrEmpty(assemblies)) { var profiles = new List&lt;Type&gt;(); // 获取继承的 Profile 类型信息 var parentType = typeof(Profile); foreach (var item in assemblies.Split(new char[] { '|' }, StringSplitOptions.RemoveEmptyEntries)) { // 获取所有继承于 Profile 的类 // var types = Assembly.Load(item).GetTypes() .Where(i =&gt; i.BaseType != null &amp;&amp; i.BaseType.Name == parentType.Name); if (types.Count() != 0 || types.Any()) profiles.AddRange(types); } // 添加映射规则 if (profiles.Count() != 0 || profiles.Any()) services.AddAutoMapper(profiles.ToArray()); } return services; }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为我是将需要加载的程序集信息放到配置文件中的，所以这里我们只需要将包含 Profile 规则的程序集添加到对应的配置项下面就可以了，此时如果包含多个程序集，则需要使用 | 进行分隔。12345{ \"Assembly\": { \"Mapper\": \"aspnetcore-automapper-tutorial\" }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们将所有的实体映射规则注入到 IServiceCollection 中，就可以在代码中使用这些实体映射规则。和其它通过依赖注入的接口使用方式相同，我们只需要在使用到的地方注入 IMapper 接口，然后通过 Map 方法就可以完成实体间的映射，使用的代码如下。12345678910111213141516171819202122232425262728293031323334353637public class PostAppService : IPostAppService{ #region Initialize /// &lt;summary&gt; /// /// &lt;/summary&gt; private readonly IPostDomain _post; /// &lt;summary&gt; /// /// &lt;/summary&gt; private readonly IMapper _mapper; /// &lt;summary&gt; /// ctor /// &lt;/summary&gt; /// &lt;param name=\"post\"&gt;&lt;/param&gt; /// &lt;param name=\"mapper\"&gt;&lt;/param&gt; public PostAppService(IPostDomain post, IMapper mapper) { _post = post ?? throw new ArgumentNullException(nameof(post)); _mapper = mapper ?? throw new ArgumentNullException(nameof(mapper)); } #endregion Initialize /// &lt;summary&gt; /// 获取所有的文章信息 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public IList&lt;PostViewModel&gt; GetPostLists() { var datas = _post.GetPostLists(); return _mapper.Map&lt;IList&lt;PostModel&gt;, IList&lt;PostViewModel&gt;&gt;(datas); }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此我们就实现了在 ASP.NET Core 项目中使用 AutoMapper，实现后的结果如下图所示。 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本篇文章主要是演示下如何在 ASP.NET Core 项目中去使用 AutoMapper 来实现实体间的映射，因为之前只是在 .NET Fx 项目中有使用过这个组件，并没有在 .NET Core 项目中使用，所以这次趁着国庆节假期就来尝试如何在 .NET Core 项目中使用，整个组件使用起来其实是很简单的，但是使用后却可以给我们在实际的项目开发中省很多的事，所以就把自己的使用方法分享出来，如果对你有些许的帮助的话，不胜荣幸~~~","link":"/2019/10/06/get-started-with-automapper-in-asp-net-core/"},{"title":"在 ASP.NET Core 项目中使用 MediatR 实现中介者模式","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近有在看 DDD 的相关资料以及微软的 eShopOnContainers 这个项目中基于 DDD 的架构设计，在 Ordering 这个示例服务中，可以看到各层之间的代码调用与我们之前传统的调用方式似乎差异很大，整个项目各个层之间的代码全部是通过注入 IMediator 进行调用的，F12 查看源码后可以看到该接口是属于 MediatR 这个组件的。既然要照葫芦画瓢，那我们就先来了解下如何在 ASP.NET Core 项目中使用 MediatR。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仓储地址：https://github.com/Lanesra712/ingos-common/tree/master/sample/aspnetcore/aspnetcore-mediatr-tutorial Step by Step&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MediatR，从 github 的项目主页上可以看到作者对于这个项目的描述是基于中介者模式的 .NET 实现，是一种基于进程内的数据传递。也就是说这个组件主要实现的是在一个应用中实现数据传递，如果想要实现多个应用间的数据传递就不太适合了。从作者的 github 个人主页上可以看到，他还是 AutoMapper 这个 OOM 组件的作者，PS，如果你想要了解如何在 ASP.NET Core 项目中使用 AutoMapper，你可以查看我之前写的这一篇文章（电梯直达）。而对于 MediatR 来说，在具体的学习使用之前，我们先来了解下什么是中介者模式。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一、什么是中介者模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多舶来词的中文翻译其实最终都会与实际的含义相匹配，例如软件开发过程中的 23 种设计模式的中文名称，我们其实可以比较容易的从中文名称中得知出该设计模式具体想要实现的作用，就像这里介绍的中介者模式。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们通过代码实现实际的业务逻辑时，如果涉及到多个对象类之间的交互，通常我们都是会采用直接引用的形式，随着业务逻辑变的越来越复杂，对于一个简单的业务抽象出的实现方法中，可能会被我们添加上各种判断的逻辑或是对于数据的业务逻辑处理方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如一个简单的用户登录事件，我们可能最终会抽象出如下的业务流程实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445public bool Login(AppUserLoginDto dto, out string msg){ bool flag = false; try { // 1、验证码是否正确 flag = _redisLogic.GetValueByKey(dto.VerificationCode); if (!flag) { msg = \"验证码错误，请重试\"; return false; } // 2、验证账户密码是否正确 flag = _userLogic.GetAppUser(dto.Account.Trim(), dto.Password.Trim(), out AppUserDetailDto appUser); if (!flag) { msg = \"账户或密码错误，请重试\"; return false; } // 3、验证账户是否可以登录当前的站点（未被锁定 or 具有登录当前系统的权限...） flag = _authLogic.CheckIsAvailable(appUser); if (!flag) { msg = \"用户被禁止登录当前系统，请重试\"; return false; } // 4、设置当前登录用户信息 _authLogic.SetCurrentUser(appUser); // 5、记录登录记录 _userLogic.SaveLoginRecord(appUser); msg = \"\"; return true; } catch (Exception ex) { // 记录错误信息 msg = $\"用户登录失败：{ex.Message}\"; return false; }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们假设对于登录事件的实现方法存在于 UserAppService 这个类中，对于 redis 资源的操作在 RedisLogic 类中，对于用户相关资源的操作在 UserLogic 中，而对于权限校验相关的资源操作位于 AuthLogic 类中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到，为了实现 UserAppService 类中定义的登录方法，我们至少需要依赖于 RedisLogic、UserLogic 以及 AuthLogic，甚至在某些情况下可能在 UserLogic 和 AuthLogic 之间也存在着某种依赖关系，因此我们可以从中得到如下图所示的类之间的依赖关系。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个简单的登录业务尚且如此，如果我们需要对登录业务添加新的需求，例如现在很多网站的登录和注册其实是放在一起的，当登录时如果判断没有当前的用户信息，其实会催生创建新用户的流程，那么，对于原本的登录功能实现，是不是会存在继续添加新的依赖关系的情况。同时对于很多本身就很复杂的业务，最终实现出来的方法是不是会有更多的对象类之间存在各种的依赖关系，牵一发而动全身，后期修改测试的成本会不会变得更高。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么，中介者模式是如何解决这个问题呢？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上文有提到，对于舶来词的中文名称，中文更多的会根据实际的含义进行命名，试想一下我们在现实生活中提到中介，是不是更多的会想到房屋中介这一角色。当我们来到一个新的城市，面临着租房的问题，绝大多数的情况下，我们最终需要通过中介去达成我们租房的目的。在租房这个案例中，房屋中介其实就是一个中介者，他承接我们对于想要租的房子的各种需求，从自己的房屋数据库中去寻找符合条件的，最终以一个桥梁的形式，连接我们与房东，最终就房屋的租住达成一致。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而在软件开发中，中介者模式则是要求我们根据实际的业务去定义一个包含各种对象之间交互关系的对象类，之后，所有涉及到该业务的对象都只关联于这一个中介对象类，不再显式的调用其它类。采用了中介者模式之后设计的登录功能所涉及到的类依赖如下图所示，这里的 AppUserLoginEventHandler 其实就是我们的中介类。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，任何事都会有利有弊，不会存在百分百完美的事情，就像我们通过房租中介去寻找合适的房屋，最终我们需要付给中介一笔费用去作为酬劳，采用中介者模式设计的代码架构也会存在别的问题。因为在代码中引入了中介者这一对象，势必会增加我们代码的复杂度，可能会使原本很轻松就实现的代码变得复杂。同时，我们引入中介者模式的初衷是为了解决各个对象类之间复杂的引用关系，对于某些业务来说，本身就很复杂，最终必定会导致这个中介者对象异常复杂。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;毕竟，软件开发的过程中不会存在银弹去帮我们解决所有的问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么，在本篇文章的示例代码中，我将使用 MediatR 这一组件，通过引入中介者模式的思想来完成上面的用户登录这一案例。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、组件加载&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用 MediatR 之前，这里简单介绍下这篇文章的示例 demo 项目。这个示例项目的架构分层可以看成是介于传统的多层架构与采用 DDD 的思想的架构分层。嗯，你可以理解成四不像，属于那种传统模式下的开发人员在往 DDD 思想上进行迁移的成品，具体的代码分层说明解释如下。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;01_Infrastructure：基础架构层，这层会包含一些对于基础组件的配置或是帮助类的代码，对于每个新建的服务来说，该层的代码几乎都是差不多的，所以对于基础架构层的代码其实最好是发布到公有 or 私有的 Nuget 仓库中，然后我们直接在项目中通过 Nuget 去引用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于采用 DDD 的思想构建的项目来说，很多人可能习惯将一些实体的配置也放置在基础架构层，我的个人理解还是应该置于领域层，对于基础架构层，只做一些基础组件的封装。如果有什么不对的地方，欢迎在评论区提出。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;02_Domain：领域层，这层会包含我们根据业务划分出的领域的几乎所有重要的部分，有领域对象（Domain Object）、值对象（Value Object）、领域事件（Domain Event）、以及仓储（Repository）等等领域组件。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里虽然我创建了 AggregateModels（聚合实体）这个文件夹，其实在这个项目中，我创建的还是不包含任何业务逻辑的贫血模型。同时，对于仓储（Repository）在领域分层中是置于 Infrastructure（基础架构层）还是位于 Domain（领域层），每个人都会有自己的理解，这里我还是更倾向于放在 Domain 层中更符合其定位。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;03_Application：应用层，这一层会包含我们基于领域所封装出的各种实际的业务逻辑，每个封装出的服务应用之间并不会出现互相调用的情况。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sample.Api：API 接口层，这层就很简单了，主要是通过 API 接口暴露出我们基于领域对外提供的各种服务。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整个示例项目的分层结构如下图所示。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与使用其它的第三方组件的使用方式相同，在使用之前，我们需要在项目中通过 Nuget 添加对于 MediatR 的程序集引用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里需要注意，因为我们主要是通过引用 MediatR 来实现中介者模式，所以我们只需要在领域层和应用层加载 MediatR 即可。而对于 Sample.Api 这个 Web API 项目，因为需要通过依赖注入的方式来使用我们基于 MediatR 所构建出的各种服务，所以这里我们还要添加 MediatR.Extensions.Microsoft.DependencyInjection 这个程序集到 Sample.Api 中。12Install-Package MediatRInstall-Package MediatR.Extensions.Microsoft.DependencyInjection &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三、案例实现&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们在 Sample.Domain 这个类库的 AggregateModels 文件夹下添加 AppUser（用户信息）类 和 Address（地址信息） 类，这里虽然并没有采用 DDD 的思想去划分领域对象和值对象，我们创建出来的都是不含任何业务逻辑的贫血模型。但是在用户管理这个业务中，对于用户所包含的联系地址信息，其实是一种无状态的数据。也就是说对于同一个地址信息，不会因为置于多个用户中而出现数据的二义性。因此，对于地址信息来说，是不需要唯一的标识就可以区分出这个数据的，所以这里的 Address 类就不需要添加主键，其实也就是对应于领域建模中的值对象。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我是使用的 EF Core 作为项目的 ORM 组件，当创建好需要使用实体之后，我们在 Sample.Domain 这个类库下面新建一个 SeedWorks 文件夹，添加自定义的 DbContext 对象和用于执行 EF Core 第一次生成数据库时写入预置种子数据的信息类。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里需要注意，在 EF Core 中，当我们需要将编写的 C# 类通过 Code First 创建出数据库表时，我们的 C# 类必须包含主键信息。而对应到我们这里的 Address 类来说，它更多的是作为 AppUser 类中的属性信息来展示的，所以这里我们需要对 EF Core 生成数据库表的过程进行重写。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们在 SeedWorks 文件夹下创建一个新的文件夹 EntityConfigurations，在这里用来存放我们自定义的 EF Core 创建表的规则。新建一个继承于 IEntityTypeConfiguration 接口的 AppUserConfiguration 配置类，在接口默认 Configure 方法中，我们需要编写映射规则，将 Address 类作为 AppUser 类中的字段进行显示，最终实现后的代码如下所示。12345678910111213141516171819202122232425262728public class AppUserConfiguration : IEntityTypeConfiguration&lt;AppUser&gt;{ public void Configure(EntityTypeBuilder&lt;AppUser&gt; builder) { // 表名称 builder.ToTable(\"appuser\"); // 实体属性配置 builder.OwnsOne(i =&gt; i.Address, n =&gt; { n.Property(p =&gt; p.Province).HasMaxLength(50) .HasColumnName(\"Province\") .HasDefaultValue(\"\"); n.Property(p =&gt; p.City).HasMaxLength(50) .HasColumnName(\"City\") .HasDefaultValue(\"\"); n.Property(p =&gt; p.Street).HasMaxLength(50) .HasColumnName(\"Street\") .HasDefaultValue(\"\"); n.Property(p =&gt; p.ZipCode).HasMaxLength(50) .HasColumnName(\"ZipCode\") .HasDefaultValue(\"\"); }); }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当创建表的映射规则编写完成后，我们就可以对 UserApplicationDbContext 类进行重写 OnModelCreating 方法。在这个方法中，我们就可以去应用我们自定义设置的实体映射规则，从而让 EF Core 按照我们的想法去创建数据库，最终实现的代码如下所示。12345678910111213141516171819public class UserApplicationDbContext : DbContext{ public DbSet&lt;AppUser&gt; AppUsers { get; set; } public UserApplicationDbContext(DbContextOptions&lt;UserApplicationDbContext&gt; options) : base(options) { } /// &lt;summary&gt; /// /// &lt;/summary&gt; /// &lt;param name=\"modelBuilder\"&gt;&lt;/param&gt; protected override void OnModelCreating(ModelBuilder modelBuilder) { // 自定义 AppUser 表创建规则 modelBuilder.ApplyConfiguration(new AppUserConfiguration()); }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们创建好 DbContext 后，我们需要在 Startup 类的 ConfigureServices 方法中进行注入。在示例代码中，我使用的是 MySQL 8.0 数据库，将配置文件写入到 appsettings.json 文件中，最终注入 DbContext 的代码如下所示。123456public void ConfigureServices(IServiceCollection services){ // 配置数据库连接字符串 services.AddDbContext&lt;UserApplicationDbContext&gt;(options =&gt; options.UseMySql(Configuration.GetConnectionString(\"SampleConnection\")));} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据库的连接字符串配置如下。12345{ \"ConnectionStrings\": { \"SampleConnection\": \"server=127.0.0.1;database=sample.application;user=root;password=123456@sql;port=3306;persistsecurityinfo=True;\" }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上文有提到，除了创建一个 DbContext 对象，我们还创建了一个 DbInitializer 类用于在 EF Core 第一次执行创建数据库操作时将我们预置的信息写入到对应的数据库表中。这里我们只是简单的判断下 AppUser 这张表是否存在数据，如果没有数据，我们就添加一条新的记录，最终实现的代码如下所示。123456789101112131415161718192021222324252627public class DbInitializer{ public static void Initialize(UserApplicationDbContext context) { context.Database.EnsureCreated(); if (context.AppUsers.Any()) return; AppUser admin = new AppUser() { Id = Guid.NewGuid(), Name = \"墨墨墨墨小宇\", Account = \"danvic.wang\", Phone = \"13912345678\", Age = 12, Password = \"123456\", Gender = true, IsEnabled = true, Address = new Address(\"啦啦啦啦街道\", \"啦啦啦市\", \"啦啦啦省\", \"12345\"), Email = \"danvic.wang@yuiter.com\", }; context.AppUsers.Add(admin); context.SaveChanges(); }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们完成种子数据植入的代码，我们需要在程序启动之前就去执行我们的代码。因此我们需要修改 Program 类中的 Main 方法，实现在运行 web 程序之前去执行种子数据的植入。1234567891011121314151617181920public class Program{ public static void Main(string[] args) { var host = CreateWebHostBuilder(args).Build(); using (var scope = host.Services.CreateScope()) { // 执行种子数据植入 // var services = scope.ServiceProvider; var context = services.GetRequiredService&lt;UserApplicationDbContext&gt;(); DbInitializer.Initialize(context); } } public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&gt; WebHost.CreateDefaultBuilder(args) .UseStartup&lt;Startup&gt;();} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时，运行我们的项目，程序就会自动执行创建数据库的操作，同时会将我们预设好的种子数据写入到数据库表中，最终实现的效果如下图所示。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基础的项目代码已经完成之后，我们就可以开始学习如何通过 MediatR 来实现中介者模式。在这一章的示例项目中，我们会使用到 MediatR 中两个很重要的接口类型：IRequest 和 INotification。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Github 上，作者针对这两个接口做了如下的解释，这里我会按照我的理解去进行使用。同时，为了防止我的理解出现了偏差，从而对各位造成影响，这里贴上作者回复解释的原文。 Requests are for:1 request to 1 handler. Handler may or may not return a value Notifications are for:1 notification to n handlers. Handler may not return a value. In practical terms, requests are “commands”, notifications are “events”.Command would be directing MediatR to do something like “ApproveInvoiceCommand -&gt; ApproveInvoiceHandler”. Event would benotifications, like “InvoiceApprovedEvent -&gt; SendThankYouEmailToCustomerHandler” &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于继承于 IRequest 接口的类来说，一个请求（request）只会有一个针对这个请求的处理程序（requestHandler），它可以返回值或者不返回任何信息；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而对于继承于 INotification 接口的类来说，一个通知（notification）会对应多个针对这个通知的处理程序（notificationHandlers），而它们不会返回任何的数据。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请求（request）更像是一种命令（command），而通知（notification）更像是一种事件（event）。嗯，可能看起来更晕了，jbogard 这里给了一个案例给我们进一步的解释了 request 与 notification 之间的差异性。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;双十一刚过，很多人都会疯狂剁手，对于购买大件来说，为了能够更好地拥有售后服务，我们在购买后肯定会期望商家给我们提供发票，这里的要求商家提供发票就是一种 request，而针对我们的这个请求，商家会做出回应，不管能否开出来发票，商家都应当通知到我们，这里的通知用户就是一种 notification。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于提供发票这个 request 来说，不管最终的结果如何，它只会存在一种处理方式；而对于通知用户这个 notification 来说，商家可以通过短信通知，可以通过公众号推送，也可以通过邮件通知，不管采用什么方式，只要完成了通知，对于这个事件来说也就已经完成了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而对应于用户登录这个业务来说，用户的登录行为其实就是一个 request，对于这个 request 来说，我们可能会去数据库查询账户是否存在，判断是不是具有登录系统的权限等等。而不管我们在这个过程中做了多少的逻辑判断，它只会有两种结果，登录成功或登录失败。而对于用户登录系统之后可能需要设置当前登录人员信息，记录用户登录日志这些行为来说，则是归属于 notification 的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;弄清楚了用户登录事件中的 request 和 notification 划分，那么接下来我们就可以通过代码来实现我们的功能。这里对于示例项目中的一些基础组件的配置我就跳过了，如果你想要具体的了解这里使用到的一些组件的使用方法，你可以查阅我之前的文章。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们在 Sample.Application 这个类库下面创建一个 Commands 文件夹，在下面存放用户的请求信息。现在我们创建一个用于映射用户登录请求的 UserLoginCommand 类，它需要继承于 IRequest&lt;T&amp;gt 这个泛型接口。因为对于用户登录这个请求来说，只会有可以或不可以这两个结果，所以对于这个请求的响应的结果是 bool 类型的，也就是说，我们具体应该继承的是 IRequest&lt;bool&gt;。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于用户发起的各种请求来说，它其实只是包含了对于这次请求的一些基本信息，而对于 UserLoginCommand 这个用户登录请求类来说，它可能只会有账号、密码、验证码这三个信息，请求类代码如下所示。123456789101112131415161718192021222324252627282930public class UserLoginCommand : IRequest&lt;bool&gt;{ /// &lt;summary&gt; /// 账户 /// &lt;/summary&gt; public string Account { get; private set; } /// &lt;summary&gt; /// 密码 /// &lt;/summary&gt; public string Password { get; private set; } /// &lt;summary&gt; /// 验证码 /// &lt;/summary&gt; public string VerificationCode { get; private set; } /// &lt;summary&gt; /// ctor /// &lt;/summary&gt; /// &lt;param name=\"account\"&gt;账户&lt;/param&gt; /// &lt;param name=\"password\"&gt;密码&lt;/param&gt; /// &lt;param name=\"verificationCode\"&gt;验证码&lt;/param&gt; public UserLoginCommand(string account, string password, string verificationCode) { Account = account; Password = password; VerificationCode = verificationCode; }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们拥有了存储用户登录请求信息的类之后，我们就需要对用户的登录请求进行处理。这里，我们在 Sample.Application 这个类库下面新建一个 CommandHandlers 文件夹用来存放用户请求的处理类。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们创建一个继承于 IRequestHandler 接口的 UserLoginCommandHandler 类用来实现对于用户登录请求的处理。IRequestHandler 是一个泛型的接口，它需要我们在继承时声明我们需要实现的请求，以及该请求的返回信息。因此，对于 UserLoginCommand 这个请求来说，UserLoginCommandHandler 这个请求的处理类，最终需要继承于 IRequestHandler&lt;UserLoginCommand, bool&gt;。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就像上面提到的一样，我们需要在这个请求的处理类中对用户请求的信息进行处理，在 UserLoginCommandHandler 类中，我们应该在 Handle 方法中去执行我们的判断逻辑，这里我们会引用到仓储来获取用户的相关信息。仓储中的代码这里我就不展示了，最终我们实现后的代码如下所示。12345678910111213141516171819202122232425262728293031323334353637383940public class UserLoginCommandHandler : IRequestHandler&lt;UserLoginCommand, bool&gt;{ #region Initizalize /// &lt;summary&gt; /// 仓储实例 /// &lt;/summary&gt; private readonly IUserRepository _userRepository; /// &lt;summary&gt; /// ctor /// &lt;/summary&gt; /// &lt;param name=\"userRepository\"&gt;&lt;/param&gt; public UserLoginCommandHandler(IUserRepository userRepository) { _userRepository = userRepository ?? throw new ArgumentNullException(nameof(userRepository)); } #endregion Initizalize /// &lt;summary&gt; /// Command Handler /// &lt;/summary&gt; /// &lt;param name=\"request\"&gt;&lt;/param&gt; /// &lt;param name=\"cancellationToken\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;bool&gt; Handle(UserLoginCommand request, CancellationToken cancellationToken) { // 1、判断验证码是否正确 if (string.IsNullOrEmpty(request.VerificationCode)) return false; // 2、验证登录密码是否正确 var appUser = await _userRepository.GetAppUserInfo(request.Account.Trim(), request.Password.Trim()); if (appUser == null) return false; return true; }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们完成了对于请求的处理代码后，就可以在 controller 中提供用户访问的入口。当然，因为我们需要采用依赖注入的方式去使用 MediatR，所以在使用之前，我们需要将请求的对应处理关系注入到依赖注入容器中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在通过依赖注入的方式使用 MediatR 时，我们需要将所有的事件（请求以及通知）注入到容器中，而 MediatR 则会自动寻找对应事件的处理类，除此之外，我们也需要将通过依赖注入使用到的 IMediator 接口的实现类注入到容器中。而在这个示例项目中，我们主要是在 Sample.Domain、Sample.Application 以及我们的 Web Api 项目中使用到了 MediatR，因此，我们需要将这三个项目中使用到 MediatR 的类全部注入到容器中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个个的注入会比较的麻烦，所以这里我还是采用对指定的程序集进行反射操作，去获取需要加载的信息批量的进行注入操作，最终实现后的代码如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445public static IServiceCollection AddCustomMediatR(this IServiceCollection services, MediatorDescriptionOptions options){ // 获取 Startup 类的 type 类型 var mediators = new List&lt;Type&gt; { options.StartupClassType }; // IRequest&lt;T&gt; 接口的 type 类型 var parentRequestType = typeof(IRequest&lt;&gt;); // INotification 接口的 type 类型 var parentNotificationType = typeof(INotification); foreach (var item in options.Assembly) { var instances = Assembly.Load(item).GetTypes(); foreach (var instance in instances) { // 判断是否继承了接口 // var baseInterfaces = instance.GetInterfaces(); if (baseInterfaces.Count() == 0 || !baseInterfaces.Any()) continue; // 判断是否继承了 IRequest&lt;T&gt; 接口 // var requestTypes = baseInterfaces.Where(i =&gt; i.IsGenericType &amp;&amp; i.GetGenericTypeDefinition() == parentRequestType); if (requestTypes.Count() != 0 || requestTypes.Any()) mediators.Add(instance); // 判断是否继承了 INotification 接口 // var notificationTypes = baseInterfaces.Where(i =&gt; i.FullName == parentNotificationType.FullName); if (notificationTypes.Count() != 0 || notificationTypes.Any()) mediators.Add(instance); } } // 添加到依赖注入容器中 services.AddMediatR(mediators.ToArray()); return services;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为需要知道哪些程序集应该进行反射获取信息，而对于 Web Api 这个项目来说，它只会通过依赖注入使用到 IMediator 这一个接口，所以这里需要采用不同的参数的形式去确定具体需要通过反射加载哪些程序集。123456789101112public class MediatorDescriptionOptions{ /// &lt;summary&gt; /// Startup 类的 type 类型 /// &lt;/summary&gt; public Type StartupClassType { get; set; } /// &lt;summary&gt; /// 包含使用到 MediatR 组件的程序集 /// &lt;/summary&gt; public IEnumerable&lt;string&gt; Assembly { get; set; }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终，我们就可以在 Startup 类中通过扩展方法的信息进行快速的注入，实际使用的代码如下，这里我是将需要加载的程序集信息放在 appsetting 这个配置文件中的，你可以根据你的喜好进行调整。12345678910111213public class Startup{ // This method gets called by the runtime. Use this method to add services to the container. public void ConfigureServices(IServiceCollection services) { // Config mediatr services.AddCustomMediatR(new MediatorDescriptionOptions { StartupClassType = typeof(Startup), Assembly = Configuration[\"Assembly:Mediator\"].Split(\"|\", StringSplitOptions.RemoveEmptyEntries) }); }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个示例项目中的配置信息如下所示。1234567{ \"Assembly\": { \"Function\": \"Sample.Domain\", \"Mapper\": \"Sample.Application\", \"Mediator\": \"Sample.Application|Sample.Domain\" }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们注入完成后，就可以直接在 controller 中进行使用。对于继承了 IRequest 的方法，可以直接通过 Send 方法进行调用请求信息，MediatR 会帮我们找到对应请求的处理方法，最终登录 action 中的代码如下。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758[ApiVersion(\"1.0\")][ApiController][Route(\"api/v{version:apiVersion}/[controller]\")]public class UsersController : ControllerBase{ #region Initizalize /// &lt;summary&gt; /// /// &lt;/summary&gt; private readonly IMediator _mediator; /// &lt;summary&gt; /// ctor /// &lt;/summary&gt; /// &lt;param name=\"mediator\"&gt;&lt;/param&gt; public UsersController(IMediator mediator) { _mediator = mediator ?? throw new ArgumentNullException(nameof(mediator)); } #endregion Initizalize #region APIs /// &lt;summary&gt; /// 用户登录 /// &lt;/summary&gt; /// &lt;param name=\"login\"&gt;用户登录数据传输对象&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; [HttpPost(\"login\")] [ProducesResponseType(StatusCodes.Status200OK)] [ProducesResponseType(StatusCodes.Status401Unauthorized)] public async Task&lt;IActionResult&gt; Post([FromBody] AppUserLoginDto login) { // 实体映射转换 var command = new UserLoginCommand(login.Account, login.Password, login.VerificationCode); bool flag = await _mediator.Send(command); if (flag) return Ok(new { code = 20001, msg = $\"{login.Account} 用户登录成功\", data = login }); else return Unauthorized(new { code = 40101, msg = $\"{login.Account} 用户登录失败\", data = login }); } #endregion APIs} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们完成了对于用户登录请求的处理之后，就可以去执行后续的“通知类”的事件。与用户登录的请求信息类相似，对于用户登录事件的通知类也只是包含一些通知的基础信息。在 Smaple.Domain 这个类库下面，创建一个 Events 文件用来存放我们的事件，我们来新建一个继承于 INotification 接口的 AppUserLoginEvent 类，用来对用户登录事件进行相关的处理。12345678910111213141516public class AppUserLoginEvent : INotification{ /// &lt;summary&gt; /// 账户 /// &lt;/summary&gt; public string Account { get; } /// &lt;summary&gt; /// ctor /// &lt;/summary&gt; /// &lt;param name=\"account\"&gt;&lt;/param&gt; public AppUserLoginEvent(string account) { Account = account; }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上文中有提到过，对于一个通知事件可能会存在着多种处理方式，所以这里我们在 Smaple.Application 这个类库的 DomainEventHandlers 文件夹下面会按照事件去创建对应的文件夹去存放实际处理方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于继承了 INotification 接口的通知类来说，在 MediatR 中我们可以通过创建继承于 INotificationHandler 接口的类去处理对应的事件。因为一个 notification 可以有多个的处理程序，所以我们可以创建多个的 NotificationHandler 类去处理同一个 notification。一个示例的 NotificationHandler 类如下所示。123456789101112131415161718192021222324252627282930313233public class SetCurrentUserEventHandler : INotificationHandler&lt;AppUserLoginEvent&gt;{ #region Initizalize /// &lt;summary&gt; /// /// &lt;/summary&gt; private readonly ILogger&lt;SetCurrentUserEventHandler&gt; _logger; /// &lt;summary&gt; /// /// &lt;/summary&gt; /// &lt;param name=\"logger\"&gt;&lt;/param&gt; public SetCurrentUserEventHandler(ILogger&lt;SetCurrentUserEventHandler&gt; logger) { _logger = logger ?? throw new ArgumentNullException(nameof(logger)); } #endregion Initizalize /// &lt;summary&gt; /// Notification handler /// &lt;/summary&gt; /// &lt;param name=\"notification\"&gt;&lt;/param&gt; /// &lt;param name=\"cancellationToken\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public Task Handle(AppUserLoginEvent notification, CancellationToken cancellationToken) { _logger.LogInformation($\"CurrentUser with Account: {notification.Account} has been successfully setup\"); return Task.FromResult(true); }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何去引发这个事件，对于领域驱动设计的架构来说，一个更好的方法是将各种领域事件添加到事件的集合中，然后在提交事务之前或之后立即调度这些域事件，而对于我们这个项目来说，因为这不在这篇文章考虑的范围内，只是演示如何去使用 MediatR 这个组件，所以这里我就采取在请求逻辑处理完成后直接触发事件的方式。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 UserLoginCommandHandler 类中，修改我们的代码，在确认登录成功后，通过调用 AppUser 类的 SetUserLoginRecord 方法来触发我们的通知事件，修改后的代码如下所示。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class UserLoginCommandHandler : IRequestHandler&lt;UserLoginCommand, bool&gt;{ #region Initizalize /// &lt;summary&gt; /// 仓储实例 /// &lt;/summary&gt; private readonly IUserRepository _userRepository; /// &lt;summary&gt; /// /// &lt;/summary&gt; private readonly IMediator _mediator; /// &lt;summary&gt; /// ctor /// &lt;/summary&gt; /// &lt;param name=\"userRepository\"&gt;&lt;/param&gt; /// &lt;param name=\"mediator\"&gt;&lt;/param&gt; public UserLoginCommandHandler(IUserRepository userRepository, IMediator mediator) { _userRepository = userRepository ?? throw new ArgumentNullException(nameof(userRepository)); _mediator = mediator ?? throw new ArgumentNullException(nameof(mediator)); } #endregion Initizalize /// &lt;summary&gt; /// Command Handler /// &lt;/summary&gt; /// &lt;param name=\"request\"&gt;&lt;/param&gt; /// &lt;param name=\"cancellationToken\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;bool&gt; Handle(UserLoginCommand request, CancellationToken cancellationToken) { // 1、判断验证码是否正确 if (string.IsNullOrEmpty(request.VerificationCode)) return false; // 2、验证登录密码是否正确 var appUser = await _userRepository.GetAppUserInfo(request.Account.Trim(), request.Password.Trim()); if (appUser == null) return false; // 3、触发登录事件 appUser.SetUserLoginRecord(_mediator); return true; }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与使用 Send 方法去调用 request 类的请求不同，对于继承于 INotification 接口的事件通知类，我们需要采用 Publish 的方法去调用。至此，对于一个采用中介者模式设计的登录流程就结束了，SetUserLoginRecord 方法的定义，以及最终我们实现的效果如下所示。1234public void SetUserLoginRecord(IMediator mediator){ mediator.Publish(new AppUserLoginEvent(Account));} 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一章主要是介绍了如何通过 MediatR 来实现中介者模式，因为自己也是第一次接触这种思想，对于 MediatR 这个组件也是第一次使用，所以仅仅是采用案例分享的方式对中介者模式的使用方法进行了一个解释。如果你想要对中介者模式的具体定义与基础的概念进行进一步的了解的话，可能需要你自己去找资料去弄明白具体的定义。因为初次接触，难免会有遗漏或错误，如果从文章中发现有不对的地方，欢迎在评论区中指出，先行感谢。 参考&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、中介者模式— Graphic Design Patterns - 图说设计模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、MediatR 知多少","link":"/2019/11/19/get-started-with-mediatr-in-asp-net-core/"},{"title":"Angular 从入坑到挖坑 - Angular 使用入门","text":"Overviewangular 入坑记录的笔记第一篇，完成开发环境的搭建，以及如何通过 angular cli 来创建第一个 angular 应用。入坑一个多星期，通过学习官方文档以及手摸手的按教程敲官方的快速上手项目，很像后端，嗯，完美的契合了我这种后端开发人员。 对应官方文档地址： 搭建本地开发环境和工作空间 ng new ng serve 工作区和项目文件结构 配套代码地址：angular-practice/src/getting-started Contents Angular 从入坑到弃坑 - Angular 使用入门 Knowledge Graph Step by Step通过 Angular CLI 创建第一个 Angular 应用开发环境搭建前提条件 node.js 版本高于 10.9.0 包含 npm 客户端 12345## 查看 node 版本node -v## 查看 npm 版本npm -v 全局安装 Angular CLI 12## 在电脑上以全局安装的方式安装 angular clinpm install -g @angular/cli 验证是否安装成功 12345## 查看 angular cli 版本ng v## 查看 angular cli 中的各种命令解释ng help 运行第一个 Angular 应用通过 Angular CLI 命令来创建一个新的应用 12## 指定位置，创建新的 angular 应用ng new my-app 常用命令参数 options 解释 –force 强制覆盖现有文件 –skipInstall 创建项目时跳过 npm install 命令 –strict 在代码中使用更严格的 typescript 编译选项 运行项目 12## 运行项目ng serve 常用命令参数 options 解释 –open / -o 是否直接打开浏览器 –port 指定程序运行的端口 项目结构、文件功能了解 e2e - 端到端测试文件 src - 单元测试源代码路径 app.e2e-spec.ts - 针对当前应用的端到端单元测试文件 app.po.ts - 单元测试源文件 protractor.conf.js - protractor 测试工具配置文件 tsconfig.json - 继承于工作空间根目录的 typescript 配置文件 src - 工作空间 [^1] 最外层根项目的源代码路径 app - 系统所提供的各种功能 app-routing.module.ts - 项目的路由模块，用来定义项目的前端路由信息 app.component.html - 项目的根组件所关联的 HTML 页面 app.component.scss - 项目的根组件 HTML 页面的样式信息 app.component.spec.ts - 项目的根组件单元测试文件 app.component.ts - 项目的根组件逻辑 app.module.ts - 应用的根模块 assets - 系统需要使用的静态资源文件 environments - 针对不同环境的构建配置选项 favicon.ico - 网站图标 index.html - 应用的主页面 main.ts - 应用的入口程序 polyfills.ts - 针对不同浏览器对于原生 API 的支持程度不相同的情况，用来抹平不同浏览器之间的支持差异 [^2] styles.scss - 项目的全局样式文件 test.ts - 单元测试的主入口程序 .editorconfig - 针对不同代码编辑器间的代码风格规范 .gitignore - git 忽略的文件 angular.json - 应用于当前工作空间的一些默认配置以及供 angular cli 和开发工具使用的配置信息 browserslist - 项目所针对的目标浏览器 [^3] karma.conf.js - 基于 node.js 的 javascript 测试执行过程管理工具 package-lock.json - 针对当前工作空间使用到 npm 包，安装到 node_modules 时的版本信息 package.json - 当前工作空间中所有项目会使用到的 npm 包依赖 README.md - 当前工作空间最外层根应用的简介文件 tsconfig.app.json - 当前工作空间最外层根应用的专属 typescript 配置文件 tsconfig.json - 当前工作空间中各个项目的基础 typescript 配置文件 tsconfig.spec.json - 当前工作空间最外层根应用的专属 tslint 配置文件 tslint.json - 当前工作空间中各个项目的基础 tslint 配置文件 [^1]: 工作空间类似于 .NET 项目中的解决方案，在一个工作空间内可以创建多个的项目 [^2]: 现代浏览器支持的某些原生 API，当用户使用老版本的浏览器或某些浏览器时并不支持，只要使用了 polyfills 这个库， 即可对于这些无法使用的浏览器添加支持，使用方法也无需更改（PS：针对的是原生的 API） [^3]: 还是因为不同浏览器支持的特性不同，或者是 css 样式前缀不同，通过 browserslist 来告诉项目中的各种前端工具，完成自动配置的过程","link":"/2020/02/13/getting-started-with-angular/"},{"title":"Angular 从入坑到挖坑 - 路由守卫连连看","text":"OverviewAngular 入坑记录的笔记第六篇，介绍 Angular 路由模块中关于路由守卫的相关知识点，了解常用到的路由守卫接口，知道如何通过实现路由守卫接口来实现特定的功能需求，以及实现对于特性模块的惰性加载 对应官方文档地址： 路由与导航 配套代码地址：angular-practice/src/router-combat Contents Angular 从入坑到弃坑 - Angular 使用入门 Angular 从入坑到挖坑 - 组件食用指南 Angular 从入坑到挖坑 - 表单控件概览 Angular 从入坑到挖坑 - HTTP 请求概览 Angular 从入坑到挖坑 - Router 路由使用入门指北 Angular 从入坑到挖坑 - 路由守卫连连看 Knowledge Graph Step by Step基础准备重复上一篇笔记的内容，搭建一个包含路由配置的 Angualr 项目 新建四个组件，分别对应于三个实际使用到的页面与一个设置为通配路由的 404 页面 1234567891011-- 危机中心页面ng g component crisis-list-- 英雄中心页面ng g component hero-list-- 英雄相亲页面ng g component hero-detail-- 404 页面ng g component page-not-found 在 app-routing.module.ts 文件中完成对于项目路由的定义，这里包含了对于路由的重定向、通配路由，以及通过动态路由进行参数传递的使用 1234567891011121314151617181920212223242526272829303132333435363738import { NgModule } from '@angular/core';import { Routes, RouterModule } from '@angular/router';// 引入组件import { CrisisListComponent } from './crisis-list/crisis-list.component';import { HeroListComponent } from './hero-list/hero-list.component';import { HeroDetailComponent } from './hero-detail/hero-detail.component';import { PageNotFoundComponent } from './page-not-found/page-not-found.component';const routes: Routes = [ { path: 'crisis-center', component: CrisisListComponent, }, { path: 'heroes', component: HeroListComponent, }, { path: 'hero/:id', component: HeroDetailComponent, }, { path: '', redirectTo: '/heroes', pathMatch: 'full', }, { path: '**', component: PageNotFoundComponent, }];@NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule],})export class AppRoutingModule { } 之后，在根组件中，添加 router-outlet 标签用来声明路由在页面上渲染的出口 123456&lt;h1&gt;Angular Router&lt;/h1&gt;&lt;nav&gt; &lt;a routerLink=\"/crisis-center\" routerLinkActive=\"active\"&gt;Crisis Center&lt;/a&gt; &amp;nbsp;&amp;nbsp; &lt;a routerLink=\"/heroes\" routerLinkActive=\"active\"&gt;Heroes&lt;/a&gt;&lt;/nav&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt; 路由守卫在 Angular 中，路由守卫主要可以解决以下的问题 对于用户访问页面的权限校验（是否已经登录？已经登录的角色是否有权限进入？） 在跳转到组件前获取某些必须的数据 离开页面时，提示用户是否保存未提交的修改 Angular 路由模块提供了如下的几个接口用来帮助我们解决上面的问题 CanActivate：用来处理系统跳转到到某个路由地址的操作（判断是否可以进行访问） CanActivateChild：功能同 CanActivate，只不过针对的是子路由 CanDeactivate：用来处理从当前路由离开的情况（判断是否存在未提交的信息） CanLoad：是否允许通过延迟加载的方式加载某个模块 在添加了路由守卫之后，通过路由守卫返回的值，从而达到我们控制路由的目的 true：导航将会继续 false：导航将会中断，用户停留在当前的页面或者是跳转到指定的页面 UrlTree：取消当前的导航，并导航到路由守卫返回的这个 UrlTree 上（一个新的路由信息） CanActivate：认证授权在实现路由守卫之前，可以通过 Angular CLI 来生成路由守卫的接口实现类，通过命令行，在 app/auth 路径下生成一个授权守卫类，CLI 会提示我们选择继承的路由守卫接口，这里选择 CanActivate 即可 1ng g guard auth/auth 在 AuthGuard 这个路由守卫类中，我们模拟了是否允许访问一个路由地址的认证授权。首先判断是否已经登录，如果登录后再判断当前登录人是否具有当前路由地址的访问权限 123456789101112131415161718192021222324252627282930313233343536import { Injectable } from '@angular/core';import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, UrlTree, Router } from '@angular/router';import { Observable } from 'rxjs';@Injectable({ providedIn: 'root'})export class AuthGuard implements CanActivate { /** * ctor * @param router 路由 */ constructor(private router: Router) { } canActivate( next: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable&lt;boolean | UrlTree&gt; | Promise&lt;boolean | UrlTree&gt; | boolean | UrlTree { // 判断是否有 token 信息 let token = localStorage.getItem('auth-token') || ''; if (token === '') { this.router.navigate(['/login']); return false; } // 判断是否可以访问当前连接 let url: string = state.url; if (token === 'admin' &amp;&amp; url === '/crisis-center') { return true; } this.router.navigate(['/login']); return false; }} 之后我们就可以在 app-routing.module.ts 文件中引入 AuthGuard 类，针对需要保护的路由进行路由守卫的配置 12345678910111213141516171819202122import { NgModule } from '@angular/core';import { Routes, RouterModule } from '@angular/router';// 引入组件import { CrisisListComponent } from './crisis-list/crisis-list.component';// 引入路由守卫import { AuthGuard } from './auth/auth.guard';const routes: Routes = [ { path: 'crisis-center', component: CrisisListComponent, canActivate: [AuthGuard], // 添加针对当前路由的 canActivate 路由守卫 }];@NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule],})export class AppRoutingModule { } CanActivateChild：针对子路由的认证授权与继承 CanActivate 接口进行路由守卫的方式相似，针对子路由的认证授权可以通过继承 CanActivateChild 接口来实现，因为授权的逻辑很相似，这里通过多重继承的方式，扩展 AuthGuard 的功能，从而达到同时针对路由和子路由的路由守卫 改造下原先 canActivate 方法的实现，将认证逻辑修改为用户的 token 信息中包含 admin 即可访问 crisis-center 页面，在针对子路由进行认证授权的 canActivateChild 方法中，通过判断 token 信息是否为 admin-master 模拟完成对于子路由的访问认证 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import { Injectable } from '@angular/core';import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, UrlTree, Router, CanActivateChild } from '@angular/router';import { Observable } from 'rxjs';@Injectable({ providedIn: 'root'})export class AuthGuard implements CanActivate, CanActivateChild { /** * ctor * @param router 路由 */ constructor(private router: Router) { } canActivate( next: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable&lt;boolean | UrlTree&gt; | Promise&lt;boolean | UrlTree&gt; | boolean | UrlTree { // 判断是否有 token 信息 let token = localStorage.getItem('auth-token') || ''; if (token === '') { this.router.navigate(['/login']); return false; } // 判断是否可以访问当前连接 let url: string = state.url; if (token.indexOf('admin') !== -1 &amp;&amp; url.indexOf('/crisis-center') !== -1) { return true; } this.router.navigate(['/login']); return false; } canActivateChild( childRoute: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean | UrlTree | Observable&lt;boolean | UrlTree&gt; | Promise&lt;boolean | UrlTree&gt; { let token = localStorage.getItem('auth-token') || ''; if (token === '') { this.router.navigate(['/login']); return false; } return token === 'admin-master'; }} 通过 Angular CLI 新增一个 crisis-detail 组件，作为 crisis-list 的子组件 1ng g component crisis-detail 接下来在 crisis-list 中添加 router-outlet 标签，用来定义子路由的渲染出口 123456789101112&lt;h2&gt;危机中心&lt;/h2&gt;&lt;ul class=\"crises\"&gt; &lt;li *ngFor=\"let crisis of crisisList\"&gt; &lt;a [routerLink]=\"[crisis.id]\"&gt; &lt;span class=\"badge\"&gt;{{ crisis.id }}&lt;/span&gt;{{ crisis.name }} &lt;/a&gt; &lt;/li&gt;&lt;/ul&gt;&lt;!-- 定义子路由的渲染出口 --&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt; 在针对子路由的认证授权配置时，我们可以选择针对每个子路由添加 canActivateChild 属性，也可以定义一个空地址的子路由，将所有归属于 crisis-list 的子路由作为这个空路由的子路由，通过针对这个空路径添加 canActivateChild 属性，从而实现将守护规则应用到所有的子路由上 这里其实相当于将原先两级的路由模式（父：crisis-list，子：crisis-detail）改成了三级（父：crisis-list，子：’ ‘（空路径），孙：crisis-detail） 12345678910111213141516171819202122232425262728293031import { NgModule } from '@angular/core';import { Routes, RouterModule } from '@angular/router';// 引入组件import { CrisisListComponent } from './crisis-list/crisis-list.component';import { CrisisDetailComponent } from './crisis-detail/crisis-detail.component';// 引入路由守卫import { AuthGuard } from './auth/auth.guard';const routes: Routes = [ { path: 'crisis-center', component: CrisisListComponent, canActivate: [AuthGuard], // 添加针对当前路由的 canActivate 路由守卫 children: [{ path: '', canActivateChild: [AuthGuard], // 添加针对子路由的 canActivate 路由守卫 children: [{ path: 'detail', component: CrisisDetailComponent }] }] }];@NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule],})export class AppRoutingModule { } CanDeactivate：处理用户未提交的修改当进行表单填报之类的操作时，因为会涉及到一个提交的动作，当用户没有点击保存按钮就离开时，最好能暂停，对用户进行一个友好性的提示，由用户选择后续的操作 创建一个路由守卫，继承于 CanDeactivate 接口 1ng g guard hero-list/guards/hero-can-deactivate 与上面的 CanActivate、CanActivateChild 路由守卫的使用方式不同，对于 CanDeactivate 守卫来说，我们需要将参数中的 unknown 替换成我们实际需要进行路由守卫的组件 1234567891011121314151617import { Injectable } from '@angular/core';import { CanDeactivate, ActivatedRouteSnapshot, RouterStateSnapshot, UrlTree } from '@angular/router';import { Observable } from 'rxjs';@Injectable({ providedIn: 'root'})export class HeroCanDeactivateGuard implements CanDeactivate&lt;unknown&gt; { canDeactivate( component: unknown, currentRoute: ActivatedRouteSnapshot, currentState: RouterStateSnapshot, nextState?: RouterStateSnapshot): Observable&lt;boolean | UrlTree&gt; | Promise&lt;boolean | UrlTree&gt; | boolean | UrlTree { return true; } } 例如，这里针对的是 HeroListComponent 这个组件，因此我们需要将泛型的参数 unknown 改为 HeroListComponent，通过 component 参数，就可以获得需要进行路由守卫的组件的相关信息 123456789101112131415161718192021222324252627282930313233343536373839404142import { Injectable } from '@angular/core';import { CanDeactivate, ActivatedRouteSnapshot, RouterStateSnapshot, UrlTree,} from '@angular/router';import { Observable } from 'rxjs';// 引入需要进行路由守卫的组件import { HeroListComponent } from '../hero-list.component';@Injectable({ providedIn: 'root',})export class HeroCanDeactivateGuard implements CanDeactivate&lt;HeroListComponent&gt; { canDeactivate( component: HeroListComponent, currentRoute: ActivatedRouteSnapshot, currentState: RouterStateSnapshot, nextState?: RouterStateSnapshot ): | Observable&lt;boolean | UrlTree&gt; | Promise&lt;boolean | UrlTree&gt; | boolean | UrlTree { // 判断是否修改了原始数据 // const data = component.hero; if (data === undefined) { return true; } const origin = component.heroList.find(hero =&gt; hero.id === data.id); if (data.name === origin.name) { return true; } return window.confirm('内容未提交，确认离开？'); }} 这里模拟判断用户有没有修改原始的数据，当用户修改了数据并移动到别的页面时，触发路由守卫，提示用户是否保存后再离开当前页面 异步路由惰性加载当应用逐渐扩大，使用现有的加载方式会造成应用在第一次访问时就加载了全部的组件，从而导致系统首次渲染过慢。因此这里可以使用惰性加载的方式在请求具体的模块时才加载对应的组件 惰性加载只针对于特性模块（NgModule），因此为了使用惰性加载这个功能点，我们需要将系统按照功能划分，拆分出一个个独立的模块 首先通过 Angular CLI 创建一个危机中心模块（crisis 模块） 12345-- 查看创建模块的相关参数ng g module --help-- 创建危机中心模块（自动在 app.moudule.ts 中引入新创建的 CrisisModule、添加当前模块的路由配置）ng g module crisis --module app --routing 将 crisis-list、crisis-detail 组件全部移动到 crisis 模块下面，并在 CrisisModule 中添加对于 crisis-list、crisis-detail 组件的声明，同时将原来在 app.module.ts 中声明的组件代码移除 123456789101112131415161718192021222324import { NgModule } from '@angular/core';import { CommonModule } from '@angular/common';import { CrisisRoutingModule } from './crisis-routing.module';import { FormsModule } from '@angular/forms';// 引入模块中使用到的组件import { CrisisListComponent } from './crisis-list/crisis-list.component';import { CrisisDetailComponent } from './crisis-detail/crisis-detail.component';@NgModule({ declarations: [ CrisisListComponent, CrisisDetailComponent ], imports: [ CommonModule, FormsModule, CrisisRoutingModule ]})export class CrisisModule { } 同样的，将当前模块的路由配置移动到专门的路由配置文件 crisis-routing.module.ts 中，并将 app-routing.module.ts 中相关的路由配置删除 1234567891011121314151617181920212223242526272829import { NgModule } from '@angular/core';import { Routes, RouterModule } from '@angular/router';// 引入组件import { CrisisListComponent } from './crisis-list/crisis-list.component';import { CrisisDetailComponent } from './crisis-detail/crisis-detail.component';// 引入路由守卫import { AuthGuard } from '../auth/auth.guard';const routes: Routes = [{ path: '', component: CrisisListComponent, canActivate: [AuthGuard], // 添加针对当前路由的 canActivate 路由守卫 children: [{ path: '', canActivateChild: [AuthGuard], // 添加针对子路由的 canActivate 路由守卫 children: [{ path: 'detail', component: CrisisDetailComponent }] }]}];@NgModule({ imports: [RouterModule.forChild(routes)], exports: [RouterModule]})export class CrisisRoutingModule { } 重新运行项目，如果你在创建模块的命令中设置了自动引入当前模块到 app.module.ts 文件中，大概率会遇到下面的问题 这里的问题与配置通配路由需要放到最后的原因相似，因为脚手架在帮我们将创建的模块导入到 app.module.ts 中时，是添加到整个数组的最后，同时因为我们已经将 crisis 模块的路由配置移动到专门的 crisis-routing.module.ts 中了，框架在进行路由匹配时会预先匹配上 app-routing.module.ts 中设置的通配路由，从而导致无法找到实际应该对应的组件，因此这里我们需要将 AppRoutingModule 放到声明的最后 当问题解决后，就可以针对 crisis 模块设置惰性加载 在配置惰性路由时，我们需要以一种类似于子路由的方式进行配置，通过路由的 loadChildren 属性来加载对应的模块，而不是具体的组件，修改后的 AppRoutingModule 代码如下 12345678910111213141516import { HeroCanDeactivateGuard } from './hero-list/guards/hero-can-deactivate.guard';import { NgModule } from '@angular/core';import { Routes, RouterModule } from '@angular/router';const routes: Routes = [ { path: 'crisis-center', loadChildren: () =&gt; import('./crisis/crisis.module').then(m =&gt; m.CrisisModule) }];@NgModule({ imports: [RouterModule.forRoot(routes, { enableTracing: true })], exports: [RouterModule],})export class AppRoutingModule { } 当导航到这个 /crisis-center 路由时，框架会通过 loadChildren 字符串来动态加载 CrisisModule，然后把 CrisisModule 添加到当前的路由配置中，而惰性加载和重新配置工作只会发生一次，也就是在该路由首次被请求时执行，在后续请求时，该模块和路由都是立即可用的 CanLoad：杜绝未通过认证授权的组件加载在上面的代码中，对于 CrisisModule 模块我们已经使用 CanActivate、CanActivateChild 路由守卫来进行路由的认证授权，但是当我们并没有权限访问该路由的权限，却依然点击了链接时，此时框架路由仍会加载该模块。为了杜绝这种授权未通过仍加载模块的问题发生，这里需要使用到 CanLoad 守卫 因为这里的判断逻辑与认证授权的逻辑相同，因此在 AuthGuard 中，继承 CanLoad 接口即可，修改后的 AuthGuard 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import { Injectable } from '@angular/core';import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, UrlTree, Router, CanActivateChild, CanLoad, Route, UrlSegment} from '@angular/router';import { Observable } from 'rxjs';@Injectable({ providedIn: 'root'})export class AuthGuard implements CanActivate, CanActivateChild, CanLoad { /** * ctor * @param router 路由 */ constructor(private router: Router) { } canActivate( next: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable&lt;boolean | UrlTree&gt; | Promise&lt;boolean | UrlTree&gt; | boolean | UrlTree { // 判断是否有 token 信息 let token = localStorage.getItem('auth-token') || ''; if (token === '') { this.router.navigate(['/login']); return false; } // 判断是否可以访问当前连接 let url: string = state.url; if (token.indexOf('admin') !== -1 &amp;&amp; url.indexOf('/crisis-center') !== -1) { return true; } this.router.navigate(['/login']); return false; } canActivateChild( childRoute: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean | UrlTree | Observable&lt;boolean | UrlTree&gt; | Promise&lt;boolean | UrlTree&gt; { let token = localStorage.getItem('auth-token') || ''; if (token === '') { this.router.navigate(['/login']); return false; } return token === 'admin-master'; } canLoad(route: Route, segments: UrlSegment[]): boolean | Observable&lt;boolean&gt; | Promise&lt;boolean&gt; { let token = localStorage.getItem('auth-token') || ''; if (token === '') { this.router.navigate(['/login']); return false; } let url = `/${route.path}`; if (token.indexOf('admin') !== -1 &amp;&amp; url.indexOf('/crisis-center') !== -1) { return true; } }} 同样的，针对路由守卫的实现完成后，将需要使用到的路由守卫添加到 crisis-center 路由的 canLoad 数组中即可实现授权认证不通过时不加载模块 12345678910111213141516import { HeroCanDeactivateGuard } from './hero-list/guards/hero-can-deactivate.guard';import { NgModule } from '@angular/core';import { Routes, RouterModule } from '@angular/router';const routes: Routes = [ { path: 'crisis-center', loadChildren: () =&gt; import('./crisis/crisis.module').then(m =&gt; m.CrisisModule) }];@NgModule({ imports: [RouterModule.forRoot(routes, { enableTracing: true })], exports: [RouterModule],})export class AppRoutingModule { }","link":"/2020/06/02/getting-started-with-angular-route-guards/"},{"title":"Angular 从入坑到挖坑 - Router 路由使用入门指北","text":"OverviewAngular 入坑记录的笔记第五篇，因为一直在加班的缘故拖了有一个多月，主要是介绍在 Angular 中如何配置路由，完成重定向以及参数传递。至于路由守卫、路由懒加载等“高级”特性，并不会在本篇文章中呈现 对应官方文档地址： 路由与导航 配套代码地址：angular-practice/src/router-tutorial Contents Angular 从入坑到弃坑 - Angular 使用入门 Angular 从入坑到挖坑 - 组件食用指南 Angular 从入坑到挖坑 - 表单控件概览 Angular 从入坑到挖坑 - HTTP 请求概览 Angular 从入坑到挖坑 - Router 路由使用入门指北 Knowledge Graph Step by Step基础概念base url在 Angular 应用中，框架会自动将 index.html 文件中的 base url 配置作为组件、模板和模块文件的基础路径地址。默认的情况下 app 文件夹是整个应用的根目录，所以我们直接使用 index.html 中使用默认的 &lt;base href='/'&gt; 即可 12345678910111213&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;RouterTutorial&lt;/title&gt; &lt;base href=\"/\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\"&gt;&lt;/head&gt;&lt;body&gt; &lt;app-root&gt;&lt;/app-root&gt;&lt;/body&gt;&lt;/html&gt; 路由的配置在 Angular 项目中，系统的路由需要我们将一个 url 地址映射到一个展示的组件，因此需要手动的去设置 url 与组件之间的映射关系 因为我们在使用 Angular CLI 创建项目时，选择了添加路由模组，因此我们可以直接在 app-routing.module.ts 文件中完成路由的定义。最终我们定义的路由信息，都会在根模块中被引入到整个项目 123456789101112131415161718192021import { NgModule } from '@angular/core';import { Routes, RouterModule } from '@angular/router';import { HomeComponent } from './components/home/home.component';import { PagenotfoundComponent } from './components/pagenotfound/pagenotfound.component';import { NewsComponent } from './components/news/news.component';import { ProductComponent } from './components/product/product.component';// 配置路由信息const routes: Routes = [ { path: 'home', component: HomeComponent }, { path: '', redirectTo: 'home', pathMatch: 'full' }, { path: 'news', component: NewsComponent }, { path: 'product', component: ProductComponent }, { path: '**', component: PagenotfoundComponent },];@NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule]})export class AppRoutingModule { } 1234567891011121314151617import { BrowserModule } from '@angular/platform-browser';import { NgModule } from '@angular/core';import { AppRoutingModule } from './app-routing.module';@NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, AppRoutingModule // 引入路由配置信息 ], providers: [], bootstrap: [AppComponent]})export class AppModule { } 当定义好路由信息后，我们需要在页面上使用 &lt;router-outlet&gt; 标签来告诉 Angular 在何处渲染出页面。对于路由之间的跳转，我们可以在 a 标签上通过使用 RouterLink 指令来绑定具体的路由来完成地址的跳转 1234567891011121314151617&lt;div class=\"card-container\"&gt; &lt;a class=\"card\" [routerLink]=\"[ '/news' ]\" routerLinkActive=\"active\"&gt; &lt;span&gt;News&lt;/span&gt; &lt;/a&gt; &lt;a class=\"card\" [routerLink]=\"[ '/product' ]\" routerLinkActive=\"active\"&gt; &lt;span&gt;Product&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=\"card-container\"&gt; &lt;div class=\"form-card\"&gt; &lt;!-- 组件渲染的出口 --&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 当然，如果你非要自己给自己找事，就是要用 a 标签的 href 属性进行跳转，当然也是可以的，不过在后面涉及到相关框架的功能时就会显得有点不辣么聪明的样子了 重定向与通配地址在普遍情况下，对于进入系统后的默认路径，我们会选择重定向到一个具体的地址上，这里我们在定义路由信息时，定义了一个空路径用来表示系统的默认地址，当用户请求时，重定向到 /home 路径上，因为只有完整的 url 地址匹配空字符串时才应该进行重定向操作，所以这里需要指定匹配模式是全部匹配 1234const routes: Routes = [ { path: 'home', component: HomeComponent }, { path: '', redirectTo: 'home', pathMatch: 'full' }]; Angular 在解析路由时，是按照我们定义路由时的顺序依次进行的，一旦匹配就会立即终止。因此，类似于 404 错误的这种通配的路由配置，因为可以匹配上每个 url 地址，所以应该在定义时放到最后 1234567const routes: Routes = [ { path: 'home', component: HomeComponent }, { path: '', redirectTo: 'home', pathMatch: 'full' }, { path: 'news', component: NewsComponent }, { path: 'product', component: ProductComponent }, { path: '**', component: PagenotfoundComponent },]; 从截图中可以看到，当我们打开系统时，会自动跳转到我们指定的 home 路径，点击菜单按钮后，则会加载对应的组件页面 激活的路由很多情况下，对于被选中的路由，我们可能会添加一个特定的样式来进行提示用户，因此，在我们定义 router-link 时，可以使用 routerLinkActive 属性绑定一个 css 的样式类，当该链接对应的路由处于激活状态时，则自动添加上指定的样式类 路由间的参数传递在进行路由跳转时，很常见的一种使用情况是我们需要将某些数据作为参数传递到下一个页面中，例如从列表中选择点击某一行数据，跳转到对应的详情页面 常见的参数传递有如下的两种方式 query 查询参数传递最常见的一种参数传递的方式，在需要跳转的路由地址后面加上参数和对应的值，在跳转后的页面通过获取参数 key 从而获取到对应的参数值 1&lt;a href=\"www.yoursite.com/product?productId=xxxx\"&gt;跳转&lt;/a&gt; 对于直接通过 a 标签进行的路由跳转，我们可以在 a 标签上通过绑定 queryParams 属性来添加查询参数信息 这里通过 queryParams 属性绑定的是一个对象，Angular 会自动的帮我们将这个参数对象与 url 进行拼接。对于参数对象中的属性（key）对应的属性值（value），我们可以绑定一个组件中的属性进行动态的赋值，也可以通过添加单引号将参数值作为一个固定的数值，例如在下面代码中的两个查询参数就是固定的值 1&lt;a class=\"card\" [routerLink]=\"[ '/news' ]\" routerLinkActive=\"active\" [queryParams]=\"{category:'social',date:'2020-05-02'}\"&gt;News&lt;/a&gt; 同样的，我们也可以在 js 中完成路由的跳转，对于这种使用场景，我们需要在进行 js 跳转的组件类中通过构造函数依赖注入 Router 类，之后通过 Router 类的 navigate 方法完成路由的跳转；对于可能存在的查询参数，我们需要定义一个 NavigationExtras 类型的变量来进行设置 12345678910111213141516171819202122232425262728293031import { Component, OnInit } from '@angular/core';// 引入路由模块import { Router, NavigationExtras } from '@angular/router';@Component({ selector: 'app-home', templateUrl: './home.component.html', styleUrls: ['./home.component.scss']})export class HomeComponent implements OnInit { constructor(private router: Router) {} ngOnInit(): void {} /** * 使用 js 的方式通过 query 查询字符串的形式传递参数 */ queryNavigate() { // 查询参数 let query: NavigationExtras = { queryParams: { category: 'social', date: '2020-05-04' } }; this.router.navigate(['/news' ], query); }} 既然在进行跳转时附加了参数信息，在跳转后的页面我们肯定需要获取到传递的参数值。在 Angular 中，需要在组件类中依赖注入 ActivatedRoute 来获取传递的参数信息 这里的 queryParamMap 是一个 Observable 对象，所以这里需要使用 subscribe 方法来获取传递的参数值 12345678910111213141516171819202122import { Component, OnInit } from '@angular/core';// 引入路由模块import { ActivatedRoute } from '@angular/router';@Component({ selector: 'app-news', templateUrl: './news.component.html', styleUrls: ['./news.component.scss']})export class NewsComponent implements OnInit { constructor(private route: ActivatedRoute) { } ngOnInit(): void { this.route.queryParamMap.subscribe((data: any) =&gt; { console.log(data.params); }); }} 动态路由传递与使用查询参数不同，使用动态路由进行参数传值时，需要我们在定义路由时就提供参数的占位符信息，例如在下面定义路由的代码里，对于组件所需的参数 newsId，我们需要在定义路由时就指明 123const routes: Routes = [ { path: 'news/detail/:newsId', component: NewsDetailComponent },]; 对于采用动态路由进行的路由跳转，在 a 标签绑定的 routerLink 属性数组的第二个数据中，需要指定我们传递的参数值。例如这里的 item.newsId 变量就是我们需要传递的参数值 1234567&lt;ul&gt; &lt;li *ngFor=\"let item of newsList; let i = index\"&gt; &lt;a [routerLink]=\"['/news/detail', item.newsId]\" routerLinkActive=\"active\" &gt; {{item.title}} &lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 而采用 js 的方式进行跳转时，我们同样需要使用依赖注入的方式注入 Router 类，然后调用 navigate 方法进行跳转。与使用 query 查询参数传递数据不同，此时需要将跳转的链接与对应的参数值组合成为一个数组参数进行传递 1234567891011121314151617181920212223242526272829303132333435363738import { Component, OnInit } from '@angular/core';// 引入路由模块import { Router, ActivatedRoute } from '@angular/router';@Component({ selector: 'app-news', templateUrl: './news.component.html', styleUrls: ['./news.component.scss']})export class NewsComponent implements OnInit { newsList: any; constructor(private route: ActivatedRoute, private router: Router) { this.newsList = [{ newsId: 1111, title: 'lalalalalallaaa' }, { newsId: 2222, title: 'lalalalalallaaa' }, { newsId: 3333, title: 'lalalalalallaaa' }]; } ngOnInit(): void { this.route.queryParamMap.subscribe((data: any) =&gt; { console.log(data.params); }); } routerNavigate() { this.router.navigate(['/news/detail', 11111]); }} 在获取参数数据的组件类中，需要依赖注入 ActivatedRoute 类，因为是采用的动态路由的方式进行的参数传递，这里需要通过 paramMap 属性获取到对应的参数值 1234567891011121314151617181920import { Component, OnInit } from '@angular/core';// 引入路由模块import { ActivatedRoute } from '@angular/router';@Component({ selector: 'app-news-detail', templateUrl: './news-detail.component.html', styleUrls: ['./news-detail.component.scss']})export class NewsDetailComponent implements OnInit { constructor(private route: ActivatedRoute) { } ngOnInit(): void { this.route.paramMap.subscribe((data: any) =&gt; { console.log(data.params); }); }} 嵌套路由在一些情况下，路由是存在嵌套关系的，例如下面这个页面，只有当我们点击资源这个顶部的菜单后，它才会显示出左侧的这些菜单，也就是说这个页面左侧的菜单的父级菜单是顶部的资源菜单 针对这种具有嵌套关系的路由，在定义路由时，我们需要通过配置 children 属性来指定路由之间的嵌套关系，例如这里我定义 ProductDetailComponent 这个组件和 ProductComponent 组件形成的路由之间具有嵌套关系 12345678910// 配置路由信息const routes: Routes = [ { path: 'product', component: ProductComponent, children: [{ path: 'detail', component: ProductDetailComponent }, { path: '', redirectTo: 'detail', pathMatch: 'full' }] }]; 因为子路由的渲染出口是在父路由的页面上，因此当嵌套路由配置完成之后，在嵌套的父级页面上，我们需要定义一个 &lt;router-outlet&gt; 标签用来指定子路由的渲染出口，最终的效果如下图所示 123456&lt;h3&gt;我是父路由页面显示的内容&lt;/h3&gt;&lt;p&gt;product works!&lt;/p&gt;&lt;!-- 加载子路由的数据 --&gt;&lt;h3&gt;子路由组件渲染的出口&lt;/h3&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt;","link":"/2020/05/10/getting-started-with-angular-routing/"},{"title":"如何获取 C# 类中发生数据变化的属性信息","text":"前言在平时的开发中，当用户修改数据时，一直没有很好的办法来记录具体修改了那些信息，只能暂时采用将类序列化成 json 字符串，然后全塞入到日志中的方式，此时如果我们想要知道用户具体改变了哪几个字段的值的话就很困难了。因此，趁着这个假期，就来解决这个一直遗留的小问题，本篇文章记录了我目前实现的方法，如果你有不同于文中所列出的方案的话，欢迎指出。 代码仓储地址：https://github.com/Lanesra712/ingos-common/tree/master/sample/csharp/get-data-changed-properties Step by Step需求场景一个经常遇到的使用场景，用户 A 修改了某个表单页面上的数据信息，然后提交到我们的服务端完成数据的更新，对于具有某些权限的用户来说，则是期望可以看到所有用户对于该表单进行操作前后的数据变更。 解决方法既然想要得知用户操作前后的数据差异，我们肯定需要去对用户操作前后的数据进行比对，这里就落到我们承接数据的类身上。 在我们定义类中的属性时，更多的是使用自动属性的方式来完成属性的 getter、setter 声明，而完整的属性声明方式则需要我们定义一个字段用来承接对于该属性的变更。 1234567891011121314151617// 自动属性声明public class Entity1{ public Guid Id { get; set; }}// 完整的属性声明public class Entity2{ private Guid _id; public Guid Id { get =&gt; _id; set =&gt; _id = value; }} 因为在给属性进行赋值的时候，需要调用属性的 set 构造器，因此，在 set 构造器内部我们是不是就可以直接对新赋的值进行判断，从而记录下属性的变更过程，改造后的类属性声明代码如下。 1234567891011121314151617181920212223242526272829303132333435363738public class Sample{ private string _a; public string A { get =&gt; _a; set { if (_a == value) return; string old = _a; _a = value; propertyChangelogs.Add(new PropertyChangelog&lt;Sample&gt;(nameof(A), old, _a)); } } private double _b; public double B { get =&gt; _b; set { if (_b == value) return; double old = _b; _b = value; propertyChangelogs.Add(new PropertyChangelog&lt;Sample&gt;(nameof(B), old.ToString(), _b.ToString())); } } private IList&lt;PropertyChangelog&lt;Sample&gt;&gt; propertyChangelogs = new List&lt;PropertyChangelog&lt;Sample&gt;&gt;(); public IEnumerable&lt;PropertyChangelog&lt;Sample&gt;&gt; Changelogs() =&gt; propertyChangelogs;} 在改造后的类属性声明中，我们在属性的 set 构造器中将新赋的值与原先的值进行判断，当存在两次值不一样时，就写入到变更记录的集合中，从而实现记录数据变更的目的。这里对于变更记录的实体类属性定义如下所示。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class PropertyChangelog&lt;T&gt;{ /// &lt;summary&gt; /// ctor /// &lt;/summary&gt; public PropertyChangelog() { } /// &lt;summary&gt; /// ctor /// &lt;/summary&gt; /// &lt;param name=\"propertyName\"&gt;属性名称&lt;/param&gt; /// &lt;param name=\"oldValue\"&gt;旧值&lt;/param&gt; /// &lt;param name=\"newValue\"&gt;新值&lt;/param&gt; public PropertyChangelog(string propertyName, string oldValue, string newValue) { PropertyName = propertyName; OldValue = oldValue; NewValue = newValue; } /// &lt;summary&gt; /// ctor /// &lt;/summary&gt; /// &lt;param name=\"className\"&gt;类名&lt;/param&gt; /// &lt;param name=\"propertyName\"&gt;属性名称&lt;/param&gt; /// &lt;param name=\"oldValue\"&gt;旧值&lt;/param&gt; /// &lt;param name=\"newValue\"&gt;新值&lt;/param&gt; /// &lt;param name=\"changedTime\"&gt;修改时间&lt;/param&gt; public PropertyChangelog(string className, string propertyName, string oldValue, string newValue, DateTime changedTime) : this(propertyName, oldValue, newValue) { ClassName = className; ChangedTime = changedTime; } /// &lt;summary&gt; /// 类名称 /// &lt;/summary&gt; public string ClassName { get; set; } = typeof(T).FullName; /// &lt;summary&gt; /// 属性名称 /// &lt;/summary&gt; public string PropertyName { get; set; } /// &lt;summary&gt; /// 旧值 /// &lt;/summary&gt; public string OldValue { get; set; } /// &lt;summary&gt; /// 新值 /// &lt;/summary&gt; public string NewValue { get; set; } /// &lt;summary&gt; /// 修改时间 /// &lt;/summary&gt; public DateTime ChangedTime { get; set; } = DateTime.Now;} 可以看到，在我们对 Sample 类进行初始化赋值时，记录了两次关于类属性的数据变更记录，而当我们进行重新赋值时，只有属性 A 发生了数据改变，因此只记录了属性 A 的数据变更记录。 虽然这里已经达到我们的目的，但是如果采用这种方式的话，相当于原先项目中需要实现数据记录功能的类的属性声明方式全部需要重写，同时，基于 C# 本身已经提供了自动属性的方式来简化属性声明，结果现在我们又回到了传统属性的声明方式，似乎显得有些不太聪明的样子。因此，既然通过一个个属性进行比较的方式过于繁琐，这里我们通过反射的方式直接对比修改前后的两个实体类，批量获取发生数据变更的属性信息。 我们最终想要实现的是用户可以看到关于某个表单的字段属性数据变化的过程，而我们定义在 C# 类中的属性有时候需要与实际页面上显示的字段名称进行映射，以及某些属性其实没有必要记录数据变化的情况，这里我通过添加自定义特性的方式，完善功能的实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/// &lt;summary&gt;/// 为指定的属性设定数据变更记录/// &lt;/summary&gt;[AttributeUsage(AttributeTargets.Class | AttributeTargets.Property)]public class PropertyChangeTrackingAttribute : Attribute{ /// &lt;summary&gt; /// 指定 PropertyChangeTrackingAttribute 属性的默认值 /// &lt;/summary&gt; public static readonly PropertyChangeTrackingAttribute Default = new PropertyChangeTrackingAttribute(); /// &lt;summary&gt; /// 构造一个新的 PropertyChangeTrackingAttribute 特性实例 /// &lt;/summary&gt; public PropertyChangeTrackingAttribute() { } /// &lt;summary&gt; /// 构造一个新的 PropertyChangeTrackingAttribute 特性实例 /// &lt;/summary&gt; /// &lt;param name=\"ignore\"&gt;是否忽略该字段的数据变化&lt;/param&gt; public PropertyChangeTrackingAttribute(bool ignore = false) { IgnoreValue = ignore; } /// &lt;summary&gt; /// 构造一个新的 PropertyChangeTrackingAttribute 特性实例 /// &lt;/summary&gt; /// &lt;param name=\"displayName\"&gt;属性对应页面显示名称&lt;/param&gt; public PropertyChangeTrackingAttribute(string displayName) : this(false) { DisplayNameValue = displayName; } /// &lt;summary&gt; /// 构造一个新的 PropertyChangeTrackingAttribute 特性实例 /// &lt;/summary&gt; /// &lt;param name=\"displayName\"&gt;属性对应页面显示名称&lt;/param&gt; /// &lt;param name=\"ignore\"&gt;是否忽略该字段的数据变化&lt;/param&gt; public PropertyChangeTrackingAttribute(string displayName, bool ignore) : this(ignore) { DisplayNameValue = displayName; } /// &lt;summary&gt; /// 获取特性中的属性对应页面上显示名称参数信息 /// &lt;/summary&gt; public virtual string DisplayName =&gt; DisplayNameValue; /// &lt;summary&gt; /// 获取特性中的是否忽略该字段的数据变化参数信息 /// &lt;/summary&gt; public virtual bool Ignore =&gt; IgnoreValue; /// &lt;summary&gt; /// 修改属性对应页面显示名称参数值 /// &lt;/summary&gt; protected string DisplayNameValue { get; set; } /// &lt;summary&gt; /// 修改是否忽略该字段的数据变化 /// &lt;/summary&gt; protected bool IgnoreValue { get; set; }} 考虑到我们的类中可能会包含很多的属性信息，如果一个个的给属性添加特性会很麻烦，因此这里可以直接针对类添加该特性。同时，针对我们可能会排除类中的某些属性，或者设定属性在页面中显示的名称，这里我们可以针对特定的类属性进行单独添加特性。 完成了自定义特性之后，考虑到我们后续使用的方便，这里我采用创建扩展方法的形式来声明我们的函数方法，同时我在 PropertyChangelog 类中添加了 DisplayName 属性用来存放属性对应于页面上存放的名称，最终完成后的代码如下所示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/// &lt;summary&gt;/// 获取类属性数据变化记录/// &lt;/summary&gt;/// &lt;typeparam name=\"T\"&gt;监听的类类型&lt;/typeparam&gt;/// &lt;param name=\"oldObj\"&gt;包含原始值的类&lt;/param&gt;/// &lt;param name=\"newObj\"&gt;变更属性值后的类&lt;/param&gt;/// &lt;param name=\"propertyName\"&gt;指定的属性名称&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static IEnumerable&lt;PropertyChangelog&lt;T&gt;&gt; GetPropertyLogs&lt;T&gt;(this T oldObj, T newObj, string propertyName = null){ IList&lt;PropertyChangelog&lt;T&gt;&gt; changelogs = new List&lt;PropertyChangelog&lt;T&gt;&gt;(); // 1、获取需要添加数据变更记录的属性信息 // IList&lt;PropertyInfo&gt; properties = new List&lt;PropertyInfo&gt;(); // PropertyChangeTracking 特性的类型 var attributeType = typeof(PropertyChangeTrackingAttribute); // 对应的类中包含的属性信息 var classProperties = typeof(T).GetProperties(); // 获取类中需要添加变更记录的属性信息 // bool flag = Attribute.IsDefined(typeof(T), attributeType); foreach (var i in classProperties) { // 获取当前属性添加的特性信息 var attributeInfo = (PropertyChangeTrackingAttribute)i.GetCustomAttribute(attributeType); // 类未添加特性，并且该属性也未添加特性 if (!flag &amp;&amp; attributeInfo == null) continue; // 类添加特性，该属性未添加特性 if (flag &amp;&amp; attributeInfo == null) properties.Add(i); // 不管类有没有添加特性，只要类中的属性添加特性，并且 Ignore 为 false if (attributeInfo != null &amp;&amp; !attributeInfo.Ignore) properties.Add(i); } // 2、判断指定的属性数据是否发生变更 // foreach (var property in properties) { var oldValue = property.GetValue(oldObj) ?? \"\"; var newValue = property.GetValue(newObj) ?? \"\"; if (oldValue.Equals(newValue)) continue; // 获取当前属性在页面上显示的名称 // var attributeInfo = (PropertyChangeTrackingAttribute)property.GetCustomAttribute(attributeType); string displayName = attributeInfo == null ? property.Name : attributeInfo.DisplayName; changelogs.Add(new PropertyChangelog&lt;T&gt;(property.Name, displayName, oldValue.ToString(), newValue.ToString())); } return string.IsNullOrEmpty(propertyName) ? changelogs : changelogs.Where(i =&gt; i.PropertyName.Equals(propertyName));} 在下面的这个测试案例中，Entity 类实际上只会记录 5 个属性的数据变化，我们手动创建两个 Entity 类实例，同时改变两个类实例对应的属性值。从我们运行的示意图中可以看到，虽然两个类实例的 Id 属性值不同，但是因为被我们手动忽略了，所以最终只显示我们设定的几个属性的变化信息。 123456789101112131415161718[PropertyChangeTracking]public class Entity{ [PropertyChangeTracking(ignore: true)] public Guid Id { get; set; } [PropertyChangeTracking(displayName: \"序号\")] public string OId { get; set; } [PropertyChangeTracking(displayName: \"第一个字段\")] public string A { get; set; } public double B { get; set; } public bool C { get; set; } public DateTime Date { get; set; } = DateTime.Now;} 总结这一章是针对我之前在工作中遇到的一个问题，趁着假期考虑的一个解决方法，虽然只是一个小问题，但是还是挺有借鉴意义的，如果能够给你在日常的开发中提供些许的帮助，不胜荣幸。","link":"/2020/02/07/how-to-get-the-data-changed-properties-in-csharp-class/"},{"title":"如何在 asp.net core 3.x 的 startup.cs 文件中获取注入的服务","text":"前言从 18 年开始接触 .NET Core 开始，在私底下、工作中也开始慢慢从传统的 mvc 前后端一把梭，开始转向 web api + vue，之前自己有个半成品的 asp.net core 2.2 的项目模板，最近几个月的时间，私下除了学习 Angular 也在对这个模板基于 asp.net core 3.1 进行慢慢补齐功能 因为涉及到底层框架大版本升级，由于某些 breaking changes 必定会造成之前的某些写法没办法继续使用，趁着端午节假期，在改造模板时，发现没办法通过构造函数注入的形式在 Startup 文件中注入某些我需要的服务了，因此本篇文章主要介绍如何在 asp.net core 3.x 的 startup 文件中获取注入的服务 Step by Step问题案例这个问题的发现源于我需要改造模型验证失败时返回的错误信息，如果你有尝试的话，在 3.x 版本中你会发现在 Startup 类中，我们没办法通过构造函数注入的方式再注入任何其它的服务了，这里仅以我的代码中需要解决的这个问题作为案例 在定义接口时，为了降低后期调整的复杂度，在接收参数时，一般会将参数包装成一个 dto 对象（data transfer object - 数据传输对象），不管是提交数据，还是查询数据，对于这个 dto 中的某些属性，都会存在一定的卡控，例如 xxx 字段不能为空了，xxx 字段的长度不能超过 30 而在 asp.net core 中，因为会自动进行模型验证，当不符合 dto 中的属性要求时，接口会自动返回错误信息，默认的返回信息如下图所示 可以看到，因为这里其实是按照 rfc7231这个 RFC 协议返回的错误信息，这个并不符合我的要求，因此这里我需要改写这个返回的错误信息 自定义 asp.net core 的模型验证错误信息方法有很多种，我的实现方法如下，因为我需要记录请求的标识 Id 和错误日志，所以这里我需要将 ILogger 和 IHttpContextAccessor 注入到 Startup 类中 1234567891011121314151617181920212223242526272829303132333435363738/// &lt;summary&gt;/// 修改模型验证错误返回信息/// &lt;/summary&gt;/// &lt;param name=\"services\"&gt;服务容器集合&lt;/param&gt;/// &lt;param name=\"logger\"&gt;日志记录实例&lt;/param&gt;/// &lt;param name=\"httpContextAccessor\"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static IServiceCollection AddCustomInvalidModelState(this IServiceCollection services, ILogger&lt;Startup&gt; logger, IHttpContextAccessor httpContextAccessor){ services.Configure&lt;ApiBehaviorOptions&gt;(options =&gt; { options.InvalidModelStateResponseFactory = actionContext =&gt; { // 获取验证不通过的字段信息 // var errors = actionContext.ModelState.Where(e =&gt; e.Value.Errors.Count &gt; 0) .Select(e =&gt; new ApiErrorDto { Title = \"请求参数不符合字段格式要求\", Message = e.Value.Errors.FirstOrDefault()?.ErrorMessage }).ToList(); var result = new ApiReturnDto&lt;object&gt; { TraceId = httpContextAccessor.HttpContext.TraceIdentifier, Status = false, Error = errors }; logger.LogError($\"接口请求参数格式错误: {JsonConvert.SerializeObject(result)}\"); return new BadRequestObjectResult(result); }; }); return services;} 在 asp.net core 2.x 版本中，你完全可以像在别的类中采用构造函数注入的方式一样直接注入使用 1234567891011121314151617181920212223242526272829303132333435363738394041public class Startup{ /// &lt;summary&gt; /// 日志记录实例 /// &lt;/summary&gt; private readonly ILogger&lt;Startup&gt; _logger; /// &lt;summary&gt; /// Http 请求实例 /// &lt;/summary&gt; private readonly IHttpContextAccessor _httpContextAccessor; /// &lt;summary&gt; /// ctor /// &lt;/summary&gt; /// &lt;param name=\"configuration\"&gt;&lt;/param&gt; /// &lt;param name=\"logger\"&gt;&lt;/param&gt; /// &lt;param name=\"httpContextAccessor\"&gt;&lt;/param&gt; public Startup(IConfiguration configuration, ILogger&lt;Startup&gt; logger, IHttpContextAccessor httpContextAccessor) { Configuration = configuration ?? throw new ArgumentNullException(nameof(configuration)); _logger = logger ?? throw new ArgumentNullException(nameof(logger)); _httpContextAccessor = httpContextAccessor ?? throw new ArgumentNullException(nameof(httpContextAccessor)); } /// &lt;summary&gt; /// 配置实例 /// &lt;/summary&gt; public IConfiguration Configuration { get; } /// &lt;summary&gt; /// This method gets called by the runtime. Use this method to add services to the container. /// &lt;/summary&gt; public void ConfigureServices(IServiceCollection services) { //注入的其它服务 // 返回自定义的模型验证错误信息 services.AddCustomInvalidModelState(_logger, _httpContextAccessor); }} 但是当你直接迁移到 asp.net core 3.x 版本后，你会发现程序会报如下的错误，很常见的一个依赖注入的错误，源头直指我们通过构造函数注入的 ILogger、IHttpContextAccessor 接口 解决方法根本原因通过查阅 stackoverflow 发现了这样的一个问题：How do I write logs from within Startup.cs，在最高赞的回答中提到了在泛型主机（GenericHostBuilder）中，没办法注入除 IConfiguration 之外的任何服务到 Startup类中，而泛型主机则是在 asp.net core 3.0 中添加的功能 查了下升级日志，从中可以看到，在泛型主机中， Startup 类的构造函数注入只支持 IHostEnvironment、 IWebHostEnvironment、IConfiguration ，嗯，不好好看别人文档的锅 为什么使用 WebHostBuilder可以，换成 GenericHostBuilder 就不行了呢 按照正常的逻辑来说，对于一个 asp.net core 应用，原则上来说只有有一个根级（root）的依赖注入容器，但是因为我们在 Startup 类中通过构造函数注入的形式注入服务时，告诉程序了我需要这个服务的实例，从而导致在构建 WebHost 时存在了一个单独的容器，并且这个容器只包含了我们需要使用到的服务信息，之后，因为会创建了一个包含完整服务的依赖注入容器，这里就会存在一个服务哪怕是单例的也可能会存在注册两次的问题，这无疑有些不太合乎规范 在推行泛型主机之后，严格控制了只会存在一个依赖注入容器，而所有的服务都是在 Startup.ConfigureServices 方法执行完成后才会注册到依赖注入容器中，因此没办法像之前一样在根容器注册完成之前通过构造函数注入的形式使用 解决方案如果你需要在 Startup.Configure 方法中使用自定义的服务，因为这里已经完成了各种服务的注册，和之前一样，我们直接在方法签名中包含需要使用到的服务即可 1234public void Configure(IApplicationBuilder app, IHostEnvironment env, ILogger&lt;Startup&gt; logger){ logger.LogInformation(\"在 Configure 中使用自定义的服务\");} 如果你需要在 Startup.ConfigureServices 中使用的话，则需要换一种方法 最简单的方法，直接替换泛型主机为原来的 WebHostBuilder，这样就可以直接在 Startup 类中注入各种服务接口了，不过，考虑到这一改动其实是在开倒车，所以这里不推荐采用这种方法 既然没办法正向通过依赖注入容器来自动创建我们需要的服务实例，是不是可以通过服务容器，手动去获取我们需要的服务，也就是被称为服务定位（Service Locator）的方式来获取实例 当然，这似乎与依赖注入的思想相左，对于依赖注入来说，我们将所有需要使用的服务定义好，在应用启动前完成注册，之后在使用时由依赖注入容器提供服务的实例即可，而服务定位则是我们已经知道存在这个服务了，从容器中获取出来然后由自己手动的创建实例 虽然服务定位是一种反模式，但是在某些情况下，我们又不得不采用 这里对于本篇文章开篇中需要解决的问题，我也是采用服务定位的方式，通过构建一个 ServiceProvider 之后，手动的从容器中获取需要使用的服务实例，调整后的代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243/// &lt;summary&gt;/// 添加自定义模型验证失败时返回的错误信息/// &lt;/summary&gt;/// &lt;param name=\"services\"&gt;服务容器集合&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static IServiceCollection AddCustomInvalidModelState(this IServiceCollection services){ // 构建一个服务的提供程序 var provider = services.BuildServiceProvider(); // 获取需要使用的服务实例 // var logger = provider.GetRequiredService&lt;ILogger&lt;Startup&gt;&gt;(); var httpContextAccessor = provider.GetRequiredService&lt;IHttpContextAccessor&gt;(); services.Configure&lt;ApiBehaviorOptions&gt;(options =&gt; { options.InvalidModelStateResponseFactory = actionContext =&gt; { // 获取失败信息 // var errors = actionContext.ModelState.Where(e =&gt; e.Value.Errors.Count &gt; 0) .Select(e =&gt; new ApiErrorMessageDto { Title = \"Request parameters do not meet the field requirements\", Message = e.Value.Errors.FirstOrDefault()?.ErrorMessage }).ToList(); var result = new ApiResponseDto&lt;object&gt; { TraceId = httpContextAccessor.HttpContext.TraceIdentifier, Status = false, Error = errors }; logger.LogError($\"接口请求参数格式错误: {JsonSerializer.Serialize(result)}\"); return new BadRequestObjectResult(result); }; }); return services;} 对于配置一些需要基于某些服务的服务，这里也可以通过委托的形式获取到需要使用的服务实例，示例代码如下 1234567891011public void ConfigureServices(IServiceCollection services){ services.AddSingleton&lt;IMyService&gt;((container) =&gt; { var logger = container.GetRequiredService&lt;ILogger&lt;MyService&gt;&gt;(); return new MyService { Logger = logger }; });} 参考资料 ASP.NET Core 3.0 的新增功能 Generic Host restricts Startup constructor injection 依赖注入模式 Avoiding Startup service injection in ASP.NET Core 3","link":"/2020/06/27/how-to-get-the-injected-services-in-startup-of-asp-net-core-3-x/"},{"title":"如何在 asp.net core 的中间件中返回具体的页面","text":"前言在 asp.net core 中，存在着中间件这一概念，在中间件中，我们可以比过滤器更早的介入到 http 请求管道，从而实现对每一次的 http 请求、响应做切面处理，从而实现一些特殊的功能 在使用中间件时，我们经常实现的是鉴权、请求日志记录、全局异常处理等等这种非业务性的需求，而如果你有在 asp.net core 中使用过 swashbuckle(swagger)、health check、mini profiler 等等这样的组件的话，你会发现，这些第三方的组件往往都提供了页面，允许我们通过可视化的方式完成某些操作或浏览某些数据 因为自己也需要实现类似的功能，虽然使用到的知识点很少、也很简单，但是在网上搜了搜也没有专门介绍这块的文档或文章，所以本篇文章就来说明如何在中间件中返回页面，如果你有类似的需求，希望可以对你有所帮助 Step by Step最终实现的功能其实很简单，当用户跳转到某个指定的地址后，自定义的中间件通过匹配到该路径，从而返回指定的页面，所以这里主要会涉及到中间件是如何创建，以及如何处理页面中的静态文件引用 因为这块并不会包含很多的代码，所以这里主要是通过分析 Swashbuckle.AspNetCore 的代码，了解它是如何实现的这一功能，从而给我们的功能实现提供一个思路 在 asp.net core 中使用 Swashbuckle.AspNetCore 时，我们通常需要在 Startup 类中针对组件做如下的配置，根据当前程序的信息生成 json 文件 =》 公开生成的 json 文件地址 =》 根据 json 文件生成可视化的交互页面 123456789101112131415161718192021222324252627282930313233343536373839public class Startup{ // This method gets called by the runtime. Use this method to add services to the container. public void ConfigureServices(IServiceCollection services) { // 生成 swagger 配置的 json 文件 services.AddSwaggerGen(s =&gt; { s.SwaggerDoc(\"v1\", new OpenApiInfo { Contact = new OpenApiContact { Name = \"Danvic Wang\", Url = new Uri(\"https://yuiter.com\"), }, Description = \"Template.API - ASP.NET Core 后端接口模板\", Title = \"Template.API\", Version = \"v1\" }); // 参数使用驼峰的命名方式 s.DescribeAllParametersInCamelCase(); }); } // This method gets called by the runtime. Use this method to configure the HTTP request pipeline. public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { // 公开 swagger 生成的 json 文件节点 app.UseSwagger(); // 启用 swagger 可视化交互页面 app.UseSwaggerUI(s =&gt; { s.SwaggerEndpoint($\"/swagger/v1/swagger.json\", $\"Swagger doc v1\"); }); }} 可以看到最终呈现给用户的页面，其实是在 Configure 方法中通过调用 UseSwaggerUI 方法来完成的，这个方法是在 Swashbuckle.AspNetCore.SwaggerUI 这个程序集中，所以这里直接从 github 上找到对应的文件夹，clone 下源代码，来看下是如何实现在中间件中返回特定的页面 在 clone 下的代码中，排除掉一些 c#、node.js 使用到的项目性文件，可以看到整个项目中的文件按照功能可以分为三大块，其中最核心的则是在 SwaggerUIMiddleware 类中，因此，这里主要聚焦在这个中间件类的实现 在一个 asp.net core 中间件中，核心的处理逻辑是在 Invoke/InvokeAsync 方法中，结合我们使用 swagger 时的场景，可以看到，在将组件中所包含的页面呈现给用户时，主要存在如下两个处理逻辑 1、当匹配到用户访问的是 /swagger 时，返回 301 的 http 状态码，浏览器重定向到 /swagger/index.html，从而再次触发该中间件的执行 2、当匹配到请求的地址为 /swagger/index.html 时，将嵌入到程序集中的文件通过 stream 流的形式获取到，转换成字符串，再指定请求的响应的类型为 text/html,从而实现将页面返回给用户 12345678910111213141516171819202122232425public async Task Invoke(HttpContext httpContext){ var httpMethod = httpContext.Request.Method; var path = httpContext.Request.Path.Value; // If the RoutePrefix is requested (with or without trailing slash), redirect to index URL if (httpMethod == \"GET\" &amp;&amp; Regex.IsMatch(path, $\"^/?{Regex.Escape(_options.RoutePrefix)}/?$\")) { // Use relative redirect to support proxy environments var relativeRedirectPath = path.EndsWith(\"/\") ? \"index.html\" : $\"{path.Split('/').Last()}/index.html\"; RespondWithRedirect(httpContext.Response, relativeRedirectPath); return; } if (httpMethod == \"GET\" &amp;&amp; Regex.IsMatch(path, $\"^/{Regex.Escape(_options.RoutePrefix)}/?index.html$\")) { await RespondWithIndexHtml(httpContext.Response); return; } await _staticFileMiddleware.Invoke(httpContext);} 这里需要注意，因为类似于这种功能，我们可能会打包成独立的 nuget 包，然后通过 nuget 进行引用，所以为了能够正确获取到页面及其使用到的静态资源文件，我们需要将这些静态文件的属性修改成嵌入的资源，从而在打包时可以包含在程序集中 对于网页来说，在引用这些静态资源文件时存在一种相对的路径关系，因此，这里在中间件的构造函数中，我们需要将页面需要使用到的静态文件，通过构建 StaticFileMiddleware 中间件，将文件映射与网页相同的 /swagger 路径下面，从而确保页面所需的资源可以正确加载 123456789101112131415161718192021222324252627282930313233public class SwaggerUIMiddleware{ private const string EmbeddedFileNamespace = \"Swashbuckle.AspNetCore.SwaggerUI.node_modules.swagger_ui_dist\"; private readonly SwaggerUIOptions _options; private readonly StaticFileMiddleware _staticFileMiddleware; public SwaggerUIMiddleware( RequestDelegate next, IHostingEnvironment hostingEnv, ILoggerFactory loggerFactory, SwaggerUIOptions options) { _options = options ?? new SwaggerUIOptions(); _staticFileMiddleware = CreateStaticFileMiddleware(next, hostingEnv, loggerFactory, options); } private StaticFileMiddleware CreateStaticFileMiddleware( RequestDelegate next, IHostingEnvironment hostingEnv, ILoggerFactory loggerFactory, SwaggerUIOptions options) { var staticFileOptions = new StaticFileOptions { RequestPath = string.IsNullOrEmpty(options.RoutePrefix) ? string.Empty : $\"/{options.RoutePrefix}\", FileProvider = new EmbeddedFileProvider(typeof(SwaggerUIMiddleware).GetTypeInfo().Assembly, EmbeddedFileNamespace), }; return new StaticFileMiddleware(next, hostingEnv, Options.Create(staticFileOptions), loggerFactory); }} 当完成了页面的呈现后，因为一般我们会创建一个单独的类库来实现这些功能，在页面中，可能会包含前后端的数据交互，由于我们在宿主的 API 项目中已经完成了对于路由规则的设定，所以这里只需要在类库中通过 nuget 引用 Microsoft.AspNetCore.Mvc.Core ，然后与 Web API 一样的定义 controller，确保这个中间件在宿主程序的调用位于路由匹配规则之后即可 12345678910111213141516171819202122public void Configure(IApplicationBuilder app, IWebHostEnvironment env){ if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); // Endpoint 路由规则设定 app.UseEndpoints(endpoints =&gt; { endpoints.MapControllers(); }); // 自定义中间件 app.UseMiddleware&lt;SampleUIMiddleware&gt;();} 参考 ASP.NET Core 应用针对静态文件请求的处理: 以 web 的形式发布静态文件","link":"/2020/08/16/how-to-return-a-page-in-asp.net-core-middleware/"},{"title":"手摸手 Elastic Stack 使用教程 - 环境安装","text":"前言在日常的开发中，会涉及到对一些中间件以及基础组件的使用，日志汇总分析、APM 监控、接口的健康检查、站内搜索，以及对于服务器、nginx、iis 等等的监控，最近的几个需求点，都和 Elastic Stack 有着很大的联系，有些需求可能使用 Elastic Stack 并不会是最优的方案，本着减少后期运维风险的原则，所以这里选择了统一 因此自己之前也没接触过，所以私底下就自己捯饬捯饬，看看如何使用，毕竟，技多不压身，当然，能够使用的前提是有环境支持，所以第一步需要在本地安装上 Elastic Stack Step by Step介绍&amp;准备Elastic Stack，主要包含了 Elasticsearch（数据存储）和 Kibana（可视化管理）以及一系列的插件，插件最终实现的也是将各种指标、日志、数据抽取到 elasticsearch 中，通过 kibana 进行可视化的展示、数据分析 作为整个技术栈的基础，所以首先需要安装的就是 elasticsearch 和 kibana 虽然也可以安装在 windows 上，但是本着不给自己找事的原则，以及出了问题好寻找解决方案，这里选择将 Elastic Stack 安装到 CentOS 7.6 上 因为我是使用的 RPM 进行安装的，由于某些原因，官网提供的组件包下载地址，如果没有特殊手段的话，可能会下载到地老天荒，因此这里可以使用国内的镜像地址进行下载，我是使用的清华的镜像进行下载的(链接直达)，你可以依据自己的喜好来选择镜像地址 下载组件包登录服务器，通过 wget 命令下载 elasticsearch 和 kibana or 直接在本地下载好然后再丢到服务器上，这里需要注意，确保 elasticsearch、kibana 以及后续使用的各个插件的版本一定要保持一致，不然的话可能会存在一些莫名其妙的问题 12345-- 下载 elasticsearchwget https://mirrors.tuna.tsinghua.edu.cn/elasticstack/yum/elastic-7.x/7.9.0/elasticsearch-7.9.0-x86_64.rpm-- 下载 kibanawget https://mirrors.tuna.tsinghua.edu.cn/elasticstack/yum/elastic-7.x/7.9.0/kibana-7.9.0-x86_64.rpm 安装与配置配置 elasticsearch当组件下载完成后，就可以开始程序的安装，因为我是使用的 RPM 包，所以这里可以直接通过 rpm 命令完成 elasticsearch 的安装 1sudo rpm --install elasticsearch-7.9.0-x86_64.rpm 当命令执行完成后，可以看到，控制台已经很清楚的提醒我们，通过 systemctl 指令就可以完成对于 elasticsearch 服务的管理 123456-- 设置开机自启sudo systemctl daemon-reloadsudo systemctl enable elasticsearch.service-- 启动 elasticsearch 服务sudo systemctl start elasticsearch.service 启动之后，可以在服务器上通过 curl 127.0.0.1:9200 来验证我们的 elasticsearch 是否已经安装成功，如果可以显示出服务的相关信息，则代表 elasticsearch 已经安装成功了 与 mysql、mongodb 相同，默认情况下，elasticsearch 是不允许远程访问服务的，但是，鉴于实际的使用情况，这里需要修改配置文件，从而允许远程访问服务器上的 elasticsearch 服务 首先，通过 whereis elasticsearch 命令查找程序的安装路径，这里会有两个路径，通过查阅官方文档可以得知，/etc/elasticsearch 是配置文件所在的路径，而 /usr/share/elasticsearch 则是 elasticsearch 的运行路径所在 切换到 /etc/elasticsearch 目录下，打开 elasticsearch.yml 文件，找到 Network 节点，调整如下的配置，从而允许远程访问服务。PS，因为配置文件是 yml 文件，所以这里的对于内容格式有着很严格的要求，一定不能忘记 : 后面的空格 1network.host: 0.0.0.0 当配置文件被修改后，需要重新启动 elasticsearch 服务，通过 systemctl 命令来重启服务，不出意外的话，你会发现服务启动不起来 :smirk: 12-- 重启 elasticsearch 服务systemctl restart elasticsearch.service 这里我们可以通过 systemctl status 来查看服务无法正常启动的原因 1systemctl status elasticsearch.service -l 在控制台打印的信息中，我们重点关注错误信息中的这句话，可以看到，我们需要针对 elasticsearch 进行节点的相关配置，因为这里采用的只是单机单节点，并不会搭建集群，因此，重新打开 elasticsearch.yml 文件，修改如下的配置项即可 the default discovery settings are unsuitable for production use; at least one of [discovery.seed_hosts, discovery.seed_providers, cluster.initial_master_nodes] must be configured 12345678# 设置集群名称cluster.name: elastic-cluster# 设置节点名称node.name: node-mater# 默认初始化的节点名称cluster.initial_master_nodes: [\"node-mater\"] 当然，你也可以直接修改配置文件，指明当前的 elasticsearch 服务以单节点的形式运行，不过，不推荐这种方式 1discovery.type: single-node 保存对于配置文件的修改，重新执行启动服务的命令，可以看到服务已经启动以来了，当然，此时如果你想要通过远程访问该服务的话，还请确保服务器的防火墙有开放 9200 端口，此时再通过浏览器访问即可打开如下的页面 12345-- 永久开放 9200 端口sudo firewall-cmd --zone=public --add-port=9200/tcp --permanent-- 重启防火墙firewall-cmd --reload 安装 kibana与安装 elasticsearch 时相似，回到文件所在的路径，通过 rpm 命令，就可以完成 kibana 的安装，之后就可以通过 systemctl 来控制 kibana 的启动 123456789101112-- 回到用户的根目录cd ~-- 安装 kibanasudo rpm --install kibana-7.9.0-x86_64.rpm-- 设置开机自启sudo systemctl daemon-reloadsudo systemctl enable kibana.service-- 启动 elasticsearch 服务sudo systemctl start kibana.service 因为 kibana 是对 elasticsearch 中的数据进行可视化管理的，所以这里需要修改 kibana 的配置文件来完成与 elasticsearch 的串接，与 elasticsearch 配置文件所在的路径相似，kibana 的配置文件位于 /etc/kibana 路径下，找到 kibana.yml 文件，需要调整的配置项如下 1234567891011## 允许远程访问server.host: \"0.0.0.0\"## 设置服务的名称server.name: \"elastic-kibana\"## 设置需要连接的 elasticsearch 服务地址elasticsearch.hosts: [\"localhost:9200\"]## 设置页面通过中文显示i18n.locale: \"zh-CN\" 当然，别忘了开放服务器的 5601 端口，从而允许远程访问 12345-- 永久开放 5601 端口sudo firewall-cmd --zone=public --add-port=5601/tcp --permanent-- 重启防火墙firewall-cmd --reload 在重新启动 kibana 之后，如果你立刻通过浏览器访问可能会提示下面的内容，嗯，请坐和放宽，等一会，多刷新几次就可以了，如果一直出现下面这个提示，可通过 systemctl status 命令来查看具体是 elasticsearch or kibana 出问题了，毕竟就这两个服务 :smile: Kibana server is not ready yet 之前在我的云服务器上安装时，当 kibana 安装启动之后，一直报这个错误，最终发现是 elasticsearch 一直启动不起来，看了看错误信息，结果发现是 elasticsearch 所使用的 jvm 内存不够了，嗯，1 核 2G 内存的主机，如果你也遇到这样的问题，这个时候你可以修改 /etc/elasticsearch 路径下的 jvm.options 文件，来调整 elasticsearch 的 jvm 虚拟机配置，之后重启就可以了 至此，就完成了 elasticsearch 和 kibana 的安装，后续也就可以基于 elasticsearch 来实现一些功能。另，对于权限相关的管控以及如何基于实际的需求来实现一些功能，则在后面不定期的文章中进行体现 注意公网直接开放 9200 端口、5601 端口很危险，请谨慎操作，谨慎操作！！！","link":"/2020/08/30/install-elastic-stack-on-centos-7/"},{"title":"从零开始针对 .NET 应用的 DevOps 运营实践 - Jenkins & SonarQube 安装配置","text":"Overview继续 DevOps 实施的相关内容，在上一篇的博客中，完成了对于工具链中使用到的软件所需的运行环境的配置，在这一篇的博客中，将聚焦于我们使用到的两个主要的软件：Jenkins 与 SonarQube 在 Windows 服务器上的部署安装，为后续 DevOps 的实施，构建软件基础 Contents 从零开始针对 .NET 应用的 DevOps 运营实践 - 运行环境搭建 从零开始针对 .NET 应用的 DevOps 运营实践 - Jenkins &amp; SonarQube 安装配置 Step by Step前言在 Jenkins 与 SonarQube 的版本选择上，这里我选择的都是最新的 LTS 版本，也就是长期支持版本，如果你没有什么特定的需求的话，建议不要选择过于古老的软件版本 这里请重点关注 SonarQube 的版本问题，对于自动化代码检查的数据，SonarQube 支持持久化到常见的数据库中（默认使用的是 H2 数据库），然而 8.x 之后的版本只支持持久化到 Oracle、SQL Server 以及 PostgreSQL，嗯，同 Gitlab 一样，没有 MySQL 因此，如果你需要持久化数据到 MySQL 数据库，最后一个能选择的版本则是 7.7 版本（电梯直达），并且这个版本只支持 MySQL 5.6、5.7，考虑到后续已经不再支持 MySQL 数据库的缘故，请谨慎考虑是否一定要采用该版本 Jenkins程序安装打开 Jenkins 官网，找到下载页面（https://www.jenkins.io/download/），选择最新的 LTS 版本下载，针对 Windows 平台，可以通过 war 包运行，在 docker 中运行，以及通过 msi 安装包安装之后，作为一个 Windows 服务运行 作为一个需要持续运行的服务，这里我选择通过 msi 方式的来完成程序的部署 双击 msi 安装文件，配置软件的安装路径，对于这种基础的软件服务，建议还是放在默认的位置 因为 Jenkins 在安装之后，是会作为一个独立的 Windows 服务的，如果你需要使用域账户或本地账户作为服务的运行方来运行该服务的话，这里需要进行配置账户、密码 Jenkins 默认使用 8080 端口，可以点击下方的 Test Port 按钮来测试当前设定的端口是否已经被占用 在上一篇中有提到 Jenkins 是基于 Java 进行开发的，在软件的安装过程中，安装程序默认会带出来我们配置的 Java SDK 信息，当然，你也可以在这里针对 Jenkins 设置不同的 Java SDK 完成所需运行环境的配置之后，将 Jenkins 服务所使用的 8080 端口添加到防火墙的白名单中，从而允许别的机器可以访问到该服务 当配置完成之后，点击 Install 等待安装完成即可，当安装向导提示安装完成时就可以通过浏览器访问 Jenkins 基础配置打开浏览器，按照页面上的提示，我们需要找到位于指定路径上的密码，复制到页面上的输入框，来完成 Jenkins 的解锁，从而继续后续的操作 解锁之后，Jenkins 会提示你安装一些必要的插件，这里如果你因为网络问题没有安装成功或者压根没有弹出这个页面，也没有关系，后续可以在程序中手动的选择需要安装的插件 等待插件的安装完成 or 直接跳过插件的安装，创建一个管理员账户，用来管理我们的 Jenkins 系统，点击下一步，会需要我们配置一个 Jenkins URL，这个地址采用默认的地址即可，这里一定要注意，如果你调整了该 URL 的配置，后续一定要通过 Web 服务器进行反向代理，否则后续会出现各种问题 点击保存并完成之后，基本的 Jenkins 运行环境就安装配置完成了，当然，为了实现我们的需求，还需要后续在此基础上，安装各种所需的插件，从而实现构建流水线来完成持续集成的功能 SonarQube程序安装同 Jenkins 一样，SonarQube 同样选择最新的 LTS 版本进行下载了（电梯直达） SonarQube 下载完成的是一个压缩包，解压压缩包，找到 bin 目录，里面列出了在不同操作系统运行程序的方式，因为我们是在 Windows 平台，所以这里选择 windows-x86-64 文件夹。同样的，作为一个需要常驻的服务，这里最好也将应用作为 Windows 服务进行运行 右击 InstallNTService.bat 选择以管理员身份运行，再使用管理员身份运行 StartNTService.bat 即可 打开浏览器，SonarQube 默认使用 9000 端口，等待一段时间，如果可以看到如下的页面，则代表应用已经安装成功，点击右上角的 Log in，输入默认的账户、密码即可登录到系统中（默认的账户、密码都是 admin） PS：如果 9000 端口已经被占用了，可以找到 conf 文件下的 sonar.properties 文件修改 sonar.web.port 配置然后重启服务即可 数据持久化对于自动化的代码检查数据，是具有一定的价值的，因为目前数据还是存储在 SonarQube 内置的 H2 数据库中，为了便于后续的使用，这里选择持久化到 SQL Server 数据库中 PS：请关注你使用的 SonarQube 所支持的数据库版本信息 新建一个数据库，这里必须调整数据库的排序规则为 CS（case-sensitive，区分大小写）、AS（accent-sensitive，区分重低音），例如这里我选择的排序规则为 Chinese_PRC_CS_AS 数据库创建之后，需要执行如下的 SQL 语句，确保当前库的 is_read_committed_snapshot_on 属性设置为 true，这里的 sonar 就是我新建的数据库名称 12345-- 查看 is_read_committed_snapshot_on 是否启用SELECT is_read_committed_snapshot_on FROM sys.databases WHERE name=&apos;sonar&apos;;-- 打开 is_read_committed_snapshot_onALTER DATABASE sonar SET READ_COMMITTED_SNAPSHOT ON WITH ROLLBACK IMMEDIATE; 数据库设置完成之后，我们需要下载 Microsoft SQL JDBC Driver 7.2.2 package 这个 SQL Server 的 JDBC 驱动到本地，这里选择下载压缩包 找到下载之后的压缩包解压，选择 auth 路径下的 x64 文件夹，获取到这个 64 位的 sqljdbc_auth.dll 文件，拷贝到 SonarQube 的路径下，这里我在 \\extensions\\jdbc-driver 路径下新建了一个 mssql 文件夹用来存放这个 dll 文件 驱动下载完成后，找到 conf 文件下的 sonar.properties 文件，修改数据库连接信息，重新启动 SonarQube 服务，等待数据库表的创建完成，嗯，这个过程比较慢，耐心等待 等待应用的重新启动完成，与 Jenkins 相同，我们可以安装各种插件来丰富 SonarQube，这里我们可以在登录系统后，点击 Administration 菜单，在 Marketplace 中，下载所需的插件，例如这里可以下载中文的语言包，重启之后，系统就变成了中文 同样的，针对服务器无法连接外网的同学，我们可以从网络上找到需要的插件进行下载，然后放到程序运行路径下的 \\extensions\\plugins 文件夹中，重启服务即可 总结自此，Jenkins 和 SonarQube 就已经安装配置完成了，当然，为了实现我们的需求，在实际使用时 Jenkins 还需要安装一些必须的插件，在下一章中，就可以通过与 Gitlab 进行串接，完成 .NET 应用的持续集成工作","link":"/2020/10/17/install-jenkins-and-sonarqube-on-windows-server/"},{"title":"我的领域驱动设计运用实例 - 领域啊领域","text":"前言断断续续的也有在闲余时间接触领域驱动设计的相关知识，因为目前在工作中更多的还只是一名 crud boy，因此目前也只是对其中的某些知识点有知晓，实际使用的比较少，仅此而已。因此，趁着这个春节假期，整理了一下自己的 github 帐号，同时结合自己定的学习计划以及自己的期望发展方向，决定从一个真实的案例来梳理领域驱动的相关知识。 本篇文章是开篇，因为领域驱动设计相关的知识真的不怎么好懂，如果行文中出现错误的地方，欢迎大家在评论区指出，先行感谢。 当然，talk is cheap, show me the code，作为一名 .NET 开发人员，实例中的服务端代码全部是基于 ASP.NET Core 框架进行搭建的。 系列目录 我的领域驱动设计运用实例 - 领域啊领域 Step by Step不清楚大家在接触领域驱动的相关知识时，是不是一上来就是领域驱动经典的四层架构，然后什么是实体、值对象、聚合，它们之间有什么异同以及与传统的开发模式又是什么，领域模型又是什么东东，最终接触到一大堆的概念，结合上网搜到的示例项目代码，结果最后就知道了几个名词。 当然，这些都是领域驱动设计中比较重要的知识点，可能是自己入行较短，按照上面的这个顺序看了一遍，看完之后，嗯，貌似最后都没看完，我只能是下面的这种表情。。。因此，为了不让像我这样的小白用户一上来就用药过猛，所以这里我换一种方式来尝试解释我所认为的领域驱动设计，如若存在偏差，希望可以帮忙指出。 第一篇介绍的是我认为领域驱动设计中一个最基础的东西，也是很多文章中并没有说的，如何去识别出业务领域并进行划分。 案例分析因为在识别领域时，需要做到对于业务流程有比较深刻的了解，至少应该做到有相关软件的使用经历，因此在这个系列的文章中，我选择的是项目管理软件作为文章的示例项目。最终实现的各种需求是基于禅道项目管理软件这个开源项目的，因此，在开发这个项目之前，我们可以先看看禅道这个项目管理系统中所包含的功能模块。毕竟，只有在了解需求之后才好进行下一步的工作。 在这个开源的项目管理系统中，主要包含了如下的几个功能。 除了一些基础的权限相关功能，站在项目产品的角度，禅道包含了对于产品的分支、团队成员、迭代版本、功能模块、功能需求等数据信息的维护，同时针对项目可以去设定各种任务、以及可以提 bug 等等任务操作。 当然，系统所包含的功能还可以继续往下展，如果按照我们面向数据库开发的经验，在弄清楚系统的各项功能后，可能就是去建各种的表了，继而识别出各个表之间的关联关系，然后就 ctrl c、ctrl v 的开干了。当然，这里既然选择采用一种新的方式进行开发，忘掉我们原来的经验，从一个新的角度开始。 领域划分领域驱动设计，在维基百科中对于领域的解释如下，因为词条的中文解释应该是机翻的，所以这里放出英文原文，下方的中文是我基于个人理解所提供的翻译，仅供参考。 A sphere of knowledge (ontology), influence, or activity. The subject area to which the user applies a program is the domain of the software; 领域是一种关于知识、影响或是活动的范围限定。软件的领域是用户想要通过使用该程序所要达到的主体功能。 范围，即是边界，能够置于相同范围内的事物必定是具有着某种相同的特性，我们通过代码的手段来解决现实中的问题时，也会将某些共通的业务放到一块。 因此，在使用领域驱动的思想来指导软件开发的过程中，我们需要按照一定的业务规则将期望达成的业务进行细分，在最终划分出的一个个小业务范围内，通过建立领域模型的方式，指导代码实现，从而解决具有共同特性的问题，因此，领域驱动设计中的领域就是这个业务边界范围内想要解决的业务问题域。 接下来，针对我们期望实现的项目管理系统，就是需要按照一定的业务规则，完成我们的业务领域的划分。 第一步：确定研究对象，明确我们将要研究的业务领域，识别出最终需要解决的业务问题； 我们最终想要实现的目标是一个项目管理系统，因此这里我们的研究对象就是项目管理。 第二步：对研究对象按照一定的业务逻辑进行细分，将领域进一步的划分成多个子领域； 从上面了解到的期望实现的系统功能中看出来，基于各个项目管理中不同业务的特性，我们可以将项目管理这个领域拆分成项目子域、版本子域、任务子域等等。 第三步：对识别出的子领域再次进行细化，从而识别出子领域中的最小单元，从而确定所需要研究的范围边界； 在识别出领域的各个子域之后，我们需要对子域进行进一步的细化，当不能再细化的时候，我们就可以在这个限界上下文中去建立该子领域的领域模型，从而构建出代码模型，完成最终的编程开发。 就像上面列出的步骤一样，我们在对业务领域进行不断的拆分中，会划分出不同的子域。对于业务来说，某些业务很重要，某些可能就无关紧要。因此在划分子领域的过程中，通过子域的重要性和业务功能属性的差异，我们可以将其区分成核心子域、通用子域、以及支撑子域。 核心子域是我们需要解决的业务核心问题，支撑子域是支撑我们的核心子域实现的业务，而通用子域则更多的是每个系统中一些通用的业务功能，例如，认证、授权等等。因此，在实现业务时，我们应该将核心子域的建设摆在首位。 按照上面的步骤，识别出的业务领域如下图所示，因为这里的领域划分，更多的是我个人的想法，所以会存在思考不完善的地方，如果你有别的看法，欢迎指出。 可以看到，这里其实只是识别出了比较粗放的业务子领域，并没有完成对于业务最小单元的边界识别。因为这块的内容会与领域建模关联比较大，所以统一放到下一篇文章中，通过介绍如何用事件风暴的方式完成对于业务领域的建模时一起介绍。 嗯，其实就是完全没想好怎么写。。。 个人总结 领域驱动的核心是完成对于领域模型的定义，从而确定业务和应用边界，保证我们的业务模型与代码模型一致性； 领域驱动是一种架构设计的方法论，通过围绕实际业务构建领域模型的方式将复杂的业务领域逐步的拆分，帮最终找出最基础的业务功能与其对应的最基础功能应用的边界； 领域是用来确定功能的范围，范围即是边界，相同的业务问题应该限制在特定的一个功能范围中。一个业务领域可以继续划分，最终实现将业务域进行不断的拆解，从而降低对于整体业务的理解和系统实现的复杂度； 参考资料 阿里盒马领域驱动设计实践 DDD理论学习系列——案例及目录 浅谈我对DDD领域驱动设计的理解","link":"/2020/01/31/my-ddd-thought-application-sample-domain-ah-domain/"},{"title":"在 ASP.NET Core 程序启动前运行你的代码","text":"前言在进行 Web 项目开发的过程中，可能会存在一些需要经常访问的静态数据，针对这种在程序运行过程中可能几乎不会发生变化的数据，我们可以尝试在程序运行前写入到缓存中，这样在系统后续使用时就可以直接从缓存中进行获取，从而减缓因为频繁读取这些静态数据造成的应用数据库服务器的巨大承载压力。 既然需要在程序运行前将静态数据写入到缓存中，毫无疑问我们需要在程序运行前执行一些自定义功能的代码，那么在本章中，我将会介绍如何在 ASP.NET Core 项目中，实现在程序启动前执行某些特定功能的代码。 Step by Step先说结论因为这一篇文章更多的是在说明我在解决这个问题时的一步步思考，并没有涉及到代码的编写，所以下面的内容可能对你的帮助并不是很大，所以这里提前将实现的方式告诉大家。对于这个问题来说，只需要将我们想要执行的代码放到下面代码中注释所在的位置，即可实现我们的需求。 123456789101112131415161718public class Program{ public static void Main(string[] args) { var host = CreateHostBuilder(args).Build(); // do what you want host.Run(); } public static IHostBuilder CreateHostBuilder(string[] args) =&gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =&gt; { webBuilder.UseStartup&lt;Startup&gt;(); });} 前车之鉴在尝试如何在 ASP.NET Core 中实现这一功能需求前，我们可以看看在 .NET Framework 中如何实现这一功能，是不是可以对我们在后续的功能实现中提供某些借鉴。 对于采用 .NET Framework 的应用程序来说，项目创建后会生成一个 Global.asax 文件，在这个类文件中存在着 Application_Start 这样的一个方法，而 Application_Start 这个方法实际上是在当应用程序接收到第一个 HTTP 请求时触发，也就是说，当系统运行后第一次接收到用户的请求，就会触发 Application_Start 中的代码逻辑，后续不管再接收到多少的请求，都不会再触发该方法。 例如在这个基于 .NET Framework 构建的 MVC 项目模板中，在程序运行前需要执行注册路由信息、注册过滤器、注册使用 bundle 压缩后的 js、css 文件等等。 但是在 ASP.NET Core 项目中，并没有原生存在这样的方法，那么我们如何在 ASP.NET Core 应用中自己动手实现类似的功能呢？ 后事之师了解了在之前版本中的实现方式，现在我们仔细看看 Application_Start 这个方法中执行的每行代码的功能，是不是特别像我们在 ASP.NET Core 项目中使用的各种中间件？ 然而，如果你有使用过 ASP.NET Core 后就会知道，ASP.NET Core 中的中间件是会在每次请求时都会触发的，虽然我们可以在我们自定义的中间件中设置缓存中不存在数据就写入，存在就直接跳过的代码逻辑，但是既然除了第一次访问时才会真正执行该中间件的功能，后面完全用不到，因此，对于我这种略微强迫症的童鞋来说，这个真的不能忍。。。 既然中间件不可以，而我们需要的仅仅是只运行一次，提到 .NET Core，不知道你的第一印象是什么，对于我个人来说，无处不在的依赖注入，可能是我在 18 年开始学习 .NET Core 时的第一印象。我们知道，对于 .NET Core 中原生的依赖注入组件，存在着三种生命周期：Singleton、Scoped 以及 Transient，对于这三种生命周期的具体解释，还是推荐博客园里蒋金楠老师的一篇文章（电梯直达）。 对于采用 Singleton 方式注入的服务来说，因为是一种类似于全局单例的形式，不管后续从何处进行访问，都会访问的是同一个实例，那么，这里是不是就可以在此基础上实现我们的需求了呢？ 很不幸，这里其实是有个很严重的逻辑上的问题的，依赖注入最终的目的是为了实现将我们定义的服务契约与实现进行解耦，实现服务的消费者只需要告诉依赖注入容器自己所需要服务的类型（服务接口 or 抽象服务类），就能自动得到与之匹配的服务实例。 简单点说就是，消费方要告诉服务提供方你要开始使用某个服务了，我才能给你提供对应的服务，就像我们去饭店吃饭，在点了菜后，没有必要关心厨师是用天然气 or 煤气给你烧的菜，但是能不能上菜的关键在于我们有没有点菜。因此，这个问题最终还是落在了我们应该在程序中的什么地方去调用我们设定好的方法。 绕了一圈，似乎我们的想法越来越偏，离我们想要实现的越来越远，既然路偏了，那就直接回到起点吧，抛弃我们在 .NET Framework 项目中的经验，重新从 ASP.NET Core 项目的启动流程开始看起。 在 ASP.NET Core 应用的启动过程中存在着两个非常重要的对象，对应到我们采用的 ASP.NET Core 3.X 的项目中则是 Host 以及 HostBuilder。这里的 Host 就是承载我们 Web 应用运行的载体，而 HostBuilder 则是用来构建 Host 对象的。 PS：因为 ASP.NET Core 3.0 开始加入了 对于 gRPC 框架和 Windows Service 的支持，同时为了与其它非 Web 服务器方案进行集成，因此将原来的 WebHost 和 WebHostBuilder 替换成了新的通用主机（generic-host）配置的模式 。当然，在 3.X 版本你还是可以使用 WebHost 和 WebHostBuilder 的，不过当然是不推荐的。 因为对于 ASP.NET Core 应用程序来说，本质上其实只是一个控制台应用，所以现在我们来看看对于一个控制台应用中最重要的文件：Program.cs， Program 类中的代码如下所示。 1234567891011121314public class Program{ public static void Main(string[] args) { CreateHostBuilder(args).Build().Run(); } public static IHostBuilder CreateHostBuilder(string[] args) =&gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =&gt; { webBuilder.UseStartup&lt;Startup&gt;(); });} 代码很少，功能也很简单，简单来说，在 Main 方法中构建 HostBuilder 对象，然后去运行它，达到启动我们 Web 应用宿主的目的。 当然，在构建 HostBuilder 对象的过程中，会配置 Kestrel 服务器，会设置 ContentRoot，会加载配置文件等等一系列的动作，因为自己水平太次，尝试了一下，还是解释不好，如果你想要深入了解的话，建议配合博客园里面的这两篇文章一起食用（200行代码，7个对象——让你了解 ASP.NET Core 框架的本质、ASP.NET Core 2.0 : 七.一张图看透启动背后的秘密）。虽然参考文章中都是基于 ASP.NET Core 2.X 版本进行解释说明的，但其实最终的差异不是很大。 不知你是否找到了这个类中对于我们最重要的一点，在 Main 方法中，我们是先构建、再去运行，因此，我们是不是可以在构建完成后，先等一等，把我们想要实现的功能先调用了，再去运行我们的程序。嗯，让我们改造下 Main 方法中的代码。 123456789101112131415161718192021public class Program{ public static void Main(string[] args) { var host = CreateHostBuilder(args).Build(); // Get logger // var logger = host.Services.GetRequiredService&lt;ILogger&lt;Program&gt;&gt;(); logger.LogInformation(\"haha, I ran before web host starting\"); host.Run(); } public static IHostBuilder CreateHostBuilder(string[] args) =&gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =&gt; { webBuilder.UseStartup&lt;Startup&gt;(); });} 从上面的图中可以看到，在我们的 Web 应用的宿主程序还未启动之前，控制台就已经打印出了我们自己设定的信息，之后，才是启动我们的 Web 应用，这里是请求我们的 API 接口。同时可以发现，在模拟多次请求时，并不会再次触发我们预设的事件。 总结这一篇文章中并没有包含代码，更多的是针对我之前在开发中遇到的一个问题，自己在解决过程中的一个案例说明，希望可以在你以后遇到这类问题时可以提供一些帮助。离 2020 年的农历新年也没有几天了，按目前的进度，估计就是年前的最后一篇博客了，我也要收拾收拾心情，准备过年了。最后，送大家一张表情包，献给得知你是最后一个放假的童鞋，哈哈哈，提前祝大家新年快乐丫。 参考 [ASP.NET Core 3框架揭秘] 依赖注入[8]：服务实例的生命周期 200行代码，7个对象——让你了解 ASP.NET Core 框架的本质 ASP.NET Core 2.0 : 七.一张图看透启动背后的秘密 ASP.NET Core 3.0 的新增功能","link":"/2020/01/19/run-your-code-before-asp-net-core-program-start/"},{"title":"在 ASP.NET Core 应用中使用 Cookie 进行身份认证","text":"Overview身份认证是网站最基本的功能，最近因为业务部门的一个需求，需要对一个已经存在很久的小工具网站进行改造，因为在逐步的将一些离散的系统迁移至 .NET Core，所以趁这个机会将这个老的 .NET Framework 4.0 的项目进行升级 老的项目是一个 MVC 的项目并且有外网访问的需求，大部门的微服务平台因为和内部的业务执行比较密切，介于资安要求与外网进行了隔离，因此本次升级就不会迁移到该平台上进行前后端分离改造 使用频次不高，不存在高并发，实现周期短，所以就没有必要为了用某些组件而用，因此这里还是选择沿用 MVC 框架，对于网站的身份认证则采用单体应用最常见的 Cookie 认证来实现，本篇文章则是如何实现的一个基础的教程，仅供参考 Step by Step在涉及到系统权限管理的相关内容时，必定会提到两个长的很像的单词，authentication（认证） 和 authorization（授权） authentication：用一些数据来证明你就是你，登录系统、指纹、面部解锁就是一种认证的过程 authorization：授予一些用户去访问一些特殊资源或功能的过程，系统包含管理员和普通用户两种角色，只有管理员才可以执行某些操作，赋予管理员角色某些操作的过程就是授权 只有认证和授权一起配合，才可以完成对于整个系统的权限管控 前期准备假定现在已经存在了一个 ASP.NET Core MVC 应用，这里以 VS 创建的默认项目为例，对于一个 MVC or Web API 应用，要求用户必须登录之后才能进行访问，最简单的方式，在需要认证的 Controller 或 Action 上添加 Authorize 特性，然后在 Startup.Configure 方法中通过 UseAuthorization 添加中间件即可 12345678[Authorize]public class HomeController : Controller{ public IActionResult Index() { return View(); }} 12345678910111213141516public class Startup{ public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =&gt; { endpoints.MapControllerRoute( \"default\", \"{controller=Home}/{action=Index}/{id?}\"); }); }} 当然，当系统只包含一个两个 Controller 时还好，当系统比较复杂的时候，再一个个的添加 Authorize 特性就比较麻烦了，因此这里我们可以通过在 Startup.ConfigureServices 中添加全局的 AuthorizeFilter 过滤器，实现对于全局的认证管控 123456789public class Startup{ public void ConfigureServices(IServiceCollection services) { services.AddControllersWithViews() .AddMvcOptions(options =&gt; { options.Filters.Add(new AuthorizeFilter()); }); }} 此时，对于一些不需要进行认证就可以访问的页面，只需要添加 AllowAnonymous 特性即可 12345678public class AuthenticationController : Controller{ [AllowAnonymous] public IActionResult Login() { return View(); }} 配置认证策略当然，如果只是这样修改的话，其实是有问题的，可以看到，当添加上全局过滤器后，系统已经无法正常的进行访问 对于 authorization（授权） 来说，它其实是在 authentication（认证）通过之后才会进行的操作，也就是说这里我们缺少了对于系统认证的配置，依据报错信息的提示，我们首先需要通过使用 AddAuthentication 方法来定义系统的认证策略 AddAuthentication 方法位于 Microsoft.AspNetCore.Authentication 类库中，通过在 Nuget 中搜索就可以发现，.NET Core 已经基于业界通用的规范实现了多个认证策略 因为这里使用的 Cookie 认证已经包含在默认的项目模板中了，所以就不需要再引用了 基于 .NET Core 标准的服务使用流程，首先，我们需要在 Startup.ConfigureServices 方法来中通过 AddAuthentication 来定义整个系统所使用的一个授权策略，以及，基于我们采用 Cookie 授权的方式，结合目前互联网针对跨站点请求伪造 (CSRF) 攻击的防范要求，我们需要对网站的 Cookie 进行一些设定 1234567891011121314151617181920212223242526272829303132public class Startup{ public void ConfigureServices(IServiceCollection services) { // 定义授权策略 services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme) .AddCookie(options =&gt; { // 无权访问的页路径 options.AccessDeniedPath = new PathString(\"/permission/forbidden\"); // 登录路径 options.LoginPath = new PathString(\"/authentication/login\"); // 登出路径 options.LogoutPath = new PathString(\"/authentication/logout\"); // Cookie 过期时间(20 分钟) options.ExpireTimeSpan = TimeSpan.FromMinutes(20); }); // 配置 Cookie 策略 services.Configure&lt;CookiePolicyOptions&gt;(options =&gt; { // 默认用户同意非必要的 Cookie options.CheckConsentNeeded = context =&gt; true; // 定义 SameSite 策略，Cookies允许与顶级导航一起发送 options.MinimumSameSitePolicy = SameSiteMode.Lax; }); }} 如代码所示，在定义授权策略时，我们定义了三个重定向的页面，去告诉 Cookie 授权策略这里对应的页面在何处，同时，因为身份验证 Cookie 的默认过期时间会持续到关闭浏览器为止，也就是说，只要用户不点击退出按钮并且不关闭浏览器，用户会一直处于已经登录的状态，所以这里我们设定 20 分钟的过期时间，避免一些不必要的风险 至此，对于 Cookie 认证策略的配置就完成了，现在就可以在 Startup.Configure 方法中添加 UseAuthentication 中间件到 HTTP 管道中，实现对于网站认证的启用，这里需要注意，因为是先认证再授权，所以中间件的添加顺序不可以颠倒 12345678910111213141516171819public class Startup{ public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { app.UseRouting(); // 添加认证授权（顺序不可以颠倒） // app.UseAuthentication(); app.UseAuthorization(); app.UseEndpoints(endpoints =&gt; { endpoints.MapControllerRoute( \"default\", \"{controller=Home}/{action=Index}/{id?}\"); }); }} 此时，当我们再次访问系统时，因为没有经过认证，自动触发了重定向到系统登录页面的操作，而这里重定向跳转的页面就是上文代码中配置的 LoginPath 的属性值 登录、登出实现当认证策略配置完成之后，就可以基于选择的策略来进行登录功能的实现。这里的登录页面上的按钮，模拟了一个登录表单提交，当点击之后会触发系统的认证逻辑，实现代码如下所示。这里别忘了将登录事件的 Action 上加上 AllowAnonymous 特性从而允许匿名访问 12345678910111213141516171819202122232425[HttpPost][AllowAnonymous][ValidateAntiForgeryToken]public async Task&lt;IActionResult&gt; LoginAsync(){ // 1、Todo:校验账户、密码是否正确，获取需要的用户信息 // 2、创建用户声明信息 var claims = new List&lt;Claim&gt; { new Claim(ClaimTypes.Name, \"张三\"), new Claim(ClaimTypes.MobilePhone, \"13912345678\") }; // 3、创建声明身份证 var claimIdentity = new ClaimsIdentity(claims, CookieAuthenticationDefaults.AuthenticationScheme); // 4、创建声明身份证的持有者 var claimPrincipal = new ClaimsPrincipal(claimIdentity); // 5、登录 await HttpContext.SignInAsync(claimPrincipal); return Redirect(\"/\");} 在整块的代码中，涉及到三个主要的对象，Claim、ClaimsIdentity 和 ClaimsPrincipal，通过对于这三个对象的使用，从而实现将用户登录成功后系统所需的用户信息包含在 Cookie 中 三个对象之间的区别，借用理解ASP.NET Core验证模型(Claim, ClaimsIdentity, ClaimsPrincipal)不得不读的英文博文这篇博客的解释来说明 Claim：被验证主体特征的一种表述，比如：登录用户名是…，email是…，用户Id是…，其中的“登录用户名”，“email”，“用户Id”就是 ClaimType ClaimsIdentity：一组 claims 构成了一个 identity，具有这些 claims 的 identity 就是 ClaimsIdentity ，驾照就是一种 ClaimsIdentity，可以把 ClaimsIdentity理解为“证件”，驾照是一种证件，护照也是一种证件 ClaimsPrincipal：ClaimsIdentity 的持有者就是 ClaimsPrincipal ，一个 ClaimsPrincipal 可以持有多个 ClaimsIdentity，就比如一个人既持有驾照，又持有护照 最后，通过调用 HttpContext.SignInAsync 方法就可以完成登录功能，可以看到，当 Cookie 被清除后，用户也就处于登出的状态了，当然，我们也可以通过手动的调用 HttpContext.SignOutAsync 来实现登出 获取用户信息对于添加在 Claim 中的信息，我们可以通过指定 ClaimType 的方式获取到，在 View 和 Controller 中，我们可以直接通过下面的方式进行获取，这里使用到的 User 其实就是上文中提到的 ClaimsPrincipal 1var userName = User.FindFirst(ClaimTypes.Name)?.Value; 而当我们需要在一个独立的类库中获取存储的用户信息时，我们需要进行如下的操作 第一步，在 Startup.ConfigureServices 方法中注入 HttpContextAccessor 服务 123456789public class Startup{ public void ConfigureServices(IServiceCollection services) { // 注入 HttpContext services.AddHttpContextAccessor(); }} 第二步，在你需要使用的类库中通过 Nuget 引用 Microsoft.AspNetCore.Http，之后就可以在具体的类中通过注入 IHttpContextAccessor 来获取到用户信息，当然，也可以在此处实现登录、登出的方法 123456789101112131415161718192021222324252627282930313233namespace Sample.Infrastructure{ public interface ICurrentUser { string UserName { get; } Task SignInAsync(ClaimsPrincipal principal); Task SignOutAsync(); Task SignOutAsync(string scheme); } public class CurrentUser : ICurrentUser { private readonly IHttpContextAccessor _httpContextAccessor; private HttpContext HttpContext =&gt; _httpContextAccessor.HttpContext; public CurrentUser(IHttpContextAccessor httpContextAccessor) { _httpContextAccessor = httpContextAccessor ?? throw new ArgumentNullException(nameof(httpContextAccessor)); } public string UserName =&gt; HttpContext.User.FindFirst(ClaimTypes.Name)?.Value; public Task SignInAsync(ClaimsPrincipal principal) =&gt; HttpContext.SignInAsync(principal); public Task SignOutAsync() =&gt; HttpContext.SignOutAsync(); public Task SignOutAsync(string scheme) =&gt; HttpContext.SignOutAsync(scheme); }} 至此，整块的认证功能就已经实现了，希望对你有所帮助 Reference SameSite cookies Work with SameSite cookies in ASP.NET Core What does the CookieAuthenticationOptions.LogoutPath property do in ASP.NET Core 2.1? 理解ASP.NET Core验证模型(Claim, ClaimsIdentity, ClaimsPrincipal)不得不读的英文博文 Introduction to Authentication with ASP.NET Core","link":"/2021/01/31/use-cookie-authentication-in-asp-net-core/"},{"title":"【Vue 牛刀小试】：第十七章 - 优化 Vue CLI 3 构建的前端项目模板（1）- 基础项目模板介绍","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上一章中，我们开始通过 Vue CLI 去搭建属于自己的前端 Vue 项目模板，就像我们 .NET 程序员在使用 asp.net core 时一样，我们更多的会在框架基础上按照自己的开发习惯进行调整。因此在后面几章的学习中，我将会在整个项目基础上，按照自己的需求进行修改设定。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PS：因为毕竟自己还是传统意义上的后端开发，所以这里最终搭建完成的前端项目模板，其实是按照 PanJiaChen 开源的 vue-admin-template 模板进行修改仿写，所以你可以把这个系列后续的文章当成是对于 vue-admin-template 模板的使用资料补充。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系列目录地址：Vue.js 牛刀小试&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仓储地址：https://github.com/Lanesra712/ingos-web 干货合集&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在调整项目模板前，我们首先还是先来了解下我们通过 Vue CLI 3 所搭建的这个基于 Element UI 的项目模板，整个模板的文件结构及相关解释说明如下所示。1234567891011121314151617181920212223242526272829303132|-- ingos.web |-- node_modules // 项目所引用的前端组件包 |-- public // 项目发布后打包后的目录地址 |-- favicon.ico |-- index.html |-- src // 项目源文件路径 |-- assets // 静态存放路径 |-- logo.png |-- components // 项目中定义的组件存放路径 |-- HelloWorld.vue |-- plugins // 项目中引用到的第三方 Vue CLI 插件所在路径 |-- element.js |-- views // 项目中视图所在路径 |-- About.vue |-- Home.vue |-- App.vue // 项目的主组件，项目中的页面都是在此进行路由切换 |-- main.js // 主入口文件，初始化 Vue 实例并使用加载项目中需要使用的插件 |-- router.js // 项目中所有的路由定义 |-- store.js |-- tests // 单元测试文件路径 |-- units // 存放单元测试用例 |-- .eslintrc.js |-- example.spec.js |-- .browserslistrc // 指定项目的目标浏览器的范围 |-- .editorconfig // 针对不同的编辑器和 IDE 之间对于代码风格的设定 |-- .eslintrc.js // eslint 的配置文件 |-- .gitignore // git 忽略添加的文件 |-- babel.config.js // Babel 规则配置文件 |-- package-lock.json // 记录安装包的具体版本号 |-- package.json // 项目加载的组件包 |-- postcss.config.js // 针对 postcss 的配置 |-- README.md // 项目 readme 文件 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一、原始代码结构了解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、webpack 的基础概念 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为很多这个系列的读者童鞋可能和我一样，就是传统意义上的后端开发，在之前完全没有接触过这种进行前端工程化的开发模式，所以这里我会针对项目的基础模板进行一个简单的说明，如果存在不对的地方，欢迎在评论区指出。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整个项目虽然是通过 Vue CLI 进行搭建的，但是因为 Vue CLI 其实也是基于 webpack 进行构建的，所以这个项目的本质上其实是个 vue.js + webpack 项目，因此在后面的使用中会涉及到很多 webpack 的相关知识点。作为目前最主流的前端构建工具，webpack 本身的知识点会很多，所以这里只是对使用到的相关知识点进行一个简单的概述，不会详细的介绍，后续如果有使用到的时候也会进行补充。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在前端项目开发中，我们可能会引入很多的 css、js、fonts、imgs 或是其它的静态文件到页面中，当一个页面引入了很多的静态文件时，为了加载这些静态资源，网页会发起很多个二次请求，从而导致页面的加载变慢。同时，我们在使用前端框架时，经常会存在很多的依赖关系，并且由于 javascript 是一个弱类型的语言，无法在代码编写时很快速的定位到框架间的依赖问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;webpack 则可以很好的帮我们解决这些问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;webpack 是一个前端应用程序的静态模块打包工具，它是基于 node.js 进行开发的，所以在使用前我们需要安装 node.js。它可以帮我们实现对于网站所引用的静态资源进行打包、压缩、混淆；帮我们解决 js、css 中可能存在的依赖关系；将同类型的静态资源打包合并成一个文件，并对生成的代码进行混淆，以增加线上代码的安全性。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、Vue 的单文件组件 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们简单了解了项目的框架基础后，我们可以从一些之前我们没有接触过的文件去入手，去逐渐了解整个前端项目。在项目文件中我们可以看到一些以 .vue 结尾的文件，一个基础的 vue 文件包含了下面所示的三部分。1234567891011121314151617181920&lt;template&gt; &lt;p&gt;{{ greeting }} World!&lt;/p&gt;&lt;/template&gt;&lt;script&gt;module.exports = { data: function () { return { greeting: 'Hello' } }}&lt;/script&gt;&lt;style scoped&gt;p { font-size: 2em; text-align: center;}&lt;/style&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到，与我们 .NET 程序员使用的 asp.net core mvc 框架中的视图对应的 cshtml 文件很相似，它们都是在 html 文件的基础上进行了扩展。就像在 razor 页面上（.cshtml）我们可以将 C# 代码嵌入到 html 代码中，并且可以得到 IDE 的代码提示一样，在 .vue 文件中，我们也可以将很多 Vue 的特性添加到 html 代码中，并可以得到很好的语法支持和代码高亮。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Vue 项目中，我们一般将一个 .vue 文件作为一个组件。当然，浏览器是不能直接解析 cshtml、vue 这类特殊后缀的文件的，所以这里我们在使用 Vue CLI 创建项目时，脚手架已经帮我们安装了 Vue Loader 这个 webpack loader，从而帮助我们将 .vue 文件转换成浏览器能直接识别的 html、css、javascript 文件。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;webpack 的 loader 可以在我们 import 或加载模块时进行文件的预处理，完成对引入模块的源代码进行指定格式的转换。例如像这个项目一样，我们需要把 sass 文件转变成 css 文件，所以这里我们就需要在项目中添加对于 sass-loader 的引用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;亦或者，你可能在前端项目开发中会使用到 typescript，而到项目最终运行时，我们需要将 typescript 代码转换成 javascript 代码，这时，我们就需要在项目中添加 ts-loader 从而让 webpack 自动帮我们完成从 typescript 代码到 javascript 的转换。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从项目文件夹的文件分层结构可以看出，src 是项目源代码的存放路径，路径下已经存在的 assets、components、plugins、views 这几个文件夹，我们还是按照模板的原意存放对应的文件。对于单独的文件，我们来一个个的解释具体的作用。而 tests 文件夹下存放的是单元测试的测试用例，这里就不具体解释了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、对于 App.Vue 的解释 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;App.vue：项目的入口组件，这里我们会对代码进行一个简单的调整，最终整个项目中编写的 Vue 组件我们都会通过 vue router 导出到这个组件上，修改后的代码如下所示。123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div id=\"app\"&gt; &lt;router-view /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'App',};&lt;/script&gt;&lt;style&gt; body { height: 100%; font-size: 14px; -moz-osx-font-smoothing: grayscale; -webkit-font-smoothing: antialiased; text-rendering: optimizeLegibility; font-family: Helvetica Neue, Helvetica, PingFang SC, Hiragino Sans GB, Microsoft YaHei, Arial, sans-serif; } * { margin: 0; padding: 0; }&lt;/style&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、对于 main.js 的解释 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从名字上就可以看出，就像是 asp.net core 项目中的入口函数，这个 js 是整个 vue 项目的入口。我们在上面调整 App.vue 时有介绍到，最后编写好的 Vue 代码都会导出到 App.vue 文件上进行显示。在使用 Vue 时，我们是需要将构造好的 Vue 实例挂载到 dom 元素上的，从下面的代码中就可以看出，将 Vue 实例挂载到 dom 元素上的操作其实就是在这个文件中进行的。在代码中，通过引用 Element UI、Vue Router、Vuex，并将这些组件挂载到 Vue 实例上，并最终渲染到绑定的页面 dom 元素上。12345678910111213import Vue from 'vue';import App from './App.vue';import router from './routers/router';import store from './stores/store';import './plugins/element';Vue.config.productionTip = false;new Vue({ router, store, render: h =&gt; h(App),}).$mount('#app'); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可能你会有疑问，这里最终挂载的 dom 元素是在什么地方定义的呢？对于单页面应用来说，因为整个项目中其实只会有唯一的一个 html 页面，所以我们直接在项目中去寻找 html 页面就可以了。对于通过 Vue CLI 构建出来的项目，我们最终是将 Vue 挂载到 public 文件夹下面的 index.html 上。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5、对于 router.js 的解释 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个文件定义了我们整个项目的前端路由信息，因为如果将整个项目中所有的路由都配置到这一个 js 文件中，这个文件肯定会变得很庞大和不好维护，所以在后面我会添加一个 routers 文件夹去专门存放我们的前端路由信息，而原有的 router.js 文件则会起到一个导出前端路由的作用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6、对于 store.js 的解释 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为在使用 Vue CLI 创建项目时，我们添加了在 Vue 中专门针对状态管理的插件 Vuex，所以这个 js 文件就是针对 Vuex 的一些配置，这里我也会在后面专门添加一个 stores 文件夹去存放项目中使用到的状态相关数据。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基础项目的 src 文件夹下就是上面提到的这些内容，接下来我会按照自己的需求去添加一些文件夹去分类存放我们在后续项目开发中可能会使用到的东西。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、自定义调整 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、项目基础调整 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面有提到，我会创建一个 routers 文件夹去专门存储项目的前端路由信息，因为作为一个需要进行前后端数据交互的项目，所以这里我创建了一个 apis 文件夹去专门存放视图组件中需要进行后端数据访问的 js 代码。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 apis、routers 这两个文件夹的结构，这里与存放视图的 views 下的结构大体是保持一致的，例如这里 views 下面有个 home 去存放网站首页相关的视图组件，对应的路由信息就会放在 routers 下的 home 文件夹中；同时，因为我们需要和后端进行数据交互，所以这里一些请求后端的方法会按照视图的结构存放在对应的 apis 文件夹下，分层后的代码结构如下图所示。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个项目中，对于项目中的视图组件我会存放到 views 文件夹下，不过对于项目网站布局的视图组件，这里我创建了一个 layouts 文件夹，去专门存放网站布局相关的视图组件文件。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样的，对于一些我们自定义的样式文件，这里我会创建一个 styles 文件夹去存放这些样式文件；同时，对于一些基础的通用方法，这里我会放在新建的 utils 文件夹下，例如这里会存放我们基于 axios 进行封装的 http 请求方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在某些时候，我们的网站可能会存在一些的全局设置，例如设置侧边栏是否固定，是否显示 logo 等等，对于这些基础的设置项属性，这里我都会存放在 setting.js 文件中，一些简单的设置项如下所示。12345678910111213141516171819module.exports = { /** * @type {string} * @description 网站默认的 title 信息 */ title: 'ingos web template', /** * @type {boolean} true or false * @description 是否固定网站的 header */ fixedHeader: false, /** * @type {boolean} true or false * @description 是否显示侧边栏的 logo */ sidebarLogo: false,}; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、浏览器兼容性设定 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在做 web 项目时，如何做到对于主流浏览器的支持，是一个庞大的工作量，如果此时还需要兼容某些上古时代的浏览器，更是灾难，嗯，说的就是你，IE6。因为需要针对一些不同的浏览器确定需要转译的 JavaScript 特性和添加对应的 CSS 浏览器前缀，如果我们还是采取手动的方式进行编写，工作量势必会很大。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而在通过 Vue CLI 构建的项目中，我们可以通过 .browserslist 文件来指明当前这个项目的目标浏览器范围，然后这个值会被通过 webpack 加载的 @babel/preset-env 和 Autoprefixer 用来确定需要那些 js 代码是需要进行转译的以及需要添加那些 CSS 浏览器前缀。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如在这个项目中，我们声明项目的目标浏览器范围是全球使用率大于 1% 的浏览器的最新两个版本，具体的声明语法这里就不详细介绍了，你可以通过点击这个链接去了解如何指定浏览器范围（电梯直达），这里我们可以直接在工程目录下运行下面的命令来查看符合我们配置的条件而筛选出的浏览器版本范围。1npx browserslist &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;确定了目标浏览器后，我们就需要对使用的 js 代码和 css 代码进行一个设定，从而使支持的浏览器可以正常显示出。有些时候，我们写的某些 js 代码可能是符合 ES6 语法的，对于某些浏览器来说可能是不支持的，这时我们就可以通过 Babel 和 browserslist 进行结合，将我们使用到的 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。12345module.exports = { presets: [ '@vue/app', ],}; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对 js 代码的转换可以使用到 Babel，那么对于同样可能出现浏览器不兼容的 css 样式，这里我们就可以通过使用 postcss + Autoprefixer + browserslist 识别出需要指定支持的浏览器类型和版本，自动添加所需的带前缀的属性声明。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PostCSS 本身是一个功能比较单一的工具，它一般会和 webpack、gulp 这种前端构建工具进行结合使用，通过使用 postcss 可以支持变量和混入（mixin），增加浏览器相关的声明前缀，或是把使用将来的 CSS 规范的样式规则转译（transpile）成当前的 CSS 规范支持的格式。123#content { display: flex;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而 Autoprefixer 的作用就是为 CSS 中的属性添加浏览器特定的前缀，例如上面的代码，使用了 flex 的布局模式，在经过 Autoprefixer 处理之后得到的 CSS 代码则如下所示。123456#content { display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、代码风格的设定 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在前端项目开发中，因为对于编辑器或是使用的操作系统不会有太严格的限定，例如这里我是使用 VS Code 在 Windows 10 上进行开发的，你完全可以选择 Atom + MacOS 或是 VS Code + Ubuntu 等等组合去打开我的这个项目，然后去进行开发，而不同的编辑器和操作系统对代码的展示会有些许的差异，所以这里我们就需要对项目的代码规范进行一个设定。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对不同编辑器的风格设定，这里使用的是 editorconfig，我们可以在 .editorconfig 文件中去设定项目规范，编辑器通过加载 editorconfig 插件之后，就可以通过读取这个配置文件，来覆盖编辑器自带的代码规范，从而达到整个项目代码风格统一的效果。1234567891011121314151617181920212223# 是否为最顶层的配置文件root = true# 匹配文件规则[*.{js,jsx,ts,tsx,vue}]# 代码缩进方式indent_style = space# 缩进的空格数indent_size = 2# 定义换行符end_of_line = lf# 是否去处行首行尾的空白字符trim_trailing_whitespace = true# 文件是否以空白行结尾insert_final_newline = true# 每行代码的最大长度max_line_length = 100 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们指定风格之后，需要有一个工具去辅助我们进行校验，通常我们会使用 ESLint 去对我们的代码进行检查，在我们通过 Vue CLI 去创建项目时其实已经加载了 ESLint 插件并选择了代码风格。这里我是使用的 airbnb 的 vue 代码风格和 eslint 强烈推荐的规则，你可以按照你自己的喜好去修改这块的设定。123456789101112131415161718192021module.exports = { root: true, env: { node: true, }, extends: [ 'plugin:vue/strongly-recommended', '@vue/airbnb', ], rules: { 'no-console': 'off', 'no-debugger': 'off', }, parserOptions: { parser: 'babel-eslint', },}; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、环境变量的设置 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正常情况下，我们的线上版本、开发版本、测试版本一些对应的请求地址是不一样的，如果我们直接把请求地址写到代码中，在后期的修改就会变得很麻烦，因此这里我们就需要对我们的项目进行环境设定。默认情况下，一个通过 Vue CLI 构建的项目会有三个环境变量，分别为 development、production、test，其实这里的 3 个环境变量就对应了我们的 package.json 中的 已经定义了的 npm 命令。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们添加 3 个环境变量文件 .env.development(开发环境)、.env.production(生产环境)、.env.staging(预发布环境) 分别对应于不同的环境的一些参数信息。因为默认是没有 staging 这个环境的，所以我们需要在 package.json 文件中去添加 staging 脚本，从而去构建出 staging 环境。1\"stage\": \"vue-cli-service build --mode staging\" &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;staging 环境的示例如下所示，不过，这里需要注意，因为只有以 VUE_APP_ 开头的变量会被 webpack.DefinePlugin 静态嵌入到客户端中，因此，如果我们想要在代码中获取到这里定义的变量值，我们只能以 VUE_APP_ 开头去定义环境变量中会使用到的参数。12345678# Node ENV 变量值NODE_ENV = production# staging 环境标识ENV = &apos;staging&apos;# 后端 API 地址VUE_APP_BASE_API_URL = &apos;http://127.0.0.1/stage-api&apos; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5、package.json &amp; package-lock.json &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在项目开发中，因为我们是使用 npm 去加载前端的组件，所以会存在 package.json 这个配置文件。在这个 json 文件中定义了这个项目所需要的各种前端模块，以及项目的配置信息（比如名称、版本、许可证等等）。当我们从别处拷贝这个项目后，通过执行 npm install 命令，就会根据这个配置文件，自动下载项目中所需要引用的前端组件包。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 package.json 这个 json 文件中存在着两个看起来很相似的节点：devDependencies 和 dependencies。devDependencies 里面的插件只适用于开发环境，不用于生产环境，而 dependencies 中引用的则是需要发布到生产环境中的。我们可以在使用 npm install 命令加载组件时通过添加 –save 修饰，表示需要将该组件添加到 dependencies 节点下面；如果你需要将引用到的 package 安装到 devDependencies 节点下，则需要使用 –save-dev 进行修饰。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为我们在 npm 上下载的包遵循了大版本.次要版本.小版本的版本定义，而在安装插件包的时候，package.json 一般指定的是包的范围，即只对插件包的大版本进行限定。因此，当别人拷贝了你的代码，准备还原引用的包时，如果恰好在组件包更新中移除了你使用的一些特性，毫无疑问，整个项目代码就会报错。而 package-lock.json 这个文件，则可以记录实际安装的各个 package 的具体来源和版本号，此时，当别人拷贝了代码，准备还原时，就可以准确的加载到你开发时使用的组件版本。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6、webpack 配置 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面我们有提到，Vue CLI 本质上也是基于 webpack 去构建的 Vue 项目，如果你有使用过 Vue CLI 2 去创建项目，你会发现原本对于 webpack 配置的 webpack.base.config.js、webpack.dev.config.js 、webpack.prod.config.js 这些配置文件已经没有了。那么这里如何去按照自己的习惯去对 webpack 进行一个调整呢？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原来，因为 Vue CLI 3 的设计思想是 0 配置，所以通过 Vue CLI 3 构建的 Vue 项目已经帮开发者已经解决绝大部分情形下的 webpack 配置，如果你有需要做一些自定义的设置，则可以去创建一个 vue.config.js 去进行自定义的配置。这里就不对配置的内容进行介绍了，我会放到下一章中去介绍这个项目对于 webpack 的一些配置。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此，我们对于模板项目的调整也就到一段路，最终我们修改完成后的项目分层如下图所示，后续我也将在这个调整后的结构上进行搭建项目模板。 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一章主要是在上一章通过 Vue CLI 3 创建好的模板项目基础上，去弄清楚项目中的各个文件到底是做什么的，以及按照我们的开发习惯进行了一个调整。在后续的文章中，我会在这个调整后的模板基础上进行开发，去构建出一个符合自己开发习惯的前端项目框架。 参考&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、从0到1搭建Element的后台框架&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、vue-cli3 项目从搭建优化到docker部署&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、一张图教你快速玩转vue-cli3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、手摸手，带你用vue撸后台 系列四(vueAdmin 一个极简的后台基础模板)","link":"/2019/09/15/vue-cli3-template-project-introduce/"}],"tags":[{"name":"asp-net-core","slug":"asp-net-core","link":"/tags/asp-net-core/"},{"name":"vue-js","slug":"vue-js","link":"/tags/vue-js/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"feeling","slug":"feeling","link":"/tags/feeling/"},{"name":"collections","slug":"collections","link":"/tags/collections/"},{"name":"planning","slug":"planning","link":"/tags/planning/"},{"name":"angular","slug":"angular","link":"/tags/angular/"},{"name":"devops","slug":"devops","link":"/tags/devops/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"csharp","slug":"csharp","link":"/tags/csharp/"},{"name":"elastic-stack","slug":"elastic-stack","link":"/tags/elastic-stack/"},{"name":"domain-driven-design","slug":"domain-driven-design","link":"/tags/domain-driven-design/"}],"categories":[{"name":"learning","slug":"learning","link":"/categories/learning/"},{"name":"mumble","slug":"mumble","link":"/categories/mumble/"},{"name":"excerpts","slug":"excerpts","link":"/categories/excerpts/"},{"name":"skills","slug":"skills","link":"/categories/skills/"}]}